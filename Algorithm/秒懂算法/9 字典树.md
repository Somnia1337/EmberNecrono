## 1. 字典树

字典树(trie)：一种适合自动补全等文字类功能的树。

字典树不是二叉树，每个节点可以有任意数量的子节点。

每个节点持有一张哈希表，key为英文字母("a"，"b"等)，value为其子节点。

## 2. 存储单词

![[Snipaste_ 230526_163610.png|300]]

字典树将单词的每个字母单独存储在节点中，自上而下依次读取节点的字母就拼出了单词。

星号表示该单词结束，很多时候一个短词是另一个长词的开头，只需再加一个key。

![[Snipaste_ 230526_164044.png|400]]

## 3. 字典树查找

字典树查找是最常用的操作，它分为两类：检查字符串是否为完整单词、或者是否至少是另一个完整单词的开头，实际上，第二类包含了第一类。

字典树查找的步骤：

1. 创建一个变量`currentNode`，初始化为指向根节点。
2. 遍历目标串的每个字母。
	1. 检查`currentNode`当前指向的节点是否有以当前字母为key的子节点，如果没有，则返回false。
	2. 将`currentNode`更新为指向该子节点，继续遍历字母。
3. 成功遍历结束后，返回true。

字典树查找操作的步骤数等于单词的长度，这很难用大O表示（如果步骤数不固定就不是$O(1)$，而$N$表示数据量，用$O(N)$也不准确），大部分资料将其表示为$O(K)$，$K$为目标串的长度。

对$O(K)$来说，字典树的数据量不会影响查找速度，因为后者只取决于目标串的长度，因此它非常高效。

## 4. 字典树插入

字典树插入的步骤：

1. 创建一个变量`currentNode`，初始化为指向根节点。
2. 遍历目标串的每个字母。
	1. 检查`currentNode`当前指向的节点是否有以当前字母为key的子节点，如果没有，则新建该子节点。
	2. 将`currentNode`更新为指向该子节点，继续遍历字母。
3. 插入最后一个字母时，为最后一个节点添加一个"\*"子节点，表示这是一个完整单词。

与查找一样，插入操作的复杂度也为$O(K)$。