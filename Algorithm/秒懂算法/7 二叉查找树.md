如果经常要保证数据的顺序，最好让数据一开始就按一定顺序排列；哈希表的各种操作速度都很快，却不支持排序；二叉查找树则兼顾了顺序与速度。

## 1. 树

树类似于链表，也是基于节点的数据结构，不过其节点可以指向多个节点。

术语：

- 最顶端的节点称为根节点，其位置称为树顶。
- 上端的节点称为下端节点的父节点，反之称为子节点。
- 树具有层级，每一行构成一层。
- 如果各节点的子树中节点数量相同，则称此树是平衡的。

## 2. 二叉查找树

二叉树：每个节点的子节点数量都为0、1或2的树。

二叉查找树：遵循以下规则的二叉树：

- 每个节点最多有一个左子节点与一个右子节点。
- 一个节点的左子树中的值均小于节点自身，右子树中的值均大于节点自身。

![[Snipaste_ 230522_201657.png|200]]

## 3. 查找

由于二叉查找树的特殊结构，查找目标值时只需不断与当前节点比较：

- 目标值 < 当前节点：向左子树继续。
- 目标值 > 当前节点：向右子树继续。

每次比较都能排除一半的剩余节点，因此对于平衡的二叉查找树，其查找算法复杂度为$O(\log N)$。

## 4. 插入

向二叉查找树插入值前，先检查其应该处于的节点上是否已有值，若还没有，则插入其父节点的左子树或右子树。

二叉查找树插入操作的复杂度为$O(\log N)$。

通常要在数据随机排列的情况下插入，才能构建平衡的树，例如，要插入1~5，如果从1开始顺序插入则会产生线性的树：

![[Snipaste_ 230523_190530.png|100]]

在树中查找值5需要5步。

如果按3、2、4、1、5的顺序插入，则会构建平衡的树：

![[Snipaste_ 230523_190714.png|100]]

因此，将有序数组转换为二叉查找树之前，应该先随机打乱顺序。

## 5. 删除

删除一个有子节点的节点时，需要安排其子节点到新的位置。

### 1) 删除有一个子节点的节点

在删除节点的同时将子节点插入到其原位置。

### 2) 删除有两个子节点的节点

删除节点的同时将其一个后继节点插入到其原位置，该后继节点是大于被删除节点的所有子节点中最小的一个（如果按升序排列删除目标节点及其后继节点，那么替代其位置的将是其后的第一个后继节点）。

寻找后继节点时，先移动到被删除节点的右子节点，然后一直往左子树移动，直到不再有子树（也即删除节点的右子树里最左下角的节点）。

### 3) 删除有一个子节点且其有一个右子节点的节点

删除结点的同时将子节点插入到其原位置，并将子节点的右子节点插入删除节点的左子节点位置。

### 4) 完整规则

- 如果要删除的节点没有子节点，那么就直接删除该节点。
- 如果要删除的节点有一个子节点，那么就在删除该节点的同时把子节点插到该节点的位置。
- 要删除有两个子节点的节点，需要把要删除的节点替换为其后继节点。后继节点就是大于被删除节点的所有子节点中最小的那个。
- 要寻找后继节点，需要先移动到被删除节点的右子节点，然后一直沿着左边的链接移动到左子节点，直到找不到任何左子节点为止。最下面的这个值就是后继节点。
- 如果后继节点有一个右子节点，那么在把后继节点放到被删除节点的位置之后，把这个右子节点变成后继节点曾经的父节点的左子节点。