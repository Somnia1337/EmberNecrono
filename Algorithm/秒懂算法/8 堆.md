堆也是一种树，适合需要一直记录数据中的最值的情况。

## 1. 优先队列

优先队列的删除和读取与传统队列相同，只能从队头进行，但其插入类似于有序数组，每次插入都要确保数据有序排列。

优先队列也是一种抽象数据结构，可以使用有序数组实现，也就是给数组加上以下限制：

- 插入数据时需要确保有序。
- 只能从数组末尾（表示优先队列的队头）删除数据（从数组末尾删除复杂度最低，为$O(1)$）。

但是插入元素时复杂度为$O(N)$，效率较低，所以通常使用堆来实现优先队列。

## 2. 堆

堆有很多种，此处重点关注二叉堆。

二叉堆是一种特殊的二叉树，分为最大堆与最小堆两类，重点关注最大堆（其实差异很小），下文简称堆。

堆是一棵满足以下条件的二叉树：

- 每个节点的值都大于其所有后代节点的值（也称堆条件）。
- 树必须是完全的（见下文）。

### 1) 堆条件

二叉查找树的每个节点值都小于其右节点值，而堆的每个节点值都绝不能小于其后代的任何节点值。

### 2) 完全树

完全树：填满了节点的树，“填满”指只有最底层可以有空位置，且空位置右侧不能有节点。

一棵非完全树：
![[Snipaste_ 230524_191554.png|100]]

一棵完全树：
![[Snipaste_ 230524_191654.png|100]]

堆就是一棵满足堆条件的完全树。

一个堆：
![[Snipaste_ 230524_191757.png|300]]

## 3. 堆的性质

虽然堆条件使堆保持了一定的顺序，但是此顺序对于堆查找没有帮助，例如，要在上图的堆中查找3，从根节点100开始，只能确知如果3存在、那么一定在100的子树下面，但完全不知道接下来该查找哪棵子树。因此，与二叉查找树相比，堆是一种弱排序的数据结构。

堆的根节点值总是最大值（对于最小堆则是最小值），这也是堆适合实现优先队列的关键。

堆的主要操作为插入与删除，由于堆查找需要检查每个节点值，因此通常不实现查找。

堆的尾节点为最底层最右侧的节点。

## 4. 堆的插入

将新数据插入堆时的步骤：

1. 创建一个新节点存储新数据，将其插入最下面一层右侧空缺的第一个位置中，使其成为尾节点。
2. 比较新节点与其父节点的值，如果新节点值更大，则交换二者位置。
3. 满足条件时重复第2步。

堆的插入操作复杂度为$O(\log N)$。

## 5. 堆的删除

只有根节点可以被删除，这与优先队列只读取、删除最高优先级的数据一致。

删除根节点的步骤：

1. 用尾节点覆盖根节点。
2. 将尾节点下滤到正确位置：如果下滤节点小于其两个子节点中较大的一个，就交换二者，直到不存在比其大的子节点。

堆的删除操作复杂度为$O(\log N)$。

## 6. 寻找尾节点

插入与删除操作的第一步都需要查找尾节点。

有时尾节点并不在根节点的右子树中：
![[Snipaste_ 230524_193004.png|200]]

遍历所有节点可以找到尾节点，但效率很低，为了提高效率，堆通常使用数组实现。

![[Snipaste_ 230525_091357.png|300]]

堆节点对应数组索引的规律：从根节点开始，逐行向下、向右排列，这样一来，尾节点总是数组的最后一个元素。

在数组实现的堆中，节点对应的索引有以下特性：

- 左子节点索引为`(index * 2) + 1`。
- 右子节点索引为`(index * 2) + 2`。
- 父节点索引为`(index - 1) / 2`。

## 7. 用堆实现优先队列

堆的弱排序是其实现优先队列的优点，由于插入时无需完全保序，因此比有序数组的插入更高效；同时它又有一定的顺序，可以高效地读取最大值。