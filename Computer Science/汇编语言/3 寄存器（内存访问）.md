👈 [[2 寄存器]]

### 内存中字的存储

字单元：存放一个字型数据（$16$ 位）的内存单元，由 2 个地址连续的内存单元组成，高地址内存单元存放高位字节，低地址内存单元存放低位字节。

### DS 和 \[address]

DS 寄存器存储要访问的数据的段地址。

将 `1000:0` 的数据读入 AL：

```asmatmel
mov bx, 1000H
mov ds, bx
mov al, [0]
```

理论上，似乎可以用 `mov ds, 1000H` 直接修改 DS，但实际上不能对段寄存器（DS）这样做，而必须通过另一个寄存器中转。

最后一句 `mov al, [0]` 中，`[addr]` 表示偏移地址为 `addr` 的内存单元，此处偏移地址为 `0`，又有段地址为 DS = `1000H`，即将内存单元 `1000:0` 的内容写入 AX。

### 字的传送

在 `mov` 指令中给出 $16$ 位的寄存器即可进行 $16$ 位数据（字）的传送：

```asmatmel
mov bx, 1000H
mov ds, bx
mov ax, [0] ; 将 1000:0 处的字写入 AX
mov [0], cx ; 将 CX 中的字写入 1000:0
```

如果使用 `mov al, [addr]`，即目标寄存器为 $8$ 位，则只会传送 `[addr]` 的内容（$8$ 位），而不是 `[addr+1]` 与 `[addr]` 组合的字。

### `mov`、`add`、`sub` 指令

`mov` 有如下命令形式：

```asmatmel
mov 寄存器, 数据 (不可换)
mov 寄存器, 寄存器
mov 寄存器, 内存单元
mov 段寄存器, 寄存器/段寄存器
```

### 数据段

将 `123B0H` ~ `123B9H` 的内存单元定义为数据段，累加段中前 3 个单元中的数据：

```asmatmel
mov ax, 123BH
mov ds, ax
mov al, 0 ; 将累加结果存储在 AL
add al, [0]
add al, [1]
add al, [2]
```

如果是累加前 3 个字型数据：

```asmatmel
mov ax, 123BH
mov ds, ax
mov al, 0 ; 将累加结果存储在 AL
add al, [0]
add al, [2] ; 现在,
add al, [4] ; 偏移量要改为 2
```

> 小结：
> 
> - 内存中用 2 个地址连续的内存单元存放一个字，字的高、低位分别与单元的高、低地址单元对应。
> - 用 `mov` 访问内存单元时，只需给出偏移地址 `[addr]`，因为段地址在 DS 中。

### 栈

LIFO。

### CPU 提供的栈机制

8086CPU 提供 `push` 和 `pop`：

- `push ax`：将 AX 的数据压栈。
- `pop ax`：弹栈并存入 AX。

压栈，并按原顺序存回：

```asmatmel
mov ax, 0123H
push ax
mov bx, 2266H
push bx
mov cx, 1122H
push cx
pop cx
pop bx
pop ax
```

两个问题：

- 如何知道某段空间作为栈使用？
- 如何知道栈顶的位置？

段寄存器 SS 和寄存器 SP：任何时刻，`SS:SP` 指向栈顶元素。

`push` 和 `pop` 的执行过程：

`push ax`：

1. `SP = SP - 2`，`SS:SP` 指向栈顶前面的单元，作为新的栈顶。
2. 将 AX 的数据写入栈顶。

![[Snipaste_240311_183654.png]]

`pop ax`：

1. 将 `SS:SP` 指向的单元内容写入 AX。
2. `SP = SP + 2`，`SS:SP` 指向栈顶后面的单元，作为新的栈顶。

![[Snipaste_240311_183903.png]]

出栈后，被“弹出”的元素其实还存储在原来的空间，但是已不在栈中，将被稍后入栈的内容所覆盖。

将 `10000H` ~ `1000FH` 作为栈空间，初始时栈为空，SS = `1000H`，此时 SP = ?

-> SP = `0010H`。

![[Snipaste_240311_184045.png]]

栈空时，`SS:SP` 指向栈底的下一个单元。

### 栈顶超界的问题

8086CPU 没有机制确保栈操作不会越界，在编程时需要自己注意此问题。

### `push`、`pop` 指令

除了 `push/pop 寄存器`，还有 `push/pop 段寄存器`，以及 `push/pop [addr]`。

`push` 和 `pop` 实际上就是内存传送指令，与 `mov` 的区别在于：

- 地址的给出：`push` 和 `pop` 的目标地址（栈顶）由 `SS:SP` 给出。
- 是否修改寄存器值：`push` 和 `pop` 将修改 SP（不过不修改 SS）。

> 小结：
> 
> - `push` 的执行：先修改 SP（`-2`），后写入 `SS:SP`。
> - `pop` 的执行：先读取 `SS:SP`，后修改 `SP`（`+2`）。
> - 8086CPU 只记录栈顶，栈空间的大小需要手动管理。

### 栈段

“段”是程序员的逻辑安排：用一个段存放 数据 / 代码 / 栈，这个段就称为 数据 / 代码 / 栈 段。

固定 SS，只修改 SP，则栈顶的变化范围为 `0` ~ `FFFFH`，一个栈段的容量最大为 $64$ kB。

👉 [[4 第一个程序]]