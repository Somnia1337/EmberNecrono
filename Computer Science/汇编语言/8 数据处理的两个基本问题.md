👈 [[7 更灵活的定位内存地址的方法]]

两个基本问题：

- 数据的位置
- 数据的长度

以后用 reg 表示一个寄存器，sreg 表示一个段寄存器：

- reg：AX，BX，CX，DX，AH，AL，BH，BL，CH，CL，DH，DL，SP，BP，SI，DI
- sreg：DS，SS，CS，ES

### BX、SI、DI 和 DP

- 只有这 4 个寄存器能用在 `[...]` 中对内存单元寻址。
- 在 `[...]` 中，它们只能单独出现、或者以 4 种组合出现：
	- BX & SI
	- BX & DI
	- BP & SI
	- BP & DI
- 如果在 `[...]` 使用 BP 且不显式指定段地址，则默认从 SS 中取。

### 机器指令处理的数据在什么地方

一条机器指令执行的前一刻，数据可能在 3 个地方：

- CPU 内部
- 内存
- 端口

| 机器码        | 汇编指令          | 数据位置         |
| ---------- | ------------- | ------------ |
| `8E1E0000` | `mov bx, [0]` | 内存，`ds:0` 单元 |
| `89C3`     | `mov bx, ax`  | CPU 内部，AX    |
| `BB0100`   | `mov bx, 1`   | CPU 内部，指令缓冲器 |

### 汇编语言中数据位置的表达

- 立即数 `idata`：在指令中给出。
- 寄存器：在指令中给出寄存器名。
- 段地址 (SA) 和偏移地址 (EA)：用 `[X]` 给出 EA，而 SA 从某个 sreg 取：
	- 可以采取默认：
		- 如果为 `[idata]` / `[di/bx/si]`，默认从 DS 中取。
		- 如果为 `[bp]`，默认从 SS 中取。
	- 也可以显式指定，如 `mov ax, ds:[bp]`。

### 寻址方式

![[Snipaste_240326_191705.png|600]]

### 指令要处理的数据有多长

在机器指令中需要指出进行字操作还是字节操作：

- 通过寄存器名指定，如 `mov ax, 1` 中 `ax` 指明了进行字操作。
- 用操作符 `X ptr` 指定内存单元的长度，其中 `X` 取 `word` / `byte`，如 `mov word ptr ds:[0], 1`。
- 有些指令默认了数据长度，如 `push [1000H]` 中 `push` 只进行字操作。

### 寻址方式的综合应用 🚫

skip

### `div` 指令

`div` 是除法指令。

| 项   | 位       | 位置                                 |
| --- | ------- | ---------------------------------- |
| 被除数 | 16 / 32 | AX / (DX 和 AX)                     |
| 除数  | 8 / 16  | reg 或内存                            |
| 结果  | 8 / 16  | AL 存商 & AH 存余数 /<br>AX 存商 & DX 存余数 |

计算 $1001 \div 100$：

```asmatmel
mov ax, 1001
mov bl, 100
div bl
```

执行后，AL = `0AH`(`10`)，AH = `1`。

计算 $100001 \div 100$：

```asmatmel
mov dx, 1
mov ax, 86A1H
mov bx, 100
div bx
```

执行后，AX = `03E8H`(`1000`)，DX = `1`。

### 伪指令 `dd`

类似于 `db`、`dw`，`dd` 用于定义双字型数据：

```asmatmel
data segment
	db 1 ; data:0 处, 01H, 占 1 字节
	dw 1 ; data:1 处, 0001H, 占 1 字
	dd 1 ; data:3 处, 00000001H, 占 2 字
data ends
```

### `dup`

`dup` 配合 `db`、`dw`、`dd` 使用，进行数据的重复：

```asmatmel
data segment
	db 3 dup (0) ; 相当于 db 0, 0, 0
	dw 2 dup (0, 1, 2) ; 相当于 dw 0, 1, 2, 0, 1, 2
data ends
```

👉 [[9 转移指令的原理]]