👈 [[1 基础知识]]

寄存器是 CPU 中的存储单元，可以由程序员用指令读写。

8086CPU 的所有寄存器都是 $16$ 位的，可以存放 $2$ Byte。

### 通用寄存器

AX、BX、CX、DX 这 4 个寄存器常用于存放一般性的数据，称为通用寄存器。

为了向前兼容，这 4 个寄存器都各自可分为 2 个 $8$ 位的寄存器单独使用，存放 $1$ Byte，如 AX 可分为 AH 与 AL。

![[Snipaste_240310_102919.png|500]]

### 字在寄存器中的存储

**字**(word)：2 个 Byte。

![[Snipaste_240310_103219.png|300]]

将一个字存储在 $16$ 位寄存器中，它的高、低位字节恰好分位于寄存器的高、低位部分寄存器中。

### 几条汇编指令

`mov`：

```asmatmel
mov ax, 18 ; AX = 18
mov bl, ah ; BL = AH
```

`add`：

```asmatmel
add bx, 31 ; BX = BX + 31
add al, bh ; AL = AL + BH
```

进位溢出：无论操作的寄存器是完整寄存器（如 AX）还是部分寄存器（如 BL），计算产生的进位溢出都会丢失。

- AX = `8226H`，执行 `add ax, 8226H`：计算结果为 `1044CH`，最高位 `1` 溢出而丢失，实际存储 AX = `044CH`。
- BX = `00C5H`，执行 `add bl, 93H`：计算结果为 `158H`，最高位 `1` 溢出而丢失，实际存储 BX = `0058H`。

### 物理地址

物理地址：每个内存单元在内存地址空间中的唯一地址。

### $16$ 位结构的 CPU

$16$ 位结构的 CPU 是指：

- 运算器一次最多可以处理 $16$ 位的数据。
- 寄存器的最大宽度为 $16$ 位。
- 寄存器和运算器之间的通路为 $16$ 位。

### 8086CPU 给出物理地址的方法

8086CPU 为 $16$ 位结构，能够一次性处理、传输、暂时存储的地址为 $16$ 位，如果将地址简单地发出，那么寻址能力仅为 $64$ kB。

实际上，8086CPU 在内部将 2 个 $16$ 位地址合成为一个 $20$ 位的物理地址。

![[Snipaste_240310_140857.png|500]]

要读写内存时，8086CPU 提供一个段地址与一个偏移地址，二者根据公式：$$物理地址 = 段地址 \times 16 + 偏移地址$$ 合成实际的物理地址。

在 $16$ 进制下，$\times 16$ 相当于左移 $1$ 位。如段地址为 `1230H`，偏移地址为 `00C8H`，则物理地址为 `1230H<<1 + 00C8H = 12300H + 00C8H = 123C8H`。

### “$段地址 \times 16 + 偏移地址 = 物理地址$”的本质含义

CPU 在访问内存时，将一个基础地址与一个偏移地址相加得到内存单元的物理地址，即：$$物理地址 = 基础地址 + 偏移地址$$

8086CPU 的寻址方法是这个通用思想的一种实现。

用纸条上的信息类比：设有两张纸条 $a$，$b$，各能够容纳 $3$ 位数字，而现在希望用它们表达一个 $4$ 位数字，那么可以事先约定 $结果 = a \times 10 + b$，拿到纸条后根据公式进行拼接就能得出结果。

### 段的概念

误解：内存被划分为若干段，每段有自己的段地址。

段的划分是一个由 CPU 这种寻址方式产生的逻辑概念，是为了编程需要而将若干地址连续的内存视作的假想的结构。

> 小结：
> 
> 如果给定段地址为 `1000H`，仅通过变化 $16$ 位的偏移地址进行寻址：
> 
> - 偏移地址可取 $[$`0`$,$`FFFFH`$]$。
> - 地址范围为 $[$`10000H`$,$`1FFFFH`$]$。
> - 寻址能力为 $64$ kB。
> - 
> 
> 一般不说“数据在 `21F60H` 内存单元中”，而是说：
> 
> - 数据在 `2000:1F60` 内存单元中。
> - 数据在内存 `2000H` 段的 `1F60H` 单元中。
> 
> 可根据实际需要，将地址连续、起始地址为 $16$ 的倍数的一组内存单元定义为一个段。

### 段寄存器

段地址存储在 8086CPU 的段寄存器：CS、DS、SS、ES，本章关注 CS。

### CS 和 IP

CS 是代码段寄存器，IP 是指令指针寄存器，它们是 8086CPU 中两个最重要的寄存器，它们指示了 CPU 当前要读取指令的地址，即：CPU 总是将 CS:IP 指向的内容视为指令执行。

8086CPU 读取、执行指令的过程：

![[Snipaste_240310_144656.png]]

1. 从 CS 和 IP 读取段地址和偏移地址，在地址加法器中计算物理地址。
2. 将物理地址传输到 I/O 控制电路。
3. 将物理地址传输到地址总线。
4. 从内存中找到目标指令，传输到数据总线。
5. 将指令传输到 I/O 控制电路。
6. 将指令传输到指令缓冲器。
7. IP 自增，以本次获取指令的长度作为增量，以便读取下一条指令。此时，本次读取的指令尚未执行。
8. 执行控制器执行本次读取的指令。
9. 指令对 AX / BX 等其他部件产生作用。

### 修改 CS、IP 的指令

`mov` 指令用于修改寄存器的值，如 `mov ax, 0123`。类似地，`jmp` 指令用于修改 CS、IP 的值：

- 同时修改二者：`jmp 段地址:偏移地址`，执行 `jmp 2AE3:3` 后 CS = `2AE3H`、IP = `0003H`。
- 仅修改 IP：`jmp 寄存器`，设 AX = `1000H`，执行 `jmp ax` 后 CS 不变、IP = `1000H`。

### 代码段

可以将一组代码写入一组地址连续、起始地址为 $16$ 的倍数的内存单元中，从而将其视为一个（代码）段。

想要让 CPU 执行代码段，需要修改 CS:IP，使其指向段首。如果代码段为 `123B0H` ~ `123B9H`，修改 CS = `123BH`，IP = `0000H`。

> 小结：
> 
> - 8086CPU 有 4 个段寄存器，其中 CS 存储段地址，IP 存储偏移地址。
> - 8086CPU 读取、执行指令的过程：
> 	1. 从 CS:IP 指向的内存单元读取指令，进入指令缓冲器。
> 	2. IP 自增，指向下一条指令。
> 	3. 执行本次读取的指令。
> 	4. 转到 1。
> - `jmp` 指令可以修改 CS、IP 的值。

👉 [[3 寄存器（内存访问）]]