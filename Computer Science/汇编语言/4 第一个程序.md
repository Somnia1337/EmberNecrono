👈 [[3 寄存器（内存访问）]]

### 一个源程序从写出到执行的过程

1. 编写汇编源程序 => 产生一个存储源程序的文本文件。
2. 编译链接源程序 => 产生了一个可执行文件，包括程序和数据、相关描述信息。
3. 执行该文件。

### 源程序

```asmatmel
assume cs:codesg

codesg segment
	mov ax, 0123H
	mov bx, 0456H
	add ax, bx
	add ax, ax
	
	mov ax, 4C00H
	int 21H
codesg ends

end
```

源程序中包含汇编指令和伪指令，后者有：

```asmatmel
段名 segment
	...
段名 ends
```

`segment` 和 `ends` 成对使用，定义了一个段的开始和结束。

一个汇编程序中至少要有一个代码段。

```asmatmel
end
```

`end` 标记了一个源程序的结束。注意区分 `ends` 和 `end`。

```asmatmel
assume 段寄存器:段名
```

`assume` 假设一个段寄存器与程序中的一个段相关联。

称整个源程序文件为源程序，称源程序中最终由计算机处理、执行的数据和指令为程序。程序先以汇编指令的形式存储在源程序中，经编译、连接后以机器码的形式存储在可执行文件中。

![[Snipaste_240313_145659.png|500]]

实现程序返回的语句：

```asmatmel
mov ax, 4C00H
int 21H
```

目前只需知道，在程序末尾使用这 2 条指令就能够使程序返回。

与“结束”相关的概念：

| 目的       | 指令                           | 性质   | 执行者      |
| -------- | ---------------------------- | ---- | -------- |
| 标记一个段的结束 | `段名 ends`                    | 伪指令  | 编译器（编译时） |
| 标记程序的结束  | `end`                        | 伪指令  | 编译器（编译时） |
| 程序返回     | `mov ax, 4C00H`<br>`int 21H` | 汇编指令 | CPU（执行时） |

### 编辑源程序

![[Snipaste_240314_154602.png|500]]

### 编译

![[Snipaste_240314_154712.png|500]]

### 连接

![[Snipaste_240314_154800.png|500]]

### 以简化的方式进行编译和连接

上图即使用了简写方式。

### `1.exe` 的执行

![[Snipaste_240314_154945.png|500]]

### 谁将可执行文件中的程序装载进入内存并使它运行？

1. 在提示符 `c:masm` 后面输入可执行文件的名字 `1`，按 `[Enter]`。这时，正在运行的 command 将 `1.exe` 中的程序加载到内存中。
2. command 设置 CPU 的 `CS:IP` 指向第一条指令，从而使 `1.exe` 中的程序运行。
3. 运行结束，返回到 command，CPU 继续运行 command，再次显示提示符 `c:masm`。

汇编程序从编写到执行完成的过程：

```text
	编程(edit) => 1.asm
->  编译(masm) => 1.obj
->  连接(link) => 1.exe
->  加载(command) => 内存中的程序
->  运行(CPU)
```

### 程序执行过程的跟踪

```text
debug 1.exe
-r
-u
```

![[Snipaste_240314_155750.png|500]]

`1.exe` 中的程序的加载过程：

![[Snipaste_240314_155857.png|500]]

用 T 命令逐条执行（对于最后返回的指令，书上要求用 P 命令，但本 Debug 版本不支持，所以仍用 T 命令）：

![[Snipaste_240314_160153.png|500]]

👉 [[5 BX 和 loop 指令]]