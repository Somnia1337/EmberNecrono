### 需求及建模

#### 需求工程

#### 需求模型

4 种模型要素：

基于场景的元素

用户视角，如基本用例及其相应的用例图

用例图，活动图，泳道图

基于类的元素

当参与者和系统交互时所操作的一组对象，这些对象被分成类—具有相似属性和共同行为的事物集合。如类图

类图、CRC 模型、collaboration 图

行为元素

描述行为的建模元素。如状态图

状态图、时序图

面向数据流的元素

信息在系统中流动时会被转换，系统接收多种形式的输入，使用函数将其转换，生成多种形式的输出。

数据流图、控制流图、

##### 三种模型

数据模型

WHY：

Examine the data objects of processing independently

Focus attention on the data domain

Create a model of abstraction at the customer’s level

Indicate how data objects relate to one another

E-R 图；数据字典；

功能模型

DFD；

行为模型

显示软件如何对外部事件或激励做出响应

状态转换图、_Control Specification、Process Specification、序列图_

#### OOA（面向对象分析）

##### 定义

is to develop a model that describes computer software as it works to satisfy a set of customer-defined requirements.

##### 用例图：

Use-cases are simply 帮助定义系统外部存在的内容以及系统应该执行的内容。.

*    A scenario that describes a “thread of usage” for a system
*    _Actors_ represent roles people or devices play as the system functions
*    _Users_ can play a member of different roles for a given scenario

用例图、活动图、时序图、状态图、分析类图、协作图

#### SA（结构化分析模型）

Structured analysis is a model building activity

* The products of analysis must be highly maintainable.
* The size of problems must be controlled.
* Graphics have to be used whenever possible.
* We have to differentiate between logical and physical.

数据模型：E-R、数据字典（DD）、DOD

为什么用数据模型：

1）Examine the data objects of processing independently.

2）Focus attention on the data domain.

3）Create a model of abstraction at the customer’s level

4）Indicate how data objects relate to one another

功能模型：DFD

行为模型：STD（状态转换图）、PSPEC、CSPEC

### 系统设计

#### 设计概念

##### 抽象：

对问题所处环境的语言以概括性的术语描述解决方案，在最高的抽象级上，使用问题所处环境的语言以概括性的术语描述解决方案，在较低的抽象级上，将提供更详细的解决方案说明。

过程抽象：暗示功能，隐藏细节

数据抽象：描述数据对象的冠名数据集合

##### 体系结构：

软件整体结构和这种结构为系统提供概念完整性的方法。

属性：

结构特性：定义了系统的构件、系统被封装的方式以及构件之间相互作用的方式。

外部功能特性：指出体系结构如何满足需求，包括性能需求，能力需求，可靠性需求，安全需求，可适性需求以及其他系统特征需求。

相关系统簇：能抽取出一类相似系统开发中经常遇到的重复性模式。本质上，设计应当能够重用体系结构构件。

##### 模式：

设计模式描述了在某个特定场景可能影响模式应用和使用方式的 “影响力” 中解决某个特定的设计问题的设计结构

##### 模块化：

关注点分离最常见的表现，软件被划分为独立命名、可处理的构建，把这些构建集成到一起可以满足问题的需求。

##### 信息隐藏：

每块模块对其他所有模块隐藏自己的设计决策，模块规定并设计成为在模块中包含的信息不被不需要这些信息的其他模块访问。

##### 关注点分离

设计概念，表面任何复杂的问题如歌被分解成可以独立解决和优化的若干块，该复杂问题能够更容易地被处理。

##### 功能独立：

标准：内聚性和耦合性

##### 重构

重新组织技术，可以简化构建设计而无需改变其功能或行为

##### 内聚（cohesion）

信息隐藏概念的自然扩展，一个内聚的模块只有一个独立的任务。将内聚性描述为构件的专一性，在为面向对象系统进行构件级设计时，内聚性意味着构件或者类只封装那些相互关联密切，以及与构件或类自身有密切关系的属性和操作。内聚性显示了某个模块相关功能的强度；耦合性显示了模块间的相互依赖性。

巧合内聚：不相干的功能，过程或数据在同一个模块被发现

逻辑内聚：逻辑相关的功能湖泊数据被放在同一个模块

时间内聚：一个模块包含的任务必须在同一段时间内执行

过程内聚：模块内必须以特定次序执行。

通信内聚：访问相同数据的所有操作被定义在一个类中

顺序内聚：处理必须顺序执行

功能内聚：一个模块只完成某一组特定操作并返回结果

分层内聚：高层能访问低层，底层不能访问高层的服务

##### 耦合（coupling）        

软件结构中多个模块之间相互来连接。耦合性显示了模块间的相互依赖性。耦合是类之间彼此联系程度的一种定性的度量。随着类相互依赖越来越多，类之间的耦合程度亦会增加。

内容耦合：当一个构件暗中修改其他构件的内部数据 ------ 违反信息隐蔽原则

公共耦合：大量构件使用一个全局变量

控制耦合：A 调用 B，并向 B 传递控制标记。接着控制标记指引 B 的逻辑流程 ----------B 的不相关变更导致 A 传递控制标记的意义变更。-------- 忽略，不会引起错误

数据耦合：需要传递长串的数据参数时。

特征耦合：当把数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合

原则：尽量数据耦合，少控制耦合，限制公共耦合的范围，完全不用内容耦合。

#### 数据设计：

或类的设计，将类模型转化为设计类的实现以及软件实现所要求的数据结构。

#### 三个层次

- 体系结构设计
- 构件设计
- 接口设计

##### 体系结构设计

**体系结构**：系统的一个或者多个结构，它包括软件构件、构件的外部属性，以及它们之间的相互关系。

*构件*：软件模块。

体系结构的结构元素：

- 处理构件
- 数据构件
- 连接构件

体系结构风格：

- 以数据为中心的体系结构
- 数据流体系结构
- C/S 结构
- 调用和返回体系结构
- 层次体系结构
- 面向对象体系结构

软件架构风格：

- 数据流
- 调用/返回
- 独立构件
- 虚拟机
- 仓库

##### 构件设计（component）

###### 构件定义：

构件是计算机软件中的一个模块化的构造块。系统中的模块化的、可部署的和可替换的部件，该部件封装了实现并暴露一组接口

###### 设计原则：

###### 开闭原则：

对外延具有开放性，对修改具有封闭性，即无需对构建自身内部做修改就可以进行扩展

###### 里氏替换：

子类可以替换它们的基类

###### 依赖倒置：

依赖于抽象而非具体实现

###### 接口分离：

为每个主要客户类型都设计一个特定的接口

##### 接口设计（大题）

###### 黄金准则

1.  用户操纵控制
2.  减少用户的记忆负担
3.  保持界面一致

### 系统测试

#### 软件测试：

以特定的目标执行程序，在交付给用户前发现错误。软件测试是软件质量保证的关键要素，代表了对规范、设计和代码生成的最终审查

##### 测试目标：

发现软件设计和实现过程中的疏忽所造成的错误

##### 测试过程：

最初，测试侧重于单个构件，确保它起到单元的作用，接下来组装或集成各个构件以形成完整的软件包。集成测试处理并验证与程序构造相关的问题，在集成过程中，普遍使用关注输入和输出的测试用例设计技术。在软件集成测试完成后，执行一系列高阶测试，必须评估确认准则。确认测试为软件满足所有的功能、行为和性能需求提供最终保证。

#### 单元测试

侧重于软件设计的最小单元（模块）的验证工作。利用构件级设计描述作为指南，测试重要的控制路径以发现模块内的错误。

#### 集成测试

旨在发现与接口相关的错误的测试

##### 增量集成策略

目标：利用已通过单元测试的构件建立设计中描述的程序结构。

###### 自顶向下的集成：

增量方法，从主控模块开始，沿着控制层次逐步向下，以深度优先或广度优先的方式将从属于主控模块的模块集成到结构中

步骤：

1.   测试顶端模块，用存根程序 (stub) 代替直接附属的下层模块
2.  根据深度优先或宽度优先的策略，每次用一个实际模块代换一个 stub
3.  在结合进一个模块的同时进行测试
4.  回归测试 (regression testing)——全部或部分地重复以前做过的测试

优点和问题：

优点：在早期即对主要控制及关键的抉择进行检验。

问题：Stub 只是对低层模块的模拟，测试时没有重要的数据自下往上流，许多重要的测试须推迟进行，而且在早期不能充分展开人力。

###### 自底向上的集成

从原子模块开始构造和测试。

步骤

1.  把低层模块组合成族，每族实现一个子功能。
2.  用驱动程序 (Driver) 协调测试数据的 I\O，测试子功能族。
3.  去掉 Driver，自下而上把子功能族合成更大的子功能族。

两种策略的优、缺点刚好互补，但单用其中任一种都不实际，通常根据软件的特点将二者混用。

###### 三明治测试

同时使用自底向上和自顶向下的测试方法，综合了两种方法的优点，也产生了新的缺点

1.  选择一个层为中间层
2.  对中间层以上的层使用自顶向下的测试
3.  对中间层以下的层使用自底向上的测试
4.  中间层不测试或者单独测试

优点：出来具有自顶向下和自底向上两种集成策略的优点之外，运用了一定的技巧，能够减少桩模块和驱动模块的开发

缺点：中间层不能尽早得到充分的测试，或者因为中间层如果选择不适当导致增加驱动模块的和桩模块工作量的设计负担

##### Big-Bang 集成测试

大爆炸集成是属于非增值式集成的一种方法，也叫一次性组装或者整体拼装。该集成测试在辅助模块的辅助下，一次性把所有系统组件集合到被测系统中，不考虑组件之间的相互依赖性或者可能存在的风险，一般一次性成功的几率不大

大爆炸测试比较适合在原有稳定系统增加子模块或者系统较小时使用

优点：

成本低，测试用例少，幸运的话，可以不需要或者只需要开发少量的辅助模块，就可以完成测试

缺点：

这种一次性组装的方式图在辅助模块的协助下，在模块单元测试基础上，将所测模块连接起来进行测试。不可避免的存在模块间接口、全局数据结构等方面的问题，所以一次试运行成功的可能性并不很大，即使运行成功，也很可能会存在隐患

##### 回归测试：

重新执行已测试过的某些子集，以确保变更没有传播不期望的副作用

##### 冒烟测试：

对整个系统进行彻底的测试

#### 验证与确认

验证：

确保软件正确的实现某一特定功能的一系列活动。-- 正确的构造软件

确认：

确保开发的软件可追溯到客户需求的另一系列活动。-- 构造正确的软件

确认测试：

始于集成测试结束。当软件可以按照用户合理的预期方式工作时，确认成功。软件确认是通过一系列表面与软件需求相符合的测试而获得的

α测试：

具有代表性的最终用户在开发者的场所进行，开发者通过用户来观察开发的软件，  是在受控的环境下进行的，在开发环境下进行

β测试：

在一个或多个最终用户场所进行 “现场” 应用，开发者不在现场，在用户环境下进行

#### 系统测试

对整个计算机的系统进行一系列不同考验的测试

##### 恢复测试

在系统出故障后，系统能否从故障中恢复过来，并在预定的时间间隔内从新开始处理

强使软件出现故障，系统应自动恢复

如需人工干预，应估算出修复的平均时间，确定出是否可接受

##### 安全性测试         

系统的预防机制（预防非法入侵：窃贼，报复，非法牟利……)

安全性测试，验证系统的预防机制

测试者扮演期望侵入系统的角色，通过一切可能的措施侵入系统

测试开销可能很大

##### 压力测试

在一个非正常数量，频率或容量方式下运行系统

测试者想办法破坏程序

1）运行要求最大内存或其他资源的程序

2）按大小递增的顺序改变输入数据的速率，看系统怎样响应

##### 性能测试

测试软件被组装进系统的环境下运行时的性能

性能测试覆盖测试过程中的每一步

##### 部署测试

部署测试，又叫做配置测试（Configuration testing), 测试不同的运行环境

#### 黑盒测试与白盒测试

##### 黑盒测试

就是功能测试, 从外部执行测试用例, 用以验证待测功能的正确性, 而不考虑软件内部处理逻辑, 外部测试

##### 等价类划分

等价类划分是一种黑盒测试方法，它将程序的输入划分为若干个数据类，从中生成测试用例。

##### 边界值分析

一种测试用例设计技术，是对 “等价划分” 的补充。BVA 不是选择等价类的任何元素，而是在等价类 “边缘” 上选择测试用例，其不是仅仅侧重于输入条件，也从输出域中导出测试用例

##### 白盒测试

叫玻璃盒测试, 是一种测试用例设计方法. 它利用作为构件层设计的一部分所描述的控制结构来生成测试用例. 白盒测试是基于过程细节的封闭测试. 测试构建内部的数据结构, 算法流程与接口, 内部测试.

基本路径测试方法（大题）