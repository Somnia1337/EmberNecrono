👈 [[1 计算机网络和因特网]]

## 应用层协议原理

### 网络应用程序体系结构

**应用程序体系结构** 由开发者设计，规定了如何在各种端系统上组织该应用程序。

2 种主流的体系结构：客户 - 服务器体系结构，对等体系结构。

![[Snipaste_240312_092845.png|450]]

在 **客户 - 服务器体系结构**(CS) 中，有一个总是打开的主机（服务器），它服务于来自许多其他主机（客户）的请求。

较大型的网络站点配备大量的主机构成数据中心，用作大型的虚拟服务器。

在 **对等体系结构**(P2P) 中，应用程序在间断连接的主机对之间直接通信，称这些主机对为对等方，它们对位于数据中心的服务器有最小的依赖。

很多流量密集型应用程序采用对等体系结构，如文件共享（BitTorrent），对等方协助下载加速器（迅雷）等。

### 进程通信

进行网络通信的是进程而非程序，一个进程可以视为一个运行在端系统上的程序。

两个端系统上的进程通过网络交换 **报文** 进行通信，发送进程生成并向网络中发送报文，接收进程接收该报文并可能发回一个报文作为响应。

#### 客户和服务器进程

在给定的一对进程之间的通信场景中，视发起通信的进程为客户，视在会话开始时等待联系的进程为服务器。

#### 进程与计算机网络之间的接口

进程通过称为 **套接字**(socket) 的软件接口与网络交换报文。

用房子和门类比进程和套接字：进程相当于房子，套接字相当于门，发送进程发送报文相当于将报文从门推出去，报文在接收进程处也通过门被接收。

![[Snipaste_240312_094850.png|600]]

套接字是建立网络应用程序的可编程接口，因此也称为应用程序和网络之间的 API。

#### 进程寻址

为了标识接收进程的地址，需要指定：

- 主机的地址：**IP 地址**
- 接收进程在该主机中的标识符：**端口号**

常见端口号：

- Web 服务器：`80`
- 邮件服务器：`25`

### 可供应用程序使用的运输服务

#### 可靠数据传输

**可靠数据传输**：确保由应用程序的一端发送的数据正确、完整地交给另一端。

运输层协议为应用程序提供进程到进程的可靠数据传输。

#### 吞吐量

**可用吞吐量**：发送进程能够向接收进程交付比特的速率。

运输层协议能以特定速率提供确保的可用吞吐量。

#### 定时

例如，保证每个比特到达接收方的套接字耗时不高于 $100$ ms。

#### 安全性

在发送和接收进程间提供机密性，以防该数据在传输途中被观察到。

### 因特网提供的运输服务

因特网为应用程序提供 2 个运输层协议：TCP 和 UDP。

#### TCP 服务

- 面向连接的服务：在应用层数据报文开始传输前，TCP 让客户和服务器交换运输层控制信息，称为握手。握手之后，一条全双工的 TCP 连接在两进程的套接字之间建立。报文传输结束后，该连接被拆除。
- 可靠的数据传输服务：无差错、按正确顺序交付发送的所有数据。

网络拥塞时，TCP 的拥塞控制机制将抑制发送进程并限制每一个 TCP 连接。

**安全套接字层**(SSL)：TCP 的加强版本，提供了关键的进程间安全服务。

#### UDP 服务

UDP 是只提供最小必要服务的轻量级协议，是无连接的（因此无握手过程）。

UDP 提供一种不可靠的数据传输服务，无法保证报文的正确性、完整性或到达顺序。

#### 因特网运输协议所不提供的服务

因特网通常能提供可靠数据传输和安全性服务，而不保证吞吐量或定时服务。

### 应用层协议

**应用层协议** 定义了进程间如何交换报文：

- 报文的类型
- 各类报文的语法
- 字段的语义
- 发送报文的时间和方式
- 进行响应的规则

应用层协议只是网络应用的一部分。

| 应用      | 应用层协议  | 运输层协议     |
| ------- | ------ | --------- |
| 电子邮件    | SMTP   | TCP       |
| 远程终端访问  | Telnet | TCP       |
| Web     | HTTP   | TCP       |
| 文件传输    | FTP    | TCP       |
| 流媒体     | 专用     | UDP 或 TCP |
| 网络电话    | 专用     | UDP 或 TCP |
| 远程文件服务器 | NFS    | UDP       |
| 网络管理    | SNMP   | UDP       |
| 路由选择协议  | RIP    | UDP       |
| 名字转换    | DNS    | UDP       |

## Web 和 HTTP

1990s，**万维网** 诞生，简称 Web，是一个因特网应用。

不同于无线电广播或电视的用户只能被动接收内容，Web 是按需操作的，用户可以主动获取想要的内容。

### HTTP 概况

**超文本传输协议**(HTTP)：Web 的应用层协议，是 Web 的核心。

术语：

- **对象**：一个文件，如一个 HTML 文件、一个 JPEG 图形、一个 Java Applet 等，通过 *URL* 寻址。
- **Web 页面**：也称文档，由若干 *对象* 组成，一般含一个 HTML 基本文件和若干引用对象。

HTTP——

- 仅由客户程序和服务器程序实现
- 定义了客户向服务器请求 *Web 页面* 的方式，以及服务器向客户传输的方式
- 使用 *TCP* 作为其运输层协议，采用 *CS 体系结构*
- 不保存关于客户的信息，属于 **无状态协议**

### 非持续连接和持续连接

每个请求 / 响应对经由——

- 一个单独的 TCP 连接发送 => **非持续连接**
- 同一个 TCP 连接发送 => **持续连接**

#### 采用非持续连接的 HTTP

假设一个被请求的页面含 $1$ 个 HTML 基本文件和 $10$ 个引用对象：

1. 客户进程由端口 `80` 发起一个到服务器的 TCP 连接，随后该连接建立。
2. 客户经其套接字向服务器发送一个 HTTP 请求报文。
3. 服务器经其套接字接收该请求报文，从其存储器中检索出请求的对象，在一个 HTTP 响应报文中进行封装，通过其套接字向客户端发送该响应报文。
4. 服务器进程通知 TCP 断开该 TCP 连接（实际上尚未断开，连接将持续到 TCP 确保客户无误地接收完成）。
5. 客户接收整个响应报文，随后断开 TCP 连接。
6. 客户解析响应报文，发现有 $10$ 个对象，对每一个重复步骤 1 ~ 5。
7. 全部完成后，显示 Web 页面。

本例中，一次 Web 页面的请求导致了 $11$ 个 TCP 连接的建立。

不同的浏览器可能会以不同的方式解释同一个页面，这一过程与 HTTP 无关。

实际上，浏览器一般可以打开 $5$ ~ $10$ 个并行的 TCP 连接，每个连接响应一个请求。

**往返时间**(RTT)：一个短分组（忽略传输时延）从客户到服务器再返回客户所花费的时间，包含其余 3 种时延（*结点处理*、*排队*、*传播*）。

“三次握手”：客户向服务器发送一个小 TCP 报文段，服务器用一个小 TCP 报文段作出响应和确认，客户再向服务器返回确认。

请求一个短对象的总响应时间：约 $2$ RTT，第 1 个用于建立 TCP 连接，第 2 个用于请求和接收该对象：

![[Snipaste_240312_184516.png|450]]

#### 采用持续连接的 HTTP

如果采用持续连接，服务器在发送响应后保持该 TCP 连接打开，使得客户的后续请求和服务器的响应报文无需反复新建、断开更多的 TCP 连接。

HTTP 默认使用带流水线的持续连接。

### HTTP 报文格式

#### HTTP 请求报文

```http
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

![[Snipaste_240319_084852.png|500]]

**HTTP 请求报文** 的首行为 **请求行**，随后的几行为 **首部行**，在一个额外的空行之后可能有 **实体体**。

- 请求行
	- 方法字段：取 `GET` / `POST` / `HEAD` / `PUT` / `DELETE`。
	- URL 字段：请求对象的标识。
	- HTTP 版本字段。
- 首部行
	- `Host`：对象所在的主机。考虑到连接已经建立，这看似不必要，但其实是 *Web 缓存器*（见下文）所要求的。
	- `Connection`：取 `close` / `keep-alive`，控制非持续 / 持续连接。
	- `User-agent`：客户端代理标识，表示客户端所使用的浏览器，以便服务器返回对象的特定版本。
	- `Accept-language`：接受的语言，如 `fr` 表示法语。
- 实体体：使用 `POST` 方法提交表单（如使用搜索引擎查询）时，会用到实体体，此时服务器根据用户的请求返回特定的内容。

更多方法字段：

- `HEAD`：类似于 `GET`，但不返回对象，用于调试。
- `PUT`：上传对象到服务器。
- `DELETE`：删除服务器中的对象。

#### HTTP 响应报文

```http
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (Centos)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
```

![[Snipaste_240319_084910.png|500]]

**HTTP 响应报文** 的首行为 **状态行**，其后的 *首部行* 和 *实体体* 与 HTTP 请求报文相同。

- 状态行
	- HTTP 版本字段。
	- 状态码及相应的状态短语：
		- `200 OK`
		- `301 Moved Permanently`
		- `400 Bad Request`
		- `404 Not Found`
- 首部行
	- `Date`：==报文本身产生的时间==。
	- `Server`：服务器信息。
	- `Last-Modified`：==对象最后修改的时间==（用于更新 Web 缓存）。
	- `Content-Length` 和 `Content-Type` 含义如字面所示。
- 实体体：包含响应的对象，如一个 HTML 文档。

### 用户与服务器的交互：cookie

cookie 使得无状态的 HTTP 得以标识用户。

cookie 技术包含的组件：

- HTTP 请求报文和响应报文的首部行。
- 客户端系统中的一个文件，由浏览器管理。
- 服务器端系统中的数据库。

![[Snipaste_240319_102205.png|600]]

### Web 缓存

**Web 缓存器**/**代理服务器**：能够代表初始 Web 服务器满足 HTTP 请求的网络实体。

可以配置浏览器，使所有 HTTP 请求首先指向 Web 缓存器。

Web 缓存器的作用：

- 缩短对客户请求的响应时间
- 减少一个机构的接入链路到因特网的通信量
- 减少整个因特网的 Web 流量

### 条件 GET 方法

**条件 GET 方法** 使得缓存器可以验证其缓存的对象是否是最新版本。

**条件 GET 请求报文**：一个使用 `GET` 且包含首部行 `If-Modified-Since` 的请求报文。

假设某响应报文有这样的首部行：

```http
Last-Modified: Wed, 7 Sep 2011 09:23:24
```

一周后，另一个用户请求了同一内容，那么缓存器将发出条件 GET 请求报文：

```http
If-Modified-Since: Wed, 7 Sep 2011 09:23:24
```

这个时间正是上一次收到对象时 `Last-Modified` 首部行的内容。如果对象在这一周内没有被修改，服务器将返回状态码 `304 Not Modified` 且不再返回这个完全相同的对象，这样就省去了一次多余的传输。

## 文件传输协议：FTP

FTP 使用了两个并行的 TCP 连接：**控制连接** 和 **数据连接**。

![[Snipaste_240328_160123.png|400]]

控制传输独立于数据传输，称 FTP 的控制信息是 **带外** 传输的（相比之下，称 HTTP 的控制信息是 **带内** 传输的）。

*控制连接* 贯穿一次会话的始终，是持续连接；而 *数据连接* 在每一次文件传输时新建，是非持续连接。

## 因特网中的电子邮件

电子邮件系统的主要组成部分：**用户代理**，**邮件服务器**，**简单邮件传输协议**(SMTP)。

![[Snipaste_240328_160313.png|500]]

### SMTP

- 采用 *持续连接* 的 *TCP*，确保可靠数据传输，多个报文可以通过同一个连接发送
- 要求整个邮件报文使用 *ASCII 编码*
- 不使用中间邮件服务器中转

### 与 HTTP 的对比

| 协议   | 协议类型 | 编码    | 对多对象文档的处理 |
| ---- | ---- | ----- | --------- |
| HTTP | 拉协议  | 无限制   | 单独封装每个对象  |
| SMTP | 推协议  | ASCII | 放入同一个报文   |

### 邮件报文格式和 MIME

邮件报文的首部行：

- 必需的：`From` 和 `To`
- 可选的：`Subject` 等

### 邮件访问协议

流行的邮件访问协议：**第三版的邮局协议**(POP3)，**因特网邮件访问协议**(IMAP)，HTTP。

邮件发送和接收全过程中使用的应用层协议：

![[Snipaste_240328_170453.png|600]]

#### POP3

POP3 的工作流程：

1. 准许：验证用户。
2. 事务处理：获取报文，标记删除等。
3. 更新：用户发出 `quit` 命令，执行删除等操作。

#### IMAP

将每个报文与一个文件夹关联，可以阅读、删除、移动、查询邮件。

#### 基于 Web 的电子邮件

浏览器充当用户代理，用户代理与邮件服务器之间的传输使用 HTTP，但邮件服务器之间的传输仍使用 SMTP。

## DNS：因特网的目录服务

**IP 地址** 和 **主机名** 是标记主机的两种形式，前者由网络实体使用，后者为人类理解记忆。

### DNS 提供的服务

**域名系统**(DNS) 的作用是将 *主机名* 转换为 *IP 地址*，DNS 是——

- 由分层的 **DNS 服务器** 实现的分布式数据库。
- 使得主机能够查询该数据库的应用层协议。

DNS 协议运行在 *UDP* 之上，使用端口 `53`。

### DNS 工作机理概述

执行查询时，用户主机的 DNS 通过端口 `53` 向网络中发送一个 UDP 数据报形式的 **DNS 请求报文**。随后，DNS 接收到一个提供了所查询映射的 **DNS 响应报文**，映射结果传递给调用 DNS 的应用程序。

#### 分布式、层次数据库

DNS 采用的分布式设计：

![[Snipaste_240328_171700.png|500]]

![[Snipaste_240328_172114.png|500]]

- **根 DNS 服务器**
- **顶级域 DNS 服务器**：负责顶级域名 `com`、`org`、`net`、`edu`、`gov`，以及国家的顶级域名如 `uk`、`fr`、`ca`、`jp`
- **权威 DNS 服务器**

还有一种不属于层次结构的 DNS 服务器：**本地 DNS 服务器**。主机的本地 DNS 服务器通常较为邻近，由它代理本地的若干主机的 DNS 请求。

每个 ISP 都有本地 DNS 服务器，当主机连接到一个 ISP 时，后者提供一台特殊主机的 IP，它具有多台其 *本地 DNS 服务器* 的 IP。

![[Snipaste_240328_172525.png|350]]

上图中使用了 **递归查询**（查询 `1`） 和 **迭代查询**（查询 `2`、`4`、`6`）。

以自己的名义获得映射时，称该次查询为 *递归查询*，否则称为 *迭代查询*。

下图中的所有查询都是 *递归查询*：

![[Snipaste_240328_172811.png|350]]

#### DNS 缓存

在一条请求链中，每台 DNS 收到回答时都将结果缓存，并保留约 2 天。

本地 DNS 服务器经常使用缓存技术绕过根 DNS 服务器，从而减轻后者的压力。

### DNS 记录和报文

实现 DNS 系统的所有服务器存储数据的形式为 **资源记录**(RR)，每个 DNS 回答报文包含若干条 RR。

RR 是一个元组 `(Name, Value, Type, TTL)`。

- `Name` 和 `Value` 可视为键值对，它们是 RR 的实际内容，并取决于 `Type`：

| `Type`  | `Name`   | `Value`                           |
| ------- | -------- | --------------------------------- |
| `A`     | 主机名      | IP 地址                             |
| `NS`    | 一个域      | 知道如何获得该域中主机 IP<br>的权威 DNS 服务器的主机名 |
| `CNAME` | 主机名      | 规范主机名                             |
| `MX`    | 邮件服务器主机名 | 规范邮件服务器主机名                        |

- `TTL`：该 RR 的生存时间（用于更新缓存）。

👉 [[3 运输层]]