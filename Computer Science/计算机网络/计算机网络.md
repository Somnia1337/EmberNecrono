[Somnia1337](https://github.com/Somnia1337)

![[OSI 5层模型.png|300]]

# 1 计算机网络和因特网

## 什么是因特网

端系统通过 **通信链路** 和 **分组交换机** 连接。

**分组**(packet)：端系统间传输数据时，将数据分段、每段加上首部字节形成的信息包。

**分组交换机**(packet switch)：传递网络包，包括 **路由器**(router) 和 **链路层交换机**(link-layer switch)。

端系统通过 **因特网服务提供商**(ISP) 接入因特网，每个 ISP 是由多个分组交换机和多段通信链路组成的网络。

**协议**(protocol)：协议定义了多个通信实体之间交换报文的格式和次序，以及收发报文或其他事件所采取的动作，协议控制着因特网中信息的收发。

**TCP**(Transmission Control Protocol，传输控制协议) 和 **IP**(Internet Protocol，网际协议) 是最重要的协议。

用人类的交流过程类比协议的工作方式：

![[Snipaste_240307_152358.png|500]]

> [!summary] 因特网的描述
> 
> - 构成
> 	- 硬件：端系统，通信链路，分组交换机
> 	- 软件：网络应用程序，协议
> 	- 是网络的网络
> - 服务：为分布式应用程序提供了运行条件

## 网络边缘

**端系统**：端系统上运行应用程序，也称为 **主机**。

主机分为 **客户** 和 **服务器**。

## 网络核心

通过网络链路和交换机传输数据的两种基本方法：**分组交换**(packet switching)，**电路交换**(circuit switching)。

### 分组交换

#### 存储转发传输

分组以链路的最大传输速率通过通信链路传输，例如：分组的大小为 $L$ bit，链路的传输速率为 $R$ bps，则传输该分组用时 $\large \frac{L}{R}$ s。

**存储转发传输**：在交换机向输出链路传输某个分组前，必须接收到整个分组。大多数分组交换机都采用此机制。

存储转发传输影响着传输的时延。考虑以下传输路径：

```text
源 --> 路由器 --> 目的地
```

沿用上文的符号 $L$ 和 $R$，忽略传播时延（比特流以近光速通过线路的耗时）：

- 时刻 $0$：源开始传输，路由器立即接收到首个比特，但由于存储转发机制而不能开始向目的地传输。
- 时刻 $\large \frac{L}{R}$：路由器接收到整个分组，开始向目的地传输。
- 时刻 $\large \frac{2 L}{R}$：目的地接收到整个分组。

最终用时 $\large \frac{2 L}{R}$。

假如路由器每接收到一个比特就立即转发到目的地，最终用时将为 $\large \frac{L}{R}$。

通过由 $N$ 条速率为 $R$ 的链路组成的路径，从源向目的地发送 $1$ 个分组，端到端时延为：$$d = N \frac{L}{R}$$

发送 $P$ 个分组，端到端时延为：$$d = (N + P - 1) \frac{L}{R}$$

#### 排队时延和分组丢失

每个分组交换机连接着多条链路，其对每条链路都保有一个 **输出缓存**/**输出队列**，用于存储路由器准备发往该链路下个结点的分组。

如果某个分组已经到达，但目标出链路正忙于传输其他分组，这个已经到达的分组只能在输出缓存中等待，称这个时延为 **排队时延**。

缓存的大小有限，如果缓存已经充满，接下来到达缓存的分组将被丢弃，称为 **分组丢失**/**丢包**。

#### 转发表和路由选择协议

每个端系统都有一个 IP 地址，源向目的地发送的分组头部包含了目的地的 IP 地址。

每台路由器都有一个 **转发表**，将目的地址映射为出链路。分组到达时，路由器检查目的地 IP 地址并搜索其转发表，从而将分组输出到正确的出链路。

因特网的 **路由选择协议** 用于自动设置转发表。

### 电路交换

不同于分组交换对资源的按需分配，电路交换会预留端系统之间通信所需的资源（缓存，传输速率等）。

用餐厅类比两种交换方式：

- 分组交换是不接受预定的餐厅，顾客到店后可能立即就餐，也可能等待。
- 电路交换是只接受预定的餐厅，顾客必须预定，也保证到店后立即就餐。

在电路交换中，设某条链路能容纳 $N$ 条电路，则每个连接将占用其中的 $1$ 条，也即占用链路带宽资源的 $\large \frac{1}{N}$；如果链路的总传输速率为 $R$，则每个连接获得 $\large \frac{R}{N}$ 的专用速率。

#### 电路交换中的复用

链路中的电路通过 **频分复用**(FDM) 和 **时分复用**(TDM) 实现。

设 $N$ 为电路总数，$B$ 为链路带宽，$T$ 为帧速率（$1$ 帧 $=$ $N$ $\times$ 时隙），$M$ 为一个时隙中的比特数：

- FDM：每条电路得到连续的部分带宽，速率为 $\large \frac{B}{N}$。
- TDM：每条电路周期性地在短时间间隔（时隙）内得到全部带宽，速率为 $T \times M$。

![[Snipaste_240312_080903.png|500]]

#### 分组交换与电路交换的对比

分组交换的性能优于电路交换：

- 电路交换不考虑需求，而预先分配资源，浪费了已分配而未使用的链路时间。
- 电路交换需要为每个连接预留电路，能够支持的并发量较小。

### 网络的网络

因特网是一个网络的网络：

- 由十多个第一层 ISP 和数十万个较低层 ISP 组成。
- 较低层 ISP 与较高层 ISP 相连，后者彼此相连。
- 用户和内容提供商是较低层 ISP 的客户，后者是较高层 ISP 的客户。

## 分组交换网中的时延、丢包和吞吐量

### 分组交换网中的时延概述

分组从一个结点沿某条路径到达后继结点的过程中，主要的时延有：

| 时延       | 英文 (~delay)      | 原因                         | 数量级   |
| -------- | ---------------- | -------------------------- | ----- |
| **结点处理** | nodal processing | 检查分组首部<br>检查比特级差错<br>选择出链路 | 微秒    |
| **排队**   | queuing          | 先于分组到达且正在排队的分组             | 微秒~毫秒 |
| **传输**   | transmission     | 将分组的所有比特传输到出链路             | 微秒~毫秒 |
| **传播**   | propagation      | 比特经由出链路到达下个结点              | 毫秒    |

![[Snipaste_240307_152531.png|400]]

称这些时延的和为 **结点总时延**。

*传输时延* 和 *传播时延* 的比较：

- 传输时延：结点将分组的所有比特输送到出链路的耗时，为 $\large \frac{L}{R}$（含义见前文）
- 传播时延：一个比特从当前结点到达下个结点的耗时，为 $\large \frac{d}{s}$（两结点间距除以传播速率），$s$ 近似光速（约 $[2, 3] \times 10^8$ m/s）
- 两者的决定变量互相独立，即：
	- 传输时延与 $d$ 或 $s$ 均无关
	- 传播时延与 $L$ 或 $R$ 均无关

### 排队时延和丢包

#### 排队时延

不同分组的排队时延可能不同：如果 10 个分组同时到达空队列，第 1 个分组没有排队时延，而第 10 个分组的排队时延最长。

设 $a$ 为分组到达队列的平均速率（分组/秒），沿用 $L$、$R$，则比特到达队列的平均速率为 $a L$ bps，称比率 $\large \frac{a L}{R}$ 为 **流量强度**。当 ${\large \frac{a L}{R}} > 1$，即比特到达队列的平均速率超过从队列传输出去的平均速率，则队列趋向无限增长，排队时延趋向 $\infty$。

原则：设计系统时，流量强度不能大于 $1$。

假设分组的到达是随机的，且队列容量无限，平均排队时延与流量强度的关系为：

![[Snipaste_240307_152610.png|500]]

#### 丢包

现实中，队列的容量有限，随着流量强度接近 $1$，路由器将 **丢弃** 无法容纳的分组，造成分组丢失。

### 端到端时延

上文的时延是针对一个结点而言，现在考虑从源到目的地的总时延。设二者之间有 $N$ 条链路，且网络无拥塞（排队时延为 $0$），$R$ 为每台路由器的输出速率，则端到端时延为：$$d_{end-end} = N (d_{proc} + d_{trans} + d_{prop})$$

#### Traceroute

![[Snipaste_240306_101618.png|500]]

#### 端系统、应用程序和其他时延

- 要向共享媒体传输分组的端系统可以有意延迟其传输，以与其他端系统共享媒体。
- 经 IP 语音(VoIP) 应用中的媒体分组化时延。

### 计算机网络中的吞吐量

考虑从主机 A 到主机 B 传输一个大文件：

- 在任意时刻，称主机 B 接收到该文件的速率（以 bps 计）为 **瞬时吞吐量**。
- 设 $F$ 为文件的总比特数，$T$ 为主机 B 接收整个文件的用时（以 s 计），称比率 $\large \frac{F}{T}$ 为 **平均吞吐量**。

某网络的吞吐量取决于其 **瓶颈链路** 的传输速率，即 ${\rm{min}}\{R_1, R_2, \cdots, R_n\}$。

## 协议层次及其服务模型

### 分层的体系结构

分层的优点：对于大而复杂且需要不断更新的系统，改变某个服务的实现不会影响其他组件的功能。

#### 协议分层

| 五层因特网协议栈 | 功能               |
| :------: | ---------------- |
|   应用层    | 网络应用程序及其应用层协议    |
|   运输层    | 在应用程序端点之间传送应用层报文 |
|   网络层    | 在主机之间传输分组        |
|   链路层    | 在结点之间传输分组        |
|   物理层    | 在结点之间传输比特        |

“分组”在各层中的名称：

- 应用层：**报文** | **message**
- 运输层：**报文段** | **segment**
- 网络层：**数据报** | **datagram**
- 链路层：**帧** | **frame**

#### OSI 模型

| 七层 ISO OSI 参考模型 |
| :-------------: |
|       应用层       |
|       表示层       |
|       会话层       |
|       运输层       |
|       网络层       |
|       链路层       |
|       物理层       |

### 封装

分组在各层之间传输的过程中，每层都在分组头部添加本层的附加信息，称为 **封装**。

![[Snipaste_240308_105256.png|600]]

<div style="page-break-after: always"></div>

# 2 应用层

## 应用层协议原理

### 网络应用程序体系结构

**应用程序体系结构** 由开发者设计，规定了如何在各种端系统上组织该应用程序。

2 种主流的体系结构：客户 - 服务器体系结构，对等体系结构。

![[Snipaste_240312_092845.png|450]]

在 **客户 - 服务器体系结构**(CS) 中，有一个总是打开的主机（服务器），它服务于来自许多其他主机（客户）的请求。

较大型的网络站点配备大量的主机构成数据中心，用作大型的虚拟服务器。

在 **对等体系结构**(P2P) 中，应用程序在间断连接的主机对之间直接通信，称这些主机对为对等方，它们对位于数据中心的服务器有最小的依赖。

很多流量密集型应用程序采用对等体系结构，如文件共享（BitTorrent），对等方协助下载加速器（迅雷）等。

### 进程通信

进行网络通信的是进程而非程序，一个进程可以视为一个运行在端系统上的程序。

两个端系统上的进程通过网络交换 **报文** 进行通信，发送进程生成并向网络中发送报文，接收进程接收该报文并可能发回一个报文作为响应。

#### 客户和服务器进程

在给定的一对进程之间的通信场景中，视发起通信的进程为客户，视在会话开始时等待联系的进程为服务器。

#### 进程与计算机网络之间的接口

进程通过称为 **套接字**(socket) 的软件接口与网络交换报文。

用房子和门类比进程和套接字：进程相当于房子，套接字相当于门，发送进程发送报文相当于将报文从门推出去，报文在接收进程处也通过门被接收。

![[Snipaste_240312_094850.png|600]]

套接字是建立网络应用程序的可编程接口，因此也称为应用程序和网络之间的 API。

#### 进程寻址

为了标识接收进程的地址，需要指定：

- 主机的地址：**IP 地址**
- 接收进程在该主机中的标识符：**端口号**

常见端口号：

- Web 服务器：`80`
- 邮件服务器：`25`

### 可供应用程序使用的运输服务

#### 可靠数据传输

**可靠数据传输**：确保由应用程序的一端发送的数据正确、完整地交给另一端。

运输层协议为应用程序提供进程到进程的可靠数据传输。

#### 吞吐量

**可用吞吐量**：发送进程能够向接收进程交付比特的速率。

运输层协议能以特定速率提供确保的可用吞吐量。

#### 定时

例如，保证每个比特到达接收方的套接字耗时不高于 $100$ ms。

#### 安全性

在发送和接收进程间提供机密性，以防该数据在传输途中被观察到。

### 因特网提供的运输服务

因特网为应用程序提供 2 个运输层协议：TCP 和 UDP。

#### TCP 服务

- 面向连接的服务：在应用层数据报文开始传输前，TCP 让客户和服务器交换运输层控制信息，称为握手。握手之后，一条全双工的 TCP 连接在两进程的套接字之间建立。报文传输结束后，该连接被拆除。
- 可靠的数据传输服务：无差错、按正确顺序交付发送的所有数据。

网络拥塞时，TCP 的拥塞控制机制将抑制发送进程并限制每一个 TCP 连接。

**安全套接字层**(SSL)：TCP 的加强版本，提供了关键的进程间安全服务。

#### UDP 服务

UDP 是只提供最小必要服务的轻量级协议，是无连接的（因此无握手过程）。

UDP 提供一种不可靠的数据传输服务，无法保证报文的正确性、完整性或到达顺序。

#### 因特网运输协议所不提供的服务

因特网通常能提供可靠数据传输和安全性服务，而不保证吞吐量或定时服务。

### 应用层协议

**应用层协议** 定义了进程间如何交换报文：

- 报文的类型
- 各类报文的语法
- 字段的语义
- 发送报文的时间和方式
- 进行响应的规则

应用层协议只是网络应用的一部分。

| 应用      | 应用层协议  | 运输层协议     |
| ------- | ------ | --------- |
| 电子邮件    | SMTP   | TCP       |
| 远程终端访问  | Telnet | TCP       |
| Web     | HTTP   | TCP       |
| 文件传输    | FTP    | TCP       |
| 流媒体     | 专用     | UDP 或 TCP |
| 网络电话    | 专用     | UDP 或 TCP |
| 远程文件服务器 | NFS    | UDP       |
| 网络管理    | SNMP   | UDP       |
| 路由选择协议  | RIP    | UDP       |
| 名字转换    | DNS    | UDP       |

## Web 和 HTTP

1990s，**万维网** 诞生，简称 Web，是一个因特网应用。

不同于无线电广播或电视的用户只能被动接收内容，Web 是按需操作的，用户可以主动获取想要的内容。

### HTTP 概况

**超文本传输协议**(HTTP)：Web 的应用层协议，是 Web 的核心。

术语：

- **对象**：一个文件，如一个 HTML 文件、一个 JPEG 图形、一个 Java Applet 等，通过 *URL* 寻址。
- **Web 页面**：也称文档，由若干 *对象* 组成，一般含一个 HTML 基本文件和若干引用对象。

HTTP——

- 仅由客户程序和服务器程序实现
- 定义了客户向服务器请求 *Web 页面* 的方式，以及服务器向客户传输的方式
- 使用 *TCP* 作为其运输层协议，采用 *CS 体系结构*
- 不保存关于客户的信息，属于 **无状态协议**

### 非持续连接和持续连接

每个请求 / 响应对经由——

- 一个单独的 TCP 连接发送 => **非持续连接**
- 同一个 TCP 连接发送 => **持续连接**

#### 采用非持续连接的 HTTP

假设一个被请求的页面含 $1$ 个 HTML 基本文件和 $10$ 个引用对象：

1. 客户进程由端口 `80` 发起一个到服务器的 TCP 连接，随后该连接建立。
2. 客户经其套接字向服务器发送一个 HTTP 请求报文。
3. 服务器经其套接字接收该请求报文，从其存储器中检索出请求的对象，在一个 HTTP 响应报文中进行封装，通过其套接字向客户端发送该响应报文。
4. 服务器进程通知 TCP 断开该 TCP 连接（实际上尚未断开，连接将持续到 TCP 确保客户无误地接收完成）。
5. 客户接收整个响应报文，随后断开 TCP 连接。
6. 客户解析响应报文，发现有 $10$ 个对象，对每一个重复步骤 1 ~ 5。
7. 全部完成后，显示 Web 页面。

本例中，一次 Web 页面的请求导致了 $11$ 个 TCP 连接的建立。

不同的浏览器可能会以不同的方式解释同一个页面，这一过程与 HTTP 无关。

实际上，浏览器一般可以打开 $5$ ~ $10$ 个并行的 TCP 连接，每个连接响应一个请求。

**往返时间**(RTT)：一个短分组（忽略传输时延）从客户到服务器再返回客户所花费的时间，包含其余 3 种时延（*结点处理*、*排队*、*传播*）。

“三次握手”：客户向服务器发送一个小 TCP 报文段，服务器用一个小 TCP 报文段作出响应和确认，客户再向服务器返回确认。

请求一个短对象的总响应时间：约 $2$ RTT，第 1 个用于建立 TCP 连接，第 2 个用于请求和接收该对象：

![[Snipaste_240312_184516.png|450]]

#### 采用持续连接的 HTTP

如果采用持续连接，服务器在发送响应后保持该 TCP 连接打开，使得客户的后续请求和服务器的响应报文无需反复新建、断开更多的 TCP 连接。

HTTP 默认使用带流水线的持续连接。

### HTTP 报文格式

#### HTTP 请求报文

```http
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

![[Snipaste_240319_084852.png|500]]

**HTTP 请求报文** 的首行为 **请求行**，随后的几行为 **首部行**，在一个额外的空行之后可能有 **实体体**。

- 请求行
	- 方法字段：取 `GET` / `POST` / `HEAD` / `PUT` / `DELETE`。
	- URL 字段：请求对象的标识。
	- HTTP 版本字段。
- 首部行
	- `Host`：对象所在的主机。考虑到连接已经建立，这看似不必要，但其实是 *Web 缓存器*（见下文）所要求的。
	- `Connection`：取 `close` / `keep-alive`，控制非持续 / 持续连接。
	- `User-agent`：客户端代理标识，表示客户端所使用的浏览器，以便服务器返回对象的特定版本。
	- `Accept-language`：接受的语言，如 `fr` 表示法语。
- 实体体：使用 `POST` 方法提交表单（如使用搜索引擎查询）时，会用到实体体，此时服务器根据用户的请求返回特定的内容。

更多方法字段：

- `HEAD`：类似于 `GET`，但不返回对象，用于调试。
- `PUT`：上传对象到服务器。
- `DELETE`：删除服务器中的对象。

#### HTTP 响应报文

```http
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (Centos)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
```

![[Snipaste_240319_084910.png|500]]

**HTTP 响应报文** 的首行为 **状态行**，其后的 *首部行* 和 *实体体* 与 HTTP 请求报文相同。

- 状态行
	- HTTP 版本字段。
	- 状态码及相应的状态短语：
		- `200 OK`
		- `301 Moved Permanently`
		- `400 Bad Request`
		- `404 Not Found`
- 首部行
	- `Date`：==报文本身产生的时间==。
	- `Server`：服务器信息。
	- `Last-Modified`：==对象最后修改的时间==（用于更新 Web 缓存）。
	- `Content-Length` 和 `Content-Type` 含义如字面所示。
- 实体体：包含响应的对象，如一个 HTML 文档。

### 用户与服务器的交互：cookie

cookie 使得无状态的 HTTP 得以标识用户。

cookie 技术包含的组件：

- HTTP 请求报文和响应报文的首部行。
- 客户端系统中的一个文件，由浏览器管理。
- 服务器端系统中的数据库。

![[Snipaste_240319_102205.png|600]]

### Web 缓存

**Web 缓存器**/**代理服务器**：能够代表初始 Web 服务器满足 HTTP 请求的网络实体。

可以配置浏览器，使所有 HTTP 请求首先指向 Web 缓存器。

Web 缓存器的作用：

- 缩短对客户请求的响应时间
- 减少一个机构的接入链路到因特网的通信量
- 减少整个因特网的 Web 流量

### 条件 GET 方法

**条件 GET 方法** 使得缓存器可以验证其缓存的对象是否是最新版本。

**条件 GET 请求报文**：一个使用 `GET` 且包含首部行 `If-Modified-Since` 的请求报文。

假设某响应报文有这样的首部行：

```http
Last-Modified: Wed, 7 Sep 2011 09:23:24
```

一周后，另一个用户请求了同一内容，那么缓存器将发出条件 GET 请求报文：

```http
If-Modified-Since: Wed, 7 Sep 2011 09:23:24
```

这个时间正是上一次收到对象时 `Last-Modified` 首部行的内容。如果对象在这一周内没有被修改，服务器将返回状态码 `304 Not Modified` 且不再返回这个完全相同的对象，这样就省去了一次多余的传输。

## 文件传输协议：FTP

FTP 使用了两个并行的 TCP 连接：**控制连接** 和 **数据连接**。

![[Snipaste_240328_160123.png|400]]

控制传输独立于数据传输，称 FTP 的控制信息是 **带外** 传输的（相比之下，称 HTTP 的控制信息是 **带内** 传输的）。

*控制连接* 贯穿一次会话的始终，是持续连接；而 *数据连接* 在每一次文件传输时新建，是非持续连接。

## 因特网中的电子邮件

电子邮件系统的主要组成部分：**用户代理**，**邮件服务器**，**简单邮件传输协议**(SMTP)。

![[Snipaste_240328_160313.png|500]]

### SMTP

- 采用 *持续连接* 的 *TCP*，确保可靠数据传输，多个报文可以通过同一个连接发送
- 要求整个邮件报文使用 *ASCII 编码*
- 不使用中间邮件服务器中转

### 与 HTTP 的对比

| 协议   | 协议类型 | 编码    | 对多对象文档的处理 |
| ---- | ---- | ----- | --------- |
| HTTP | 拉协议  | 无限制   | 单独封装每个对象  |
| SMTP | 推协议  | ASCII | 放入同一个报文   |

### 邮件报文格式和 MIME

邮件报文的首部行：

- 必需的：`From` 和 `To`
- 可选的：`Subject` 等

### 邮件访问协议

流行的邮件访问协议：**第三版的邮局协议**(POP3)，**因特网邮件访问协议**(IMAP)，HTTP。

邮件发送和接收全过程中使用的应用层协议：

![[Snipaste_240328_170453.png|600]]

#### POP3

POP3 的工作流程：

1. 准许：验证用户。
2. 事务处理：获取报文，标记删除等。
3. 更新：用户发出 `quit` 命令，执行删除等操作。

#### IMAP

将每个报文与一个文件夹关联，可以阅读、删除、移动、查询邮件。

#### 基于 Web 的电子邮件

浏览器充当用户代理，用户代理与邮件服务器之间的传输使用 HTTP，但邮件服务器之间的传输仍使用 SMTP。

## DNS：因特网的目录服务

**IP 地址** 和 **主机名** 是标记主机的两种形式，前者由网络实体使用，后者为人类理解记忆。

### DNS 提供的服务

**域名系统**(DNS) 的作用是将 *主机名* 转换为 *IP 地址*，DNS 是——

- 由分层的 **DNS 服务器** 实现的分布式数据库。
- 使得主机能够查询该数据库的应用层协议。

DNS 协议运行在 *UDP* 之上，使用端口 `53`。

### DNS 工作机理概述

执行查询时，用户主机的 DNS 通过端口 `53` 向网络中发送一个 UDP 数据报形式的 **DNS 请求报文**。随后，DNS 接收到一个提供了所查询映射的 **DNS 响应报文**，映射结果传递给调用 DNS 的应用程序。

#### 分布式、层次数据库

DNS 采用的分布式设计：

![[Snipaste_240328_171700.png|500]]

![[Snipaste_240328_172114.png|500]]

- **根 DNS 服务器**
- **顶级域 DNS 服务器**：负责顶级域名 `com`、`org`、`net`、`edu`、`gov`，以及国家的顶级域名如 `uk`、`fr`、`ca`、`jp`
- **权威 DNS 服务器**

还有一种不属于层次结构的 DNS 服务器：**本地 DNS 服务器**。主机的本地 DNS 服务器通常较为邻近，由它代理本地的若干主机的 DNS 请求。

每个 ISP 都有本地 DNS 服务器，当主机连接到一个 ISP 时，后者提供一台特殊主机的 IP，它具有多台其 *本地 DNS 服务器* 的 IP。

![[Snipaste_240328_172525.png|350]]

上图中使用了 **递归查询**（查询 `1`） 和 **迭代查询**（查询 `2`、`4`、`6`）。

以自己的名义获得映射时，称该次查询为 *递归查询*，否则称为 *迭代查询*。

下图中的所有查询都是 *递归查询*：

![[Snipaste_240328_172811.png|350]]

#### DNS 缓存

在一条请求链中，每台 DNS 收到回答时都将结果缓存，并保留约 2 天。

本地 DNS 服务器经常使用缓存技术绕过根 DNS 服务器，从而减轻后者的压力。

### DNS 记录和报文

实现 DNS 系统的所有服务器存储数据的形式为 **资源记录**(RR)，每个 DNS 回答报文包含若干条 RR。

RR 是一个元组 `(Name, Value, Type, TTL)`。

- `Name` 和 `Value` 可视为键值对，它们是 RR 的实际内容，并取决于 `Type`：

| `Type`  | `Name`   | `Value`                           |
| ------- | -------- | --------------------------------- |
| `A`     | 主机名      | IP 地址                             |
| `NS`    | 一个域      | 知道如何获得该域中主机 IP<br>的权威 DNS 服务器的主机名 |
| `CNAME` | 主机名      | 规范主机名                             |
| `MX`    | 邮件服务器主机名 | 规范邮件服务器主机名                        |

- `TTL`：该 RR 的生存时间（用于更新缓存）。

<div style="page-break-after: always"></div>

# 3 运输层

## 概述和运输层服务

运输层协议为不同端系统的应用进程提供 **逻辑通信**。

### 运输层和网络层的关系

*运输层* 提供 *进程之间* 的逻辑通信，*网络层* 提供 *端系统之间* 的逻辑通信。

类比：两个家庭，各有若干人员以及一个负责管理邮件的人 Amy 和 Bob，则——

- 运输层协议 <=> Amy 和 Bob
- 网络层协议 <=> 邮政服务

运输层协议能提供的服务受制于网络层协议的服务模型。

### 因特网运输层概述

网络层的 **网际协议**(IP) 提供 **尽力而为交付服务**，不保证完整性和到达顺序，属于 **不可靠服务**。

UDP 也属于不可靠服务，而 TCP 额外提供了可靠数据传输和拥塞控制。

## 多路复用与多路分解

TCP 和 UDP 负责将端系统间 IP 的交付服务扩展到进程间的交付服务，称该过程为多路复用和多路分解。

每个进程有若干套接字，在源端系统，运输层从各个套接字收集数据、封装上首部信息生成报文段，并传递到网络中，称此过程为 **多路复用**(multiplexing)。

在目的端系统，运输层从网络层接收报文段，并将其中的数据交付给对应的套接字，称此过程为 **多路分解**(demultiplexing)。

继用前文的类比：

- 多路复用：Amy 收集邮件并交给邮递员
- 多路分解：Bob 拿到邮件并分发给收信人

每个报文段有 **源端口号** 字段和 **目的端口号** 字段。

`0` ~ `1023` 范围的端口号为 **周知端口号**，保留给 HTTP 等周知应用层协议。

#### 无连接的多路复用与多路分解

一个 *UDP 套接字* 由一个二元组 `(目的 IP, 目的端口号)` 唯一标识，如果两个报文段有相同的二元组，它们将通过同一个套接字定向到同一个目的进程。

#### 面向连接的多路复用与多路分解

一个 *TCP 套接字* 由一个四元组 `(源 IP, 源端口号, 目的 IP, 目的端口号)` 唯一标识。

#### Web 服务器与 TCP

Web 服务器通常只使用一个进程，而为每个新的客户连接创建一个新线程。

## 无连接运输：UDP

使用 UDP 发送报文段前无需握手，称其为无连接的。

UDP 的优点 / 应用场景：

- 实时应用（有最低发送速率要求，能容忍数据丢失）
- 不会引入建立连接的时延
- 无连接状态
- 首部开销小

### UDP 报文段结构

UDP 首部有 4 个字段，$4 \times 2 = 8$ 个字节。

![[Snipaste_240410_081444.png|300]]

### UDP 检验和

求 *检验和*：对报文段中所有字（$16$ 比特）求和，回卷所有溢出，最后取反。

![[Snipaste_240410_081456.png|500]]

UDP 只能检测而不能纠正差错，通常只是丢弃出错的报文段，最多警告上级应用程序。

## 可靠数据传输原理

![[Snipaste_240410_081606.png|500]]

### 构造可靠数据传输协议

最终版本：

![[Snipaste_240410_081806.png|600]]

| 机制   | 作用                              |
| ---- | ------------------------------- |
| 检验和  | 检测分组中的比特错误                      |
| 定时器  | 记录超时，以重传一个分组                    |
| 序号   | 为分组按顺序编号                        |
| 确认   | 接收方告诉发送方分组已被正确接收<br>携带着被确认分组的序号 |
| 否定确认 | 接收方告诉发送方分组未被正确接收<br>携带着未收到分组的序号 |
| 流水线  | 提高利用率                           |

### 流水线可靠数据传输协议

发送方的利用率：发送方实际忙于将比特送入信道的时间 $\div$ 发送时间。

用流水线提高利用率带来的影响：

- 必须增大序号空间大小。
- 双方需要缓存一定量的分组。

根据如何处理 *异常情况*（丢失 / 损坏 / 延时过长），有 2 种应对措施：*回退 N 步* / *选择重传*。

### 回退 N 步

- **基序号**(base)：最早的未确认分组的序号。
- **下一个序号**(nextseqnum)：下一个待发送分组的序号。

![[Snipaste_240410_083106.png|600]]

称 N 为窗口长度，**回退 N 步**(GBN) 又称为 **滑动窗口协议**。

GBN 发送方响应的事件：

- 上层调用 `send()` => 检查窗口，如果未满，发送一个新分组并更新变量
- 收到一个 ACK => 一个 `ACK n` 意味着接收方已正确接收 `n` 及之前的分组
- 超时 => 重传所有已发送而未被确认的分组，收到 ACK 也会重置计时器

GBN 的接收方丢弃所有失序分组，如果收到分组 `n`，检查上个确认的分组 `x`：

- `x == n - 1` => 保留 `n` 并发回 `ACK n`
- `x < n - 1` => 丢弃 `n` 并发回 `ACK x`

这样，接收方无需缓存任何失序分组，只需维护一个变量 `expectedseqnum`，指示下一个期望分组的序号。

![[Snipaste_240410_083918.png|400]]

### 选择重传

| 比较项        | GBN               | SR          |
| ---------- | ----------------- | ----------- |
| 重传         | 所有已发出而未确认的分组      | 怀疑出错的分组     |
| `ACK n` 含义 | 确认所有序号 `<= n` 的分组 | 确认单个分组 `n`  |
| 定时器        | 只有一个，针对窗口         | 有多个，与分组一一对应 |
| 缓存         | 无缓存               | 缓存所有失序分组    |
| 向上交付       | 逐一交付              | 按批交付        |

![[Snipaste_240410_084218.png|600]]

![[Snipaste_240410_084641.png|600]]

SR 中，`窗口长度 <= 序号空间 / 2`，否则可能无法区分某些分组是新的还是重传的。

## 面向连接的运输：TCP

### TCP 连接

- TCP 只在端系统运行，所有中间的网络元素不会知道或主动维持其连接状态。
- TCP 提供点对点的全双工连接，无法实现多播。

*三次握手* 的前 2 个特殊报文段不承载有效载荷，而由第 3 个报文段承载。

TCP 可从缓存中取出并放入报文段中的数据数量取决于 **最大报文段长度**(MSS)，后者又取决于最初确定的由本地主机发送的最大链路层帧长度 **最大传输单元**(MTU)。

TCP 连接的双方都持有缓存：

![[Snipaste_240416_220338.png|450]]

### TCP 报文段结构

TCP 首部一般为 $20$ 字节。

![[Snipaste_240416_220525.png|350]]

#### 序号和确认号

TCP 的序号字段根据传送的字节流（而非报文段）的顺序确定，一个 TCP 报文段的序号为其首字节的字节流编号。

TCP 的确认号为期望接收的下一字节的序号（而不是已经接收的最后一字节）。收到失序报文段时，暂时保存在缓存中并发送第一处空缺的序号，等待空缺被填补。

### 往返时间的估计与超时

#### 估计往返时间

报文段的 **样本 RTT**($\rm SampleRTT$) 为从发出该报文段直到收到其确认所消耗的时间。

- 在任意时刻，仅测量一个已发送而未收到其确认的报文段的 $\rm SampleRTT$。
- 不为测量重传报文的 $\rm SampleRTT$。

TCP 维护一个 $\rm SampleRTT$ 的加权均值 **估计 RTT**($\rm EstimatedRTT$)，每测量一个新的 $\rm SampleRTT$，就更新 $\rm EstimatedRTT$：

$$\rm EstimatedRTT_{new} = (1 - \alpha) \cdot EstimatedRTT_{old} + \alpha \cdot SampleRTT$$

通常取 $\alpha = 0.125$，此公式对样本的赋值权重随着样本测量时间的久远而快速降低。

用 **RTT 偏差**($\rm DevRTT$) 估算 $\rm SampleRTT$ 偏离 $\rm EstimatedRTT$ 的程度：

$$\rm DevRTT = (1 - \beta) \cdot DevRTT + \beta \cdot \lvert SampleRTT - EstimatedRTT \rvert$$

通常取 $\beta = 0.25$。

#### 设置和管理重传超时间隔

设置重传超时间隔的公式：

$$\rm TimeoutInterval = EstimatedRTT + 4 \cdot DevRTT$$

初始时设置 $\rm TimeoutInterval = 1$ 秒，更新规则：

- 出现超时 => $\rm TimeoutInterval$ 倍增
- 更新 $\rm SampleRTT$ => 用公式重算

### 可靠数据传输

因特网的网络层服务（IP）不可靠，而 TCP 在其上建立了一种可靠数据传输服务。

TCP 仅使用一个重传超时定时器，超时时重传引发超时的报文段并重置定时器。

#### 一些有趣的情况

`ACK 100` 中途丢失，主机 A 等待超时后重传 `Seq 92`：

![[Snipaste_240416_222732.png|350]]

两个 `ACK` 都遇到拥塞，主机 A 等待超时后重传 `Seq 92`，但由于在再次超时前收到两个 `ACK` 而没有重传 `Seq 100`：

![[Snipaste_240416_222909.png|350]]

`ACK 100` 中途丢失，但由于在再次超时前传输 `Seq 100` 并收到 `ACK 120` 而没有重传 `Seq 92`：

![[Snipaste_240416_223046.png|350]]

#### 快速重传

**冗余 ACK**：再次确认某个报文段的 ACK。

一旦收到 $3$ 个 *冗余 ACK*，就无视计时器而立即进行重传，称为 **快速重传**。

![[Snipaste_240416_223841.png|400]]

#### 是回退 N 步还是选择重传

与二者的相似之处：

- 与 GBN：发送方仅需维持已发送而未被确认的最小字节序号（SendBase）和下一个要发送的字节序号（NextSeqNum）。
- 与 SR：接收方缓存所有失序报文段；发送方只重传超时的那个报文段 `n`，如果后续接收到 `ACK m` 且 `m > n` 则甚至不会重传 `n`。

### 流量控制

- **流量控制**：*TCP* 为应用程序提供，以避免发送方发送过快使接收方 *缓存溢出*，属于 *速度匹配服务*。
- **拥塞控制**：*TCP* 发送方由于 *IP 网络* 的拥塞而被控制。

TCP 使发送方维护一个 **接收窗口**($\rm rwnd$) 进行流量控制，该窗口指示接收方目前可用的缓存空间大小。

发送方在连接的整个过程中须保证 $\rm LastByteSent - LastByteAcked \leqslant rwnd$。

当接收方的缓冲区溢出后重新被空出，需要通知发送方可以继续发送，机制为：当接收方 `rwnd == 0`，发送方持续发送只有 $1$ 字节的报文段，当接收方空出缓冲区后，将在确认报文中包含一个大于 $0$ 的 `rwnd` 值，示意发送方可以恢复发送。

### TCP 连接管理

客户与服务器建立一条 *TCP 连接* 的过程（*三次握手*）：

1. 客户向服务器发送一个特殊的 TCP 报文段，称为 **SYN 报文段**：
	- 首部的 *SYN 比特* 标志位为 `1`
	- *序号字段* 为随机选择的初始序号 `client_isn`
	- 不包含实际数据
2. 服务器收到 *SYN 报文段*，为连接分配缓存和变量，并发回一个允许连接的报文段，称为 **SYNACK 报文段**：
	- *SYN 比特* 为 `1`
	- *ACK* 为 `client_isn + 1`
	- *序号字段* 为随机选择的初始序号 `server_isn`
3. 客户端收到 *SYNACK 报文段*，为连接分配缓存和变量，并发回一个确认 *SYNACK 报文段* 的报文段：
	- *SYN 比特* 为 `0`
	- *ACK* 为 `server_isn + 1`
	- 可以包含实际数据

![[Snipaste_240424_083326.png|400]]

一条 *TCP 连接* 的任何一方都可以终止连接：

1. 发起方（A）发送一个特殊报文段，首部的 *FIN 比特* 标志位为 `1`。
2. 另一方（B）发回一个确认报文段。
3. B 发送自己的终止报文段（*FIN 比特* 为 `1`）。
4. A 发回一个确认报文段。

![[Snipaste_240424_083558.png|400]]

## 拥塞控制原理

*丢包* 一般是当网络拥塞时由于路由器 *缓存溢出* 引起。

### 拥塞控制方法

- 端到端拥塞控制：端系统通过对网络行为的观察推断拥塞程度。
- 网络辅助的拥塞控制：网络层构件（路由器）发送方提供网络拥塞情况的反馈。

## TCP 拥塞控制

TCP 必须使用 *端到端的拥塞控制*，即让每一个发送方自感知拥塞程度并调整发送速率。

> [!question] 如何调整发送速率

发送方跟踪一个额外的变量 **拥塞窗口**，记为 `cwnd`，从而限制速率：$$\rm LastByteSend - LastByteAcked \leqslant min \{cwnd, rwnd\}$$

> [!question] 如何感知拥塞程度

定义 *“丢包事件”* 为二者之一：

- *超时*
- 收到 3 个 *冗余 ACK*

TCP 发送方调整发送速率的规则：

- 发生 *“丢包事件”* -> 拥塞 => 降速
- 收到 *ACK 报文段* -> 畅通 => 提速

> [!question] 采用何种调整算法

**TCP 拥塞控制算法** 的 FSM 描述：

![[TCP 拥塞控制的 FSM 描述.png|600]]

任何状态下发生——

- *超时* => *慢启动*
- *冗余* => *快速恢复*

#### 慢启动

跟踪变量 **慢启动阈值** `ssthresh`。

`cwnd` 从 $1$ MSS 开始，每经过 $1$ RTT 就倍增，直到 `cwnd >= ssthresh` 后转移到 *拥塞避免* 状态。

`cwnd` 不能通过倍增超过 `ssthresh`，例如，某一时刻 `cwnd == 4`，`ssthresh == 7`，那么 $1$ RTT 后 `cwnd == 7`（而非 `4 * 2 = 8`）。

#### 拥塞避免

每经过 $1$ RTT，`cwnd` 加上 $1$ MSS。

#### 快速恢复

当收到引起转移到 *快速恢复* 的报文段的 ACK 时，转移到 *拥塞避免*。如果发生 *超时*，转移到 *慢启动*。

#### TCP 拥塞控制：回顾

TCP 有两个版本：旧版的 **Tahoe**，新版的 **Reno**。

*Tahoe* 没有 *快速恢复* 状态，因此任何 *“丢包事件”* 都将导致重新开始 *慢启动*。

下图中，`Round 8` 时出现 *冗余* 事件，随后 *Tahoe* 与 *Reno* 的轨迹有所不同：

![[Snipaste_240424_080214.png|600]]

假设使用 *Reno*，且 *“丢包事件”* 只有 *冗余*，那么：

- 每个 RTT 内 `cwnd` 加性增 $1$ MSS
- 发生 *冗余* 时 `cwnd` 乘性减半

因此称 *TCP 拥塞控制* 为 **加性增、乘性减**(AIMD) 的：

![[Snipaste_240424_081428.png|500]]

#### 对 TCP 吞吐量的宏观描述

记 $W$ 为发生 *“丢包事件”* 时的 `cwnd`，一条连接的平均吞吐量为：$$\frac{0.75 \times W}{{\rm RTT}}$$

#### 经高带宽路径的 TCP

记 $L$ 为丢包率，一条连接的平均吞吐量：$$\rm \frac{1.22 \times MSS}{ RTT}$$

#### 公平性和 UDP

*UDP 源* 可能压制 TCP 流量。

<div style="page-break-after: always"></div>

# 4 网络层

不同于 *运输层* 和 *应用层*，网络中的每台主机、每台路由器都运行着 *网络层*。

## 概述

![[网络层.png|350]]

### 转发和路由选择

**转发**：路由器将收到的分组移动到适当输出链路的过程。

**路由选择**：网络中的所有路由器经 *路由选择协议* 协同决定分组从源到目的地结点的具体路径。

*转发* 是单个路由器的动作，*路由选择* 是全网络范围的动作。

**转发表**：每台路由器持有，它检查到达分组首部字段的值并查询 *转发表* 进行 *转发*。

*转发* 的决定：

- 链路层交换机基于 *链路层* 字段的值
- 路由器基于 *网络层* 字段的值

### 网络服务模型

**网络服务模型** 定义了分组在发送与接收端系统之间的端到端运输特性。

因特网的网络层提供 *尽力而为服务*；ATM 网络提供 **恒定比特率(CBR) ATM 网络服务** 和 **可用比特率(ABR) ATM 网络服务**。

## 虚电路和数据报网络

*网络层* 也能提供面向连接服务和无连接服务，但与 *运输层* 有所不同：

- 在网络层中，这些服务是由网络层向运输层提供的 *主机到主机* 的服务；而在运输层中，这些服务是由运输层向应用层提供的 *进程到进程* 的服务。
- 每种网络体系结构只提供 *面向连接服务* ==或== *无连接服务*，分别称为 **虚电路(VC)网络**、**数据报(datagram)网络**。

### 虚电路网络

除因特网外的很多其他网络体系结构都是 *虚电路网络*，称它们在网络层的连接为 *虚电路*。

*虚电路* 的 3 个阶段：虚电路建立 -> 数据传送 -> 虚电路拆除。

一条 *虚电路* 的构成：

- 源和目的主机之间的一系列 *路由器和链路*
- 每段链路的 *VC 号*
- 每台路由器的 *转发表* 表项

通过虚电路传输的分组在其首部携带一个 *VC 号*，每到达一个路由器，后者就从转发表中获取一个新的 VC 号赋予分组。这样做的理由：

- 减少分组首部中 VC 字段的长度
- 简化虚电路的建立

*虚电路网络* 中的路由器需要为每条连接维持 **连接状态信息**，每跨越某台路由器建立一个新连接，它的 *转发表* 中就增加一项，该连接拆除时，该项随之删除。

对比 *虚电路* 与 *运输层的连接*：

- *运输层的连接* 建立时，两个端系统决定参数且知情，中间路由器均不知情。
- *虚电路* 建立时，需要所有中间路由器的参与，它们都知情。

**信令报文**：端系统向网络发送的、指示虚电路建立与拆除的报文，以及路由器之间传递的、用于建立与拆除虚电路的报文。

**信令协议**：交换 *信令报文* 的协议。

### 数据报网络

在 *数据报网络* 中，端系统要发送分组时，需为其加上首部控制信息，然后将其推进网络，每台中间路由器查询其转发表以转发分组。

假设一台路由器有 4 个出链路，其转发表如下：

![[Snipaste_240423_190749.png|400]]

有一个到达分组的目的地址为 `11001000 00010111 00011000 10101010`，它的前缀与输出链路 `1`、`2` 都匹配，但将由 **最长前缀匹配规则** 被匹配到 `1`。

对比 *数据报网络* 和 *虚电路网络* 的转发表更新：

- *虚电路网络* 在有经过路由器的连接建立或拆除时更新
- *数据报网络* 每 $1$ ~ $5$ 分钟运行一次路由选择算法更新

### 虚电路和数据报网络的由来

*虚电路网络* 比 *数据报网络* 复杂。

*因特网* 作为一种数据报网络，很多额外功能（可靠数据传输、拥塞控制、DNS）在端系统的更高层实现，因而其实现简单、易于扩展。

## 路由器工作原理

路由器体系结构：

![[Snipaste_240423_191530.png|600]]

**路由选择处理器** 执行 *路由选择协议*，维护 *路由选择表* 和连接的状态信息，计算 *转发表*，并执行网络管理功能。

**输入端口**、**输出端口** 和 **交换结构** 共同实现了转发功能，总称其为 **路由器转发平面**，其为 *硬件实现*（因为远快于软件实现）。

称路由器的控制功能为 **路由器控制平面**，其为 *软件实现*。

### 输入端口

路由器使用 *转发表* 查询输出端口，而 *输入端口* 存有该表的一个副本。

![[Snipaste_240423_192130.png|400]]

查询需用极快的硬件进行，通常使用 **三态内容可寻址存储器**(TCAM)。

### 交换结构

交换的完成方式：

- 经内存：同一时间只能执行一个内存读写（即转发一个分组）。
	- 记内存带宽为读写 $B$ 分组/秒，则总的转发吞吐量 $\leqslant$ $\large \frac{B}{2}$ 分组/秒。
- 经总线：同一时间只允许一个分组通过总线。
- 经互联网络：可以并行转发多个分组。

![[Snipaste_240427_150331.png|500]]

### 输出端口

![[Snipaste_240427_150728.png|500]]

### 何处出现排队

发生处理缓慢的部位——

- 交换结构 => 输入端口排队
- 输出端口 => 输出端口排队

**线路前部(HOL)阻塞**：在一个输入队列中排队的分组被位于线路前部的另一个分组所阻塞，而不得不等待通过交换结构，即使它的目标输出端口是空闲的。

下图中，3 个深蓝色的数据报竞争上方输出端口，浅蓝色的数据报的目标为中间输出端口，但它被其前方的深蓝色所阻塞（因为竞争失败）：

![[Snipaste_240427_151004.png|400]]

## 网际协议：因特网中的转发和编址

### 数据报格式

IPv4 首部有 $20$ 个字节（假设没有 `option` 字段）。

![[Snipaste_240429_132821.png|450]]

#### IP 数据报分片

![[MSS 与 MTU.png|450]]

数据报所经路径上每段链路的 *MTU* 可能不同，因此传输时将其分为若干片，由接收方端系统负责重新组装。

> message -> package -> datagram -> fragment -> frame

![[Snipaste_240429_133230.png|500]]

- 发送主机将每个数据报的 **标识号** 递增 `1`（同一数据报的不同分片，其 *标识号* 与原数据报相同）
- 设有 `n` 个分片，则前 `n - 1` 个的 **标志比特** 均为 `1`，最后一个的为 `0`，表示本数据报的结束；且前 `n - 1` 个均为定长，最后一个补足余量
- 用 **偏移字段** 标识每个片所在原数据报中的位置，它必须为 `8` 的倍数（偏移值 $\times$ `8` $=$ 字节数）

发送一个总长 `4000` 字节的数据报：

![[Snipaste_240429_133320.png|600]]

数据报的 **有效载荷** 仅在所有分片重组成功时向上交给运输层，如果接收到的分片不完整，将直接丢弃。

*IPv6* 废除了分片机制。

### IPv4 编址

**接口**：主机与物理链路之间的边界。

一个 IP 地址与一个 *接口* 相关联，而不是一台路由器或主机。

**子网**：下图中的 3 个灰色阴影部分。

![[Snipaste_240429_134303.png|400]]

上图中最左侧的 *子网* 有着 IP 地址 `223.1.1.0/24`，其中的 `24` 为 **子网掩码**，意为 $32$ 比特中的左侧 $24$ 比特定义了 *子网* 地址。

*子网掩码* 形式上必须为 `1..10..0`，称前面为 `1` 的位为 *网络位*，称后面为 `0` 的位为 *主机位*。

下图中则有 6 个 *子网*：包括 3 个路由器两两之间的网络。

![[Snipaste_240429_134545.png|350]]

因特网的地址分配策略称为 **无类别域间路由选择**(CIDR)。

`255.255.255.255` 为 **IP 广播地址**，以之为目的地址的数据报将传输给所在网络中的所有主机。

> [!tip] 计算某子网的网络地址、广播地址、主机地址范围、主机数量
> 
> 已知任一接口的 IP 地址 `ip` 和子网掩码 `mask`：
> 
> - `网络地址 = ip & mask`
> - `广播地址 = network_addr | (!mask)`（`网络地址` 的 *主机位* 全变为 `1`）
> - 主机地址范围为 `(网络地址 + 1)..=(广播地址 - 1)`
> - 主机数量为 `pow(2, 主机位数) - 2`

> [!question] 主机和子网最初如何取得自身的地址？

1. 获取一块地址

IP 地址由 **因特网名字和编号分配机构**(ICANN) 管理，它向各 *ISP* 分配一些地址，后者再分发给下级组织。

![[Snipaste_240429_204638.png|600]]

2. 获取主机地址：动态主机配置协议

组织为其中的主机和路由器接口逐个分配地址，由 **动态主机配置协议**(DHCP) 自动完成，它是一种 *即插即用协议*。

每个 *子网* 有若干 *DHCP* 服务器。

新到达子网的主机获取其 IP 地址的步骤：DHCP 发现 -> ~ 提供 -> ~ 请求 -> ~ 确认。

这 4 个报文的 `ip_dest` 均为 *IP 广播地址*。

![[Snipaste_240429_205147.png|400]]

*DHCP* 的不足：子网中一个地理上移动的结点将不断得到新的 IP 地址，无法维持与远程应用间的 TCP 连接。

3. 网络地址转换

**网络地址转换**(NAT) 隐藏内部主机的地址，而对外界暴露一个特殊的地址，其地址空间取 `10/8` / `172.16/12` / `192.168/16` 之一。

NAT 路由器对外界的行为如同一个具有单一 IP 地址的单一设备，它使用一张 **NAT 转换表** 决定将收到的分组转发给内部的哪一台主机（表项为 `{端口号, IP/端口号}`）。

*NAT* 妨碍 *P2P* 程序。

4. UPnP

**通用即插即用**(UPnP) 允许外部主机使用 TCP 或 UDP 向 *NAT 化* 的主机发起通信会话。

### 因特网控制报文协议

**因特网控制报文协议**(ICMP) 使得主机和路由器能够沟通网络层信息，例如差错报告。

### IPv6

#### IPv6 数据报格式

![[Snipaste_240508_093031.png|500]]

- 地址长度由 $32$ 比特增加到 $128$ 比特
- 简化高效的 $40$ 字节首部

#### 从 IPv4 到 IPv6 的迁移

**双栈**(dual-stack) 和 **建隧道**。

## 路由选择算法

*路由选择* 的目标：确定从发送方到接收方通过路由器网络的好路径。

主机通常直接与一台路由器连接，称其为主机的 **默认路由器** / **第一跳路由器**。

称源主机的 *默认路由器* 为 **源路由器**，称目的主机的为 **目的路由器**。

路由选择算法的分类：

| 分类方法  | 类别                                               |
| ----- | ------------------------------------------------ |
| 实现方式  | 全局式：又称 **链路状态**(LS) 算法<br>分散式：例如 **距离向量**(DV) 算法 |
| 变化情况  | 静态：路由随时间变化缓慢<br>动态：当网络负载变化时改变路由选择路径              |
| 负载敏感性 | 负载敏感：链路费用动态变化，以反映拥塞程度<br>负载迟钝：链路费用不明显反映拥塞程度      |

### 链路状态路由选择算法

*LS 算法* 的常见实现为 *Dijkstra 算法*。

![[Snipaste_240512_091925.png|400]]

![[Snipaste_240512_092002.png|600]]

**路由震荡**：线路费用变化太快，路由选择频繁改变，数据包的路线频繁变动，有时甚至走回头路，导致数据传输变慢甚至丢失。

避免 *路由震荡* 的方法：确保所有路由器不同时运行 *LS 算法*，随机化路由器发送链路通告的时间。

<div style="page-break-after: always"></div>

# 5 链路层：链路、接入网和局域网

## 链路层概述

**结点**：运行 *链路层协议* 的任何设备。

**链路**：沿着通信路径连接相邻结点的通信信道。

### 链路层提供的服务

- 成帧
- 链路接入：**介质访问控制**(MAC) 规定了帧在链路上传输的规则
- 可靠交付
- 差错检测和纠正

### 链路层在何处实现

链路层的主体部分在 **网络适配器**/**网络接口卡** 中实现。

## 差错检测和纠正技术

### 奇偶校验

设实际数据有 $d$ bit，*偶校验* 要附加额外的 $1$ 比特，使 $d + 1$ 比特中 `1` 的数量为偶，*奇校验* 则是使其数量为奇。

*二维奇偶校验* 还能定位单个错误的比特。

### 检验和方法

将数据的字节视为 $16$ bit 的整数，求和后取反码，作为检验和。

### 循环冗余检测

**循环冗余检测**(CRC) 编码：设要发送 $d$ 比特的数据 $D$，双方事先商定一个 $r + 1$ bit 的 **生成多项式** $G$（要求最高位为 `1`），发送方在 $D$ 的末端附加一个 $r$ bit 的 **CRC 比特** $R$ 作为实际发送的数据 $D^\prime$，接收方计算 $D^\prime \space {\rm mod} \space G$，当且仅当结果为 $0$ 时认为传输无误。

$R$ 的计算：$$R = D \cdot 2^r \space {\rm mod} \space G$$

在计算 $R$ 的过程中涉及到特殊的二进制计算，所有操作均等价于 $\rm XOR$ 且无视进位：

- $1 + 1 = 0$
- $0 - 1 = 1$

*CRC* 能够测出所有连续 $r$ bit 或更少的差错。

## 多路访问链路和协议

多路访问协议能够划分为 3 种类型：

- 信道划分协议
	- 时分多路复用
	- 频分多路复用
	- 码分多址
- 随机接入协议
	- 时隙 ALOHA
	- 纯 ALOHA
	- 载波侦听多路访问 CSMA
	- 具有碰撞检测的载波侦听多路访问 CSMA/CD
- 轮流协议
	- 轮询
	- 令牌传递

## 交换局域网

### 链路层寻址和 ARP

#### MAC 地址

主机和路由器的适配器（网络接口）具有一个 *网络层的 IP 地址* 和一个 *链路层的* **LAN 地址**/**物理地址**/**MAC 地址**。

*MAC 地址* 与 IP 地址的比较：

- MAC 地址具有扁平结构，而 IP 地址具有层次结构
- MAC 地址不像 IP 地址一样随着设备的移动而改变
- 二者的广播地址均为全 `1` 的串
- IPv4 地址长 $32$ 字节，MAC 地址长 $48$ 字节，IPv6 地址长 $128$ 字节
- IPv4 用点分十进制表示，MAC 以十六进制和 `-` 表示，IPv6 以十六进制和 `:` 表示

#### 地址解析协议

**地址解析协议**(ARP) 负责将 IP 地址转换为 MAC 地址。

ARP 和 DNS 解析的比较：

- DNS 将主机名解析为 IP 地址，ARP 将 IP 地址解析为 MAC 地址
- DNS 为因特网中的任何主机工作，ARP 只为与其在同一子网的主机工作

ARP 查询分组的目的地址为 *MAC 广播地址* `FF-FF-FF-FF-FF-FF`，而响应分组的目的地址为发起查询的主机。

一个可能的 ARP 表：

| IP 地址             | MAC 地址              | TTL      |
| ----------------- | ------------------- | -------- |
| `222.222.222.221` | `88-B2-2F-54-1A-0F` | 13:45:00 |
| `222.222.222.223` | `5C-66-AB-90-75-B1` | 13:52:00 |

ARP 表是自动建立的，无需管理员手动配置。

#### 发送数据报到子网以外

发送的过程中，目标 IP 地址不变，但目标 MAC 地址在每个子网中都不同。

### 以太网

#### 以太网的 3 个发展阶段

##### 总线结构

##### 物理（拓扑）星形、逻辑（实际）总线结构

中心为基于 **集线器**(hub)，作用于比特，将到达比特放大后输出到所有接口

##### 星形结构

将 *集线器* 替换为 *交换机*，当其收到来自接口 $x$ 的报文时，检查其表项——

- 无对应表项 => 广播给除 $x$ 外的所有接口（*洪泛*）
- 对应目标接口为 $y$ =>
	- $y = x$ => 忽略并丢弃（*过滤*）
	- $y \neq x$ => 转发到接口 $y$（*转发*）

![[以太网的吞吐量.png|400]]