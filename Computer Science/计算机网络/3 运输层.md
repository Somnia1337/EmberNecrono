👈 [[2 应用层]]

## 概述和运输层服务

运输层协议为不同端系统的应用进程提供 **逻辑通信**。

### 运输层和网络层的关系

运输层在网络层上，前者提供进程之间的逻辑通信，后者提供端系统之间的逻辑通信。

类比：两个家庭，各有若干人员以及一个负责管理邮件的人 Amy 和 Bob，则——

- 运输层协议 <=> Amy 和 Bob
- 网络层协议 <=> 邮政服务

运输层协议能提供的服务受制于网络层协议的服务模型。

### 因特网运输层概述

网络层的 **网际协议**(IP) 提供 **尽力而为交付服务**，不保证完整性和到达顺序，属于 **不可靠服务**。

UDP 也属于不可靠服务，而 TCP 额外提供了可靠数据传输和拥塞控制。

## 多路复用与多路分解

TCP 和 UDP 负责将端系统间 IP 的交付服务扩展到进程间的交付服务，称该过程为多路复用和多路分解。

每个进程有若干套接字，在源端系统，运输层从各个套接字收集数据、封装上首部信息生成报文段，并传递到网络中，称此过程为 **多路复用**(multiplexing)。

在目的端系统，运输层从网络层接收报文段，并将其中的数据交付给对应的套接字，称此过程为 **多路分解**(demultiplexing)。

继用前文的类比：

- 多路复用：Amy 收集邮件并交给邮递员
- 多路分解：Bob 拿到邮件并分发给收信人

每个报文段有 **源端口号** 字段和 **目的端口号** 字段。

`0` ~ `1023` 范围的端口号为 **周知端口号**，保留给 HTTP 等周知应用层协议。

#### 无连接的多路复用与多路分解

一个 UDP 套接字由一个二元组 `(目的 IP, 目的端口号)` 唯一标识，该二元组相同的两个报文段将通过同一个套接字定向到同一个目的进程。

#### 面向连接的多路复用与多路分解

一个 TCP 套接字由一个四元组 `(源 IP, 源端口号, 目的 IP, 目的端口号)` 唯一标识

#### Web 服务器与 TCP

Web 服务器通常只使用一个进程，而为每个新的客户连接创建一个新线程。

## 无连接运输：UDP

使用 UDP 发送报文段前无需握手，称其为无连接的。

UDP 的优点 / 应用场景：

- 实时应用（要求最小发送速率，能容忍数据丢失）
- 不会引入建立连接的时延
- 无连接状态
- 首部开销小

### UDP 报文段结构

UDP 首部只有 4 个字段、$4 \times 2 = 8$ 个字节。

![[Snipaste_240410_081444.png|400]]

### UDP 检验和

求检验和：对报文段中所有字（$16$ 比特）求和，回卷任何溢出，最后取反。

![[Snipaste_240410_081456.png|500]]

UDP 只能检测、不能恢复差错，通常只是丢弃出错的报文段，最多警告上级应用程序。

## 可靠数据传输原理

![[Snipaste_240410_081606.png|600]]

### 构造可靠数据传输协议

最终版本：

![[Snipaste_240410_081806.png|600]]

| 机制   | 说明                              |
| ---- | ------------------------------- |
| 检验和  | 检测分组中的比特错误                      |
| 定时器  | 超时/重传一个分组                       |
| 序号   | 为分组按顺序编号                        |
| 确认   | 接收方告诉发送方分组已被正确接收<br>携带着被确认分组的序号 |
| 否定确认 | 接收方告诉发送方分组未被正确接收<br>携带着未收到分组的序号 |
| 流水线  | 提高利用率                           |

### 流水线可靠数据传输协议

发送方的利用率：发送方实际忙于将比特送入信道的时间 $\div$ 发送时间。

用流水线提高利用率带来的影响：

- 必须增大序号空间大小。
- 双方需要缓存一定量的分组。

对这两个新影响的应对措施取决于如何处理异常情况（丢失 / 损坏 / 延时过长）：回退 N 步 / 选择重传。

### 回退 N 步

- **基序号**(base)：最早的未确认分组的序号。
- **下一个序号**(nextseqnum)：下一个待发分组的序号。

![[Snipaste_240410_083106.png|600]]

称 N 为窗口长度，GBN 常称为 **滑动窗口协议**。

GBN 发送方响应的事件：

- 上层调用 `send()` 时检查窗口，如果未满，发送一个新分组并更新变量。
- 收到一个 ACK，一个 `ACK n` 意味着接收方已正确接收 `n` 及之前的分组。
- 超时，重传所有已发送而未被确认的分组，收到 ACK 也会重启计时器。

GBN 的接收方丢弃所有失序分组，如果收到分组 `n`，检查上个确认的分组 `x`：

- 如果 `x == n - 1`，保留 `n` 并发回 `ACK n`。
- 否则（`x < n - 1`），丢弃 `n` 并发回 `ACK x`。

这样，接收方无需缓存任何失序分组，只需维护一个变量 `expectedseqnum`，指示下一个按序分组的序号。

![[Snipaste_240410_083918.png|400]]

### 选择重传

| 比较项        | GBN               | SR         |
| ---------- | ----------------- | ---------- |
| 重传         | 已发出而未被确认的所有分组     | 怀疑出错的分组    |
| `ACK n` 含义 | 确认序号 `<= n` 的所有分组 | 确认单个分组 `n` |
| 定时器        | 只有一个，针对窗口         | 有多个，针对每个分组 |
| 缓存         | 无缓存               | 所有失序分组     |
| 交付         | 逐一交付              | 按批交付       |

![[Snipaste_240410_084218.png|600]]

![[Snipaste_240410_084641.png|600]]

SR 中，窗口长度 `<=` 序号空间大小的一半，否则可能无法区分某些分组是新分组还是重传分组。

👉 