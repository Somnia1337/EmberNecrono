👈 [[2 应用层]]

## 概述和运输层服务

运输层协议为不同端系统的应用进程提供 **逻辑通信**。

### 运输层和网络层的关系

运输层在网络层上，前者提供进程之间的逻辑通信，后者提供端系统之间的逻辑通信。

类比：两个家庭，各有若干人员以及一个负责管理邮件的人 Amy 和 Bob，则——

- 运输层协议 <=> Amy 和 Bob
- 网络层协议 <=> 邮政服务

运输层协议能提供的服务受制于网络层协议的服务模型。

### 因特网运输层概述

网络层的 **网际协议**(IP) 提供 **尽力而为交付服务**，不保证完整性和到达顺序，属于 **不可靠服务**。

UDP 也属于不可靠服务，而 TCP 额外提供了可靠数据传输和拥塞控制。

## 多路复用与多路分解

TCP 和 UDP 负责将端系统间 IP 的交付服务扩展到进程间的交付服务，称该过程为多路复用和多路分解。

每个进程有若干套接字，在源端系统，运输层从各个套接字收集数据、封装上首部信息生成报文段，并传递到网络中，称此过程为 **多路复用**(multiplexing)。

在目的端系统，运输层从网络层接收报文段，并将其中的数据交付给对应的套接字，称此过程为 **多路分解**(demultiplexing)。

继用前文的类比：

- 多路复用：Amy 收集邮件并交给邮递员
- 多路分解：Bob 拿到邮件并分发给收信人

每个报文段有 **源端口号** 字段和 **目的端口号** 字段。

`0` ~ `1023` 范围的端口号为 **周知端口号**，保留给 HTTP 等周知应用层协议。

#### 无连接的多路复用与多路分解

一个 UDP 套接字由一个二元组 `(目的 IP, 目的端口号)` 唯一标识，如果两个报文段有相同的二元组，它们将通过同一个套接字定向到同一个目的进程。

#### 面向连接的多路复用与多路分解

一个 TCP 套接字由一个四元组 `(源 IP, 源端口号, 目的 IP, 目的端口号)` 唯一标识

#### Web 服务器与 TCP

Web 服务器通常只使用一个进程，而为每个新的客户连接创建一个新线程。

## 无连接运输：UDP

使用 UDP 发送报文段前无需握手，称其为无连接的。

UDP 的优点 / 应用场景：

- 实时应用（要求最小发送速率，能容忍数据丢失）
- 不会引入建立连接的时延
- 无连接状态
- 首部开销小

### UDP 报文段结构

UDP 首部有 4 个字段，$4 \times 2 = 8$ 个字节。

![[Snipaste_240410_081444.png|400]]

### UDP 检验和

求检验和：对报文段中所有字（$16$ 比特）求和，回卷任何溢出，最后取反。

![[Snipaste_240410_081456.png|500]]

UDP 只能检测、不能恢复差错，通常只是丢弃出错的报文段，最多警告上级应用程序。

## 可靠数据传输原理

![[Snipaste_240410_081606.png|600]]

### 构造可靠数据传输协议

最终版本：

![[Snipaste_240410_081806.png|600]]

| 机制   | 说明                              |
| ---- | ------------------------------- |
| 检验和  | 检测分组中的比特错误                      |
| 定时器  | 超时/重传一个分组                       |
| 序号   | 为分组按顺序编号                        |
| 确认   | 接收方告诉发送方分组已被正确接收<br>携带着被确认分组的序号 |
| 否定确认 | 接收方告诉发送方分组未被正确接收<br>携带着未收到分组的序号 |
| 流水线  | 提高利用率                           |

### 流水线可靠数据传输协议

发送方的利用率：发送方实际忙于将比特送入信道的时间 $\div$ 发送时间。

用流水线提高利用率带来的影响：

- 必须增大序号空间大小。
- 双方需要缓存一定量的分组。

对这两个新影响的应对措施取决于如何处理异常情况（丢失 / 损坏 / 延时过长）：回退 N 步 / 选择重传。

### 回退 N 步

- **基序号**(base)：最早的未确认分组的序号。
- **下一个序号**(nextseqnum)：下一个待发分组的序号。

![[Snipaste_240410_083106.png|600]]

称 N 为窗口长度，GBN 常称为 **滑动窗口协议**。

GBN 发送方响应的事件：

- 上层调用 `send()` 时检查窗口，如果未满，发送一个新分组并更新变量。
- 收到一个 ACK，一个 `ACK n` 意味着接收方已正确接收 `n` 及之前的分组。
- 超时，重传所有已发送而未被确认的分组，收到 ACK 也会重启计时器。

GBN 的接收方丢弃所有失序分组，如果收到分组 `n`，检查上个确认的分组 `x`：

- 如果 `x == n - 1`，保留 `n` 并发回 `ACK n`。
- 否则（`x < n - 1`），丢弃 `n` 并发回 `ACK x`。

这样，接收方无需缓存任何失序分组，只需维护一个变量 `expectedseqnum`，指示下一个按序分组的序号。

![[Snipaste_240410_083918.png|400]]

### 选择重传

| 比较项        | GBN               | SR         |
| ---------- | ----------------- | ---------- |
| 重传         | 已发出而未被确认的所有分组     | 怀疑出错的分组    |
| `ACK n` 含义 | 确认序号 `<= n` 的所有分组 | 确认单个分组 `n` |
| 定时器        | 只有一个，针对窗口         | 有多个，针对每个分组 |
| 缓存         | 无缓存               | 所有失序分组     |
| 交付         | 逐一交付              | 按批交付       |

![[Snipaste_240410_084218.png|600]]

![[Snipaste_240410_084641.png|600]]

SR 中，窗口长度 `<=` 序号空间大小的一半，否则可能无法区分某些分组是新分组还是重传分组。

## 面向连接的运输：TCP

### TCP 连接

- TCP 只在端系统运行，所有中间的网络元素不会知道或维持连接状态。
- TCP 提供点对点的全双工连接，无法实现多播。

三次握手：前 2 个特殊报文段不承载有效载荷，而由第 3 个报文段承载。

TCP 可从缓存中取出并放入报文段中的数据数量受限于 **最大报文段长度**(Maximum Segment Size，MSS)，后者根据最初确定的由本地主机发送的最大链路层帧长度——即 **最大传输单元**(Maximum Transmission Unit，MTU)——确定。

TCP 连接的双方都持有缓存：

![[Snipaste_240416_220338.png|500]]

### TCP 报文段结构

TCP 首部一般为 $20$ 字节。

![[Snipaste_240416_220525.png|500]]

#### 序号和确认号

TCP 的序号字段根据传送的字节流、而非报文段的顺序确定，一个 TCP 报文段的序号为其首字节的字节流编号。

TCP 的确认号为期望接收的下一字节的序号（而不是已经接收的最后一字节）。收到失序报文段时，暂时保存在缓存中并发送第一处空缺的序号，等待空缺被填补。

#### Telnet：序号和确认号的一个学习案例

### 往返时间的估计与超时

#### 估计往返时间

报文段的样本 RTT（$\rm SampleRTT$）指从发出该报文段直到收到其确认所消耗的时间。

- 在任意时刻，仅测量一个已发送而未收到其确认的报文段的 $\rm SampleRTT$。
- 不为重传报文测量 $\rm SampleRTT$。

TCP 维持一个 $\rm SampleRTT$ 的均值 $\rm EstimatedRTT$，每测量一个新的 $\rm SampleRTT$，就更新 $\rm EstimatedRTT$：

$$\rm EstimatedRTT = (1 - \alpha) \cdot EstimatedRTT + \alpha \cdot SampleRTT$$

通常取 $\alpha = 0.125$，此公式对样本的赋值权重随着样本测量时间的久远而快速降低。

用 RTT 偏差（$\rm DevRTT$）估算 $\rm SampleRTT$ 偏离 $\rm EstimatedRTT$ 的程度：

$$\rm DevRTT = (1 - \beta) \cdot DevRTT + \beta \cdot \lvert SampleRTT - EstimatedRTT \rvert$$

通常取 $\beta = 0.25$。

#### 设置和管理重传超时间隔

设置重传超时间隔的公式：

$$\rm TimeoutInterval = EstimatedRTT + 4 \cdot DevRTT$$

初始时设置 $\rm TimeoutInterval = 1$ 秒，更新规则：

- 出现超时 => $\rm TimeoutInterval$ 倍增，
- 更新 $\rm SampleRTT$ => 用公式重算，

### 可靠数据传输

因特网的网络层服务（IP）不可靠，而 TCP 在不可靠的 IP 上建立了一种可靠数据传输服务。

TCP 仅使用一个重传超时定时器，超时时重传引发的报文段并重置定时器。

#### 一些有趣的情况

`ACK 100` 中途丢失，主机 A 等待超时后重传 `Seq 92`：

![[Snipaste_240416_222732.png|400]]

两个 `ACK` 都遇到拥塞，主机 A 等待超时后重传 `Seq 92`，但由于在再次超时前收到两个 `ACK` 而没有重传 `Seq 100`：

![[Snipaste_240416_222909.png|400]]

`ACK 100` 中途丢失，但由于在再次超时前传输 `Seq 100` 并收到 `ACK 120` 而没有重传 `Seq 92`：

![[Snipaste_240416_223046.png|400]]

#### 超时间隔加倍

#### 快速重传

**冗余 ACK** 指再次确认某个报文段的 ACK，一旦收到 $3$ 个冗余 ACK，就无视计时器而立即进行重传，称为 **快速重传**。

![[Snipaste_240416_223841.png|400]]

#### 是回退 N 步还是选择重传

与二者的相似之处：

- 与 GBN：发送方仅需维持已发送而未被确认的最小字节序号（SendBase）和下一个要发送的字节序号（NextSeqNum）。
- 与 SR：接收方缓存所有失序报文段；发送方只重传超时的那 1 个报文段 `n`，如果后续接收到 `ACK m` 且 `m > n` 则甚至不会重传 `n`。

### 流量控制

- **流量控制**：*TCP* 为应用程序提供，以避免发送方发送过快使接收方 *缓存溢出*，属于 *速度匹配服务*。
- **拥塞控制**：*TCP* 发送方由于 *IP* 网络的拥塞而被控制。

TCP 使发送方维护一个 **接收窗口**（$\rm rwnd$）进行流量控制，该窗口指示接收方目前可用的缓存空间大小。

发送方在连接的整个过程中须保证 $\rm LastByteSent - LastByteAcked \leqslant rwnd$。

当接收方的缓冲区溢出后重新被空出，需要通知发送方可以继续发送，机制为：当接收方 `rwnd == 0`，发送方持续发送只有 $1$ 字节的报文段，当接收方空出缓冲区后，将在确认报文中包含一个大于 $0$ 的 `rwnd` 值。

### TCP 连接管理

## 拥塞控制原理

### 拥塞原因与代价

### 拥塞控制方法

## TCP 拥塞控制

TCP 必须使用 *端到端的拥塞控制*，即让每一个发送方感知拥塞程度并调整发送速率。

> [!question] 讨论的问题
> 
> - 如何调整发送速率
> - 如何感知拥塞程度
> - 采用何种调整算法

> [!tip] 如何调整发送速率

发送方跟踪一个额外的变量 **拥塞窗口**，记为 `cwnd`，从而限制速率：$$\rm LastByteSend - LastByteAcked \leqslant min \{cwnd, rwnd\}$$

> [!tip] 如何感知拥塞程度

定义 *“丢包事件”* 为二者之一：

- *超时*
- 收到 3 个 *冗余 ACK*

TCP 发送方调整发送速率的原则：

- 发生 *“丢包事件”* -> 拥塞 -> 降速。
- 收到 *ACK 报文段* -> 畅通 -> 提速。

> [!tip] 采用何种调整算法

**TCP 拥塞控制算法** 是一个 FSM：

![[Snipaste_240423_194612.png|600]]

#### 慢启动

#### 拥塞避免

#### 快速恢复

#### TCP 拥塞控制：回顾

#### 对 TCP 吞吐量的宏观描述

#### 经高带宽路径的 TCP

#### 公平性和 UDP

👉 [[4 网络层]]