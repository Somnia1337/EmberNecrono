👈 [[1 浏览器生成消息]]

> ——探索协议栈和网卡

关键词：

> TCP/IP，套接字，协议栈，IP 地址，端口号，包，头部，网卡，网卡驱动，MAC 地址，以太网控制器，ICMP，UDP

看点：

![[Snipaste_231231_152027.png|600]]

> 创建套接字
> 
> 连接服务器
> 
> 收发数据
> 
> 从服务器断开连接并删除套接字
> 
> IP 与以太网的包收发操作
> 
> 用 UDP 协议收发数据的操作

结构：

> - 创建套接字
> 	- 协议栈的内部结构
> 	- 套接字的实体就是通信控制信息
> 	- 调用 `socket` 时的操作
> - 连接服务器
> 	- 连接是什么意思
> 	- 负责保存控制信息的头部
> 	- 连接操作的实际过程
> - 收发数据
> 	- 将 HTTP 请求消息交给协议栈
> 	- 对较大的数据进行拆分
> 	- 使用 ACK 号确认网络包已收到
> 	- 根据网络包平均往返时间调整 ACK 号等待时间
> 	- 使用窗口有效管理 ACK 号
> 	- ACK 与窗口的合并
> 	- 接收 HTTP 响应消息
> - 从服务器断开并删除套接字
> 	- 数据发送完毕后断开连接
> 	- 删除套接字
> 	- 数据收发操作小结
> - IP 与以太网的包收发操作
> 	- 包的基本知识
> 	- 包收发操作概览
> 	- 生成包含接收方 IP 地址的 IP 头部
> 	- 生成以太网用的 MAC 头部
> 	- 通过 ARP 查询目标路由器的 MAC 地址
> 	- 以太网的基本知识
> 	- 将 IP 包转换成电或光信号发送出去
> 	- 给网络包再加 3 个控制数据
> 	- 向集线器发送网络包
> 	- 接收返回包
> 	- 将服务器的响应包从 IP 传递给 TCP
> - UDP 协议的收发操作
> 	- 不需要重发的数据用 UDP 发送更高效
> 	- 控制用的短数据
> 	- 音频和视频数据

### 创建套接字

#### 协议栈的内部结构

![[Snipaste_240101_105417.png|500]]

浏览器、邮件等一般的应用程序使用 TCP，DNS 查询等收发较短的控制数据则使用 UDP。

#### 套接字的实体就是通信控制信息

协议栈内部有一块用于存放控制信息的内存空间，记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等。

套接字只是一个概念，如果一定要赋予它一个实体，可以说这些控制信息和存储它们的内存空间就是套接字的实体。

协议栈是根据套接字中记录的控制信息来工作的。

在 Windows cmd 中使用 `netstat` 以查看套接字：

![[Snipaste_240101_110148.png]]

#### 调用 `socket` 时的操作

调用 `socket` 创建套接字：

1. 分配一个套接字所需的内存空间。
2. 向其中写入初始状态。
3. 将表示这个套接字的描述符告知应用程序，后者在向协议栈进行收发数据委托时提供描述符。

![[Snipaste_240101_110608.png|500]]

### 连接服务器

#### 连接是什么意思

连接就是通信双方交换控制信息、做数据交换之前的一系列准备工作，例如：

- 将服务器的 IP 和端口号等信息告知协议栈。
- 客户端向服务器传达开始通信的请求。
- 分配临时存放收发数据的内存空间，称为“缓冲区”。

> “连接”(connect)一词是将电话通信的术语套用到计算机网络中的结果，其实就其本质而言，叫“准备”更恰当。

#### 负责保存控制信息的头部

通信操作中使用的控制信息分为两类：

- 头部中记录的信息。
- 套接字(协议栈中的内存空间)中记录的信息。

1. 头部信息

客户端与服务器连接时交换的控制信息，在整个通信过程中都需要，被添加在网络包的开头，根据通信协议又分为 TCP 头部、以太网(MAC)头部、IP 头部。

![[Snipaste_240101_151955.png|500]]

2. 套接字信息

保存在套接字中，控制协议栈的操作。

#### 连接操作的实际过程

调用 `connect` 的格式如下：

```text
connect(<描述符>, <服务器的IP和端口号>, ...)
```

这些信息将传递给协议栈中的 TCP 模块，后者与服务器的 TCP 模块交换控制信息，过程：

1. 客户端创建一个包含表示开始数据收发操作的控制信息的头部。
2. 将头部中的控制位的 SYN 比特置 `1`，表示连接。
3. TCP 模块将信息传递给 IP 模块，委托后者发送。
4. 网络包到达服务器，IP 模块将收到的数据传递给 TCP 模块，后者根据端口号找到目标套接字，写入相应信息并将状态改为“正在连接”。

返回响应的过程大致相同，还需额外将 ACK 比特置 `1`，表示已经接收到网络包。客户端接收响应后，也需将 ACK 比特置 `1`，表示已经接收到响应包。

连接之后，套接字已经处于随时可以收发数据的状态了，在调用 `close` 断开之前，这个连接一直存在。到这里，协议栈的连接操作已经结束，控制流程交回到应用程序。

### 收发数据

#### 将 HTTP 请求消息交给协议栈

控制流程从 `connect` 回到应用程序，进入数据收发阶段。应用程序调用 `write` 将要发送的数据交给协议栈，协议栈收到数据后执行发送操作，但不是收到后立刻发送，而是存放在缓冲区，等待积累到一定量后一并发送。

如果积累量太小，可能因发送大量小包导致网络效率低下；反之，可能因等待时间太长导致发送延迟。

判断积累量的参数之一是 **最大传输单元** | Maximum Transmission Unit | **MTU**，指一个网络包的最大长度。**最大分段大小** | Maximum Segment Size | **MSS** 是从 MTU 中减去头部长度得到的一个网络包中的最大数据长度。应尽量等到积累量接近 MSS 时再发送。

当数据频率较低时，如果每次都等待积累到接近 MSS 再发送，延迟太高，因此协议栈内部有一个计时器，每当经过一段时间后，即使没有到 MSS 也要发送。

![[Snipaste_240103_151221.png|500]]

#### 对较大的数据进行拆分

一般的 HTTP 请求消息都能装在一个网络包中，如果超出，就以 MSS 进行拆分，每段前面加上 TCP 头部进行发送。

#### 使用 ACK 号确认网络包已收到

TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部中，即“序号”字段。

接收方得到每个包的序号，并计算数据长度，就可以验证数据是否存在丢失。将目前接收到的数据长度总和写在 TCP 头部的 ACK 号中发回给发送方。

通过“序号”和“ACK 号”可以确认接收方是否收到了网络包。

![[Snipaste_240103_151712.png|500]]

![[Snipaste_240103_152046.png|500]]

![[Snipaste_240103_152114.png|500]]

ACK 号的错误发现与纠正机制是整个传输过程中唯一的补救机制，其他任何地方只需在发现错误数据时丢弃，因为最终一定会重传错误的部分。

#### 根据网络包平均往返时间调整 ACK 号等待时间

超时时间：等待 ACK 号返回的时间。

网络拥堵时，ACK 号的返回变慢，需要延长超时时间，否则可能在重传包之后才收到上次的 ACK 号，加重网络拥堵。

网络畅通时，则需要缩短超时时间以降低延迟。

TCP 在发送数据的过程中持续测量 ACK 号的返回时间，动态调整超时时间。

#### 使用窗口有效管理 ACK 号

用滑动窗口的方式利用等待 ACK 号的空闲时间。

![[Snipaste_240103_152730.png|500]]

潜在的问题是，如果接收方的处理速率较低，可能导致接收缓冲区溢出，造成包的丢失。解决方案是接收方实时更新自己当前能够接纳的数据量，称为 **窗口大小**，是 TCP 调优参数之一。

![[Snipaste_240103_153016.png|500]]

#### ACK 与窗口的合并

接收方在发送 ACK 号和窗口更新时，会等待一定时间，将 ACK 号和窗口更新、多个 ACK 号进行合并（根据 ACK 工作原理，多个 ACK 号合并为最后一个），以减少包的数量。

#### 接收 HTTP 响应消息

这是整个旅途的最末一步，过程：

1. 协议栈检查收到的数据块和 ACK 号，判断数据完整性，返回 ACK 号。
2. 数据暂存到接收缓冲区，按顺序连接，还原出原始数据，交给应用程序。

### 从服务器断开并删除套接字

#### 数据发送完毕后断开连接

![[Snipaste_240104_153258.png|500]]

#### 删除套接字

套接字在通信结束后一段时间才删除，这是为了防止误操作，比如 ACK 号丢失时重发一次 FIN，如果此时套接字已经删除了，意味着端口号可能已经重新分配给其他应用，新收到的 FIN 将导致该应用的连接直接断开。

#### 数据收发操作小结

![[Snipaste_240104_153952.png|500]]

### IP 与以太网的包收发操作

#### 包的基本知识

TCP/IP 包有 2 个头部：MAC 头部记录以太网控制信息，IP 头部记录 IP 控制信息。

![[Snipaste_240106_155010.png|500]]

![[Snipaste_240106_155038.png|500]]

![[Snipaste_240106_155239.png|500]]

#### 包收发操作概览

IP 模块负责添加 2 个头部：

- MAC 头部：以太网用的头部，包含 MAC 地址。
- IP 头部：IP 用的头部，包含 IP 地址。

无论要收发的包是控制包还是数据包，IP 对各种类型的包的收发操作都是相同的。

#### 生成包含接收方 IP 地址的 IP 头部

IP 头部：

![[Snipaste_240213_085225.png]]

其中，“接收方 IP 地址”填写通信对象的 IP 地址，发送方 IP 地址则需判断发送所使用的网卡（如果有多块网卡，每块的 IP 都不同），并填写该网卡的 IP 地址。

路由器使用路由表判断具体使用的网卡，用 `route print` 显示路由表：

![[Snipaste_240213_085051.png]]

#### 生成以太网用的 MAC 头部

以太网在判断网络包目的地时和 TCP/IP 的方式不同，类似于 IP 头部，以太网用 MAC 头部确定目的地。

![[Snipaste_240213_085832.png]]

#### 通过 ARP 查询目标路由器的 MAC 地址

IP 模块根据路由表 Gateway 栏的内容判断应该把包发送给谁。

在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP 就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。”然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 ××××。”

![[Snipaste_240213_090044.png]]

为避免每次都进行广播造成包的冗余，ARP 对查询历史进行缓存，用 `arp -a` 显示缓存的所有内容：

![[Snipaste_240213_090350.png]]

![[Snipaste_240213_090453.png]]

#### 以太网的基本知识

以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，其原型如下图所示：

![[Snipaste_240213_090610.png]]

在上图中的 (a) 和 (b) 中，当一台计算机发送信号时，信号会通过网线流过整个网络，最终到达所有的设备，每个设备检查自己是否为接收者，如果不是就丢掉包。

(c) 的结构类似于 (b)，但信号只会流到根据 MAC 地址指定的设备，而不会到达其他设备了。

以太网的 3 条基本性质：

- 将包发送到 MAC 头部的接收方 MAC 地址代表的目的地。
- 用发送方 MAC 地址识别发送方。
- 用以太类型识别包的内容。

#### 将 IP 包转换成电或光信号发送出去

网卡构成概念图：

![[Snipaste_240213_091048.png]]

网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的。这个 MAC 地址会由网卡驱动程序读取并分配给 MAC 模块。

#### 给网络包再加 3 个控制数据

![[Snipaste_240213_091321.png]]

#### 向集线器发送网络包

发送信号的操作分为两种，一种是使用集线器的半双工模式，另一种是使用交换机的全双工模式。

在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信号。如果有，则需要等待该信号传输完毕，然后才可以发送信号。

在全双工模式中，发送和接收可以同时进行，不会发生碰撞。

#### 接收返回包

#### 将服务器的响应包从 IP 传递给 TCP

### UDP 协议的收发操作

#### 不需要重发的数据用 UDP 发送更高效

大多数的应用程序使用 TCP 协议收发数据，也有一些（如向 DNS 服务器查询 IP 地址时）使用 UDP 协议。

TCP 协议保证了数据的可靠性，代价就是低效（确认及重传）。

#### 控制用的短数据

像 DNS 查询等交换控制信息的操作基本都可以在一个包的大小范围内解决，这种场景中就可以用 UDP。只要在从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 进行发送即可。

![[Snipaste_240213_092246.png]]

#### 音频和视频数据

一旦错过播放时机，重发数据也是没有用的，因为声音和图像已经卡顿了，这是无法挽回的。在这些无需重发数据，或者是重发了也没什么意义的情况下，使用 UDP 发送数据更高效。

👉 [[3 从网线到网络设备]]