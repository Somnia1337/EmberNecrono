- 简答论述题：6 题，60 分
- 分析设计题：4 题，40 分

### 2 软件工程

- **软件工程**
	- 定义：运用系统的、规范的、可量化的方法开发、运行和维护软件，即将工程化的方法运用到软件开发中。
	- 目标：经济地开发出高质量的软件并有效地维护它。
	- 分层（上 -> 下）：工具，方法，过程，质量
- **过程框架**
	- 通用的 5 个过程活动：沟通，策划，建模，构建，部署
- 软件开发神话
- 普适性活动
	- 软件项目跟踪和控制；风险管理；软件质量保证；技术评审；测量；软件配置管理(SCM)；可重用性管理；产品准备和生产

### 3 软件过程结构

- 规范模型
	- 过程模型的功能
	- 理解过程模型的意义和特征
	- 过程模型、模式、框架
- **瀑布模型**
	- V 周期模型
	- 适合需求清楚、稳定的系统
- **增量模型**
	- 适合需求渐进、周期比较短的项目
	- 基于面向对象
	- 为什么使用增量模型？
- 演化模型
	- **原型模型**
		- 对瀑布模型的改进，适合需求不清楚的系统
		- 过程模式
	- **螺旋模型**
- 专门的过程模型
	- 基于构件的开发（需要面向对象技术支持）
	- 面向对象的过程模型
- **统一过程模型的 5 个阶段**
	- 起始(Inception)，细化(Elaboration)，构建(Construction)，转换(Transition)，生产(Production)

### 4 理解需求

- 设计和构建的桥梁
	- **需求工程**：致力于不断理解需求的大量任务和技术，是一个软件工程动作，开始于沟通并持续到建模。
- **需求工程的 7 个职能**
	- 起始(Inception)，导出(Elicitation)，精化(Elaboration)，协商(Negotiation)，规格说明(Specification)，确认(Validation)，需求管理(Requirements management)
- 初始化需求工程过程
- 获取需求
	- 开发系统原型
	- 开发用例

### 5 需求建模

- 需求分析
	- 分析建模：将需求转换为系统设计的过程，通过创建抽象模型来描述系统的各个方面。
	- 分析建模的 3 个目标
		- 信息/数据：识别和描述系统需要处理的信息和数据结构。
		- 功能：定义系统应具备的功能和操作。
		- 行为：描述系统在不同情境下的反应和行为模式。
	- 规格说明和需求：规格说明详细描述系统的功能和性能要求，是开发和测试的基础。需求包括用户需求、系统需求和业务需求。
	- 客户和最终用户：客户是委托开发系统的一方，最终用户是使用系统的一方。需求分析需要充分了解和考虑这两类人的需求和期望。
- 分析建模方法
	- 建模原则：建模应遵循简洁、明确、一致和可追溯的原则，以确保模型的清晰性和可维护性。
- 数据建模概念
	- **E-R 图**：实体-关系图，用于表示数据对象及其相互关系。
	- 对象关系：描述对象之间的关联和互动方式。
- 场景驱动建模：通过描述系统在不同使用场景下的行为，帮助理解和验证系统需求。
- **UML**
	- 用例图：描述系统功能和用户交互。
	- 活动图：表示系统活动流程和顺序。
	- 序列图：显示对象之间的交互顺序和时间顺序。
	- 状态图：描述对象的状态变化和转换。
	- 类图：表示系统的类及其属性和方法。
- 面向对象分析
	- 行为：分析系统在不同情境下的行为。
	- 类：识别和定义系统中的类及其关系。
	- 用例：描述用户与系统的交互场景。
- 创建行为模型：行为模型描述系统在不同状态下的反应和行为，通常使用状态图和活动图来表示。
- 基于类的建模
	- 识别分析类：确定系统中的类和对象，并定义它们的属性和方法。
	- CRC（类-职责-协作）建模：通过定义类的职责和协作关系，帮助理解和设计系统的类结构。

### 6 设计概念

- 软件工程设计背景下的设计
	- 将分析模型映射到设计模型：分析模型描述系统的需求和功能，而设计模型则进一步细化这些描述，包含系统的结构、组件、接口和详细实现。
- 设计概念
	- 抽象：抽象是设计的核心概念，通过隐藏复杂的实现细节，只关注系统的高级特性和行为。
	- 细化：细化是逐步细化系统设计的过程，从高层次的抽象逐步过渡到详细的实现细节。
	- 架构：架构定义了系统的总体结构和主要组件，以及组件之间的交互方式。
	- 模式：设计模式是经过验证的解决方案，可以复用于常见的设计问题，提升设计的复用性和灵活性。
	- 模块化：模块化是将系统划分为多个相对独立的模块，每个模块完成特定的功能，减少模块之间的依赖。
	- 信息隐藏：信息隐藏是模块化的原则之一，通过隐藏模块的实现细节，只暴露必要的接口，增强系统的可维护性和安全性。
	- 功能独立性：功能独立性通过高内聚和低耦合实现，每个模块完成独立的功能，并且模块之间的依赖最小。
	- 重构：重构是改善代码结构和设计的过程，提高代码的可读性、可维护性和性能，而不改变其外部行为。
	- 设计类：设计类是面向对象设计中的核心元素，定义了对象的属性和行为，并描述了对象之间的关系。
- 设计模型
	- 设计过程：一个迭代的过程，逐步细化和优化设计模型，确保系统满足需求和性能要求。
- **设计的 4 个要素**
	- 数据设计：定义数据的结构和存储方式，确保数据的完整性和访问效率。
	- 架构设计：定义系统的高层结构和主要组件，确保系统的可扩展性和灵活性。
	- 接口设计：定义组件之间的交互方式和接口，确保组件可以协同工作。
	- 组件级设计：定义每个组件的内部结构和实现细节，确保组件的功能和性能。
- **良好设计的 4 个特征**
	- 完整性和充分性（原始性）：设计应完整地覆盖系统的所有需求，并提供足够的细节以指导实现。
	- **高内聚**：每个模块应只完成单一功能，模块内部的元素紧密相关。
	- **低耦合**：模块之间的依赖应尽量减少，使得模块可以独立开发、测试和维护。
- 分析模型和设计模型
	- 关系：分析模型是设计模型的基础，设计模型是对分析模型的细化和实现。
	- 过程维度：设计是从分析模型到设计模型的渐进过程，通过不断细化和优化，形成详细的系统设计。
	- 抽象维度：设计模型在不同的抽象层次上表示系统，从高层的架构设计到详细的组件级设计，逐步过渡到具体实现。

### 7 架构设计

- 软件架构：系统的高层设计，包括系统的主要组件、它们之间的关系以及设计和演化的指导原则。
- **架构设计中的数据设计目标**
	- 确保数据的完整性和一致性。
	- 优化数据存储和访问性能。
	- 支持数据的复用和扩展。
	- 提供数据安全性和隐私保护。
- 架构风格和模式
	- 组件：系统的基本构建块，负责特定的功能或数据处理。
	- 连接器：定义组件之间的交互机制，如方法调用、数据流等。
	- 约束：限制组件和连接器的行为，确保系统的一致性和正确性。
	- 语义模型：定义系统的行为和交互方式，为架构提供语义解释。
- **常见的架构风格**
	- 数据中心：以数据存储和管理为核心，数据是系统的关键资源。例如，数据库系统。
	- 数据流：系统的主要功能通过数据流动实现，包括流水线和过滤器架构。
	- 调用与返回：经典的分层架构，模块通过调用和返回实现交互。例如，面向过程编程。
	- 面向对象：基于对象和类的设计，每个对象封装数据和行为。
	- 分层架构：系统被划分为若干层，每层提供特定的服务，并且只能调用下一层的服务。
- **架构的 3 种依赖关系**
	- 共享依赖：多个组件依赖于同一个共享资源或服务。
	- 直接依赖：一个组件直接依赖于另一个组件。
	- 间接依赖：一个组件通过第三方依赖于另一个组件。

### 8 组件级设计

- 组件：软件系统的基本构建块，可以被独立开发和复用。组件通常封装了一组相关的功能，并通过接口与其他组件进行交互。
	- 传统视图：在传统视图中，组件通常被视为一组功能相关的程序单元或模块。
	- 面向对象视图：在面向对象的视图中，组件通常被视为类或对象，包含数据和操作这些数据的方法。
- 基于设计类的组件：按照一定的设计原则和标准创建的组件，以提高系统的可维护性、可扩展性和复用性。
	- **设计的 4 个基本原则**
		- 开闭原则：软件实体（类、模块、函数等）应该 *对扩展开放，对修改关闭*。这意味着可以通过扩展系统的行为来实现新的功能，而不需要修改现有的代码。
		- Liskov 替换原则：*子类对象应该能够替换其基类对象*，并且程序的行为不会改变。即子类应确保不破坏父类的功能。
		- 依赖倒置原则：*高层模块不应该依赖于低层模块，二者都应该依赖于抽象*。抽象不应该依赖于细节，细节应该依赖于抽象。这一原则鼓励使用接口或抽象类来降低系统的耦合度。
		- 接口分离原则：*不应该强迫客户依赖他们不使用的接口*。即应将大的、笨重的接口拆分为更小、更具体的接口，让客户只需了解和使用与其相关的接口。
	- **内聚和耦合**：测量模块独立性的两个定性标准
		- 内聚：内聚是指模块内部各成分彼此结合的紧密程度。高内聚意味着模块内部的功能紧密相关，更易于理解和维护。
		- 耦合：耦合是指模块之间相互依赖的程度。低耦合意味着模块之间的依赖性小，模块可以更容易地被复用和独立更换。
	- 分析类和设计类
		- 分析类：在需求分析阶段定义的类，主要描述系统需要实现的业务逻辑和功能。
		- 设计类：在系统设计阶段定义的类，主要描述系统内部的实现细节和架构。
- 进行组件级设计：为每个组件详细设计其内部结构和功能。
	- 面向对象组件级设计步骤
		1. 识别和描述组件：确定系统需要的组件及其功能。
		2. 定义组件接口：设计组件的接口，包括其方法和属性。
		3. 组件实现：根据设计实现组件，包括编写代码和测试。
- 设计传统组件
	- **流程图**：一种图形工具，用于描述算法或过程的流程。它使用各种符号表示不同的操作和控制结构，通过箭头表示执行顺序。

### 9 用户界面设计

- **黄金法则**
	- 保持一致性
	- 减少用户记忆负担
	- 让用户处于控制地位
- 用户界面分析和设计
	- 用户分析：了解目标用户群体的特征、需求和行为模式。
	- 任务分析：分析用户需要完成的任务及其操作步骤，确定系统应支持的功能。
	- 界面分析：分析现有界面和交互模式，找出优缺点。
	- 界面设计：基于前面的分析，设计用户界面，包括布局、导航、交互方式等。
	- 界面验证：通过用户测试和评估，验证设计是否满足用户需求和使用习惯。
- **界面分析步骤**
	1. 收集需求：了解用户的需求和期望，确定界面功能和性能要求。
	2. 现有界面评估：分析当前系统或类似系统的界面，找出优点和不足。
	3. 用户角色和任务分析：确定不同用户角色及其需要完成的任务。
	4. 使用环境分析：考虑界面在不同使用环境下的表现，如不同设备和操作系统。
- **界面设计步骤**
	1. 定义界面结构：确定界面的整体结构和布局，如导航栏、内容区域等。
	2. 设计交互方式：设计用户与系统交互的方式，如按钮、表单、菜单等。
	3. 创建线框图和原型：制作界面的线框图和原型，用于展示和评估设计思路。
	4. 用户测试和反馈：通过用户测试收集反馈，改进设计。
	5. 详细设计和实现：进行详细的界面设计，并交由开发团队实现。

### 10 测试策略和技术

- **软件测试的战略方法**
	- 验证：检查软件是否按规定的要求进行开发，确保软件正确地实现了设计。
	- 确认：检查软件是否满足用户需求，确保软件能够完成其预期的功能。
- **传统软件的测试策略**
	- 单元测试：主要测试软件的最小功能单元（如函数或方法），确保其独立功能的正确性。
	- 集成测试：测试多个单元模块组合后的整体功能、模块之间的接口和交互。
	- 回归测试：在软件修改后进行的测试，确保新修改没有引入新的错误。
	- 冒烟测试：初步测试，验证软件基本功能是否正常。
	- 验收测试（确认测试）：验证软件是否符合业务需求和用户需求，是交付前的重要测试阶段。
	- 系统测试：测试整个系统的集成情况，确保所有部分协调工作。
		- 用例图
		- 函数测试，规格说明
- **测试与调试的关系**：测试发现错误，调试解决错误。
- **白盒测试**：基于软件内部结构的测试方法。
	- 流图标记法：使用流图表示程序逻辑，检查代码路径。
	- 圈复杂度与独立路径：圈复杂度衡量程序复杂度，独立路径测试确保所有路径都被测试。
- **黑盒测试**：基于软件功能的测试方法，不考虑内部实现。
	- 等价类划分：将输入数据划分为等价类，每个类代表一组相似的输入。
	- 边界值分析：测试输入数据的边界值，确保系统在边界条件下的表现。
- **基路径测试**：一种白盒测试方法，通过分析程序的控制流图来设计测试用例，确保所有独立路径都被覆盖。
- **控制结构测试**（条件/循环）：关注程序的条件和循环结构，确保不同条件和循环的执行情况都得到测试。
- 面向对象的测试方法：针对面向对象编程中的类和对象，测试对象的状态和行为，以及对象之间的交互。