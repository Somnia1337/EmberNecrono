### 没考过的（**定时炸弹**）

#### 软件项目跟踪和控制

项目管理的重要组成部分，旨在 **监控项目进度、资源使用和风险，并根据需要采取纠正措施，以确保项目按计划完成**，包括进度跟踪、成本监控、质量控制和变更管理等活动；*帮助项目经理及时发现问题并进行调整*。

#### 风险管理

**识别、分析、评估和应对项目风险的过程**，目标是 **最大限度地减少潜在风险对项目的负面影响**，包括风险识别、风险评估、风险缓解和监控风险等步骤；*提高项目的成功率和稳定性*。

#### 软件质量保证

一套系统的活动，用于 **确保软件产品符合规定的质量标准和需求**，包括制定质量标准、执行审查和测试、过程改进和质量评估等；*保证软件的可靠性、可维护性和用户满意度*。

#### 技术评审

**对软件产品或过程进行正式检查和评估的活动**，旨在 **发现和纠正缺陷，提高产品质量**，包括代码审查、设计评审和需求评审，通过集体审查和讨论；*确保各个开发阶段的产出物符合质量标准和需求*。

#### 测量

**在软件工程中使用定量方法评估和分析软件过程、产品和资源的活动**，常见的测量指标包括代码行数、缺陷密度、开发时间和成本等；*改进软件开发过程、评估项目进度和性能，以及做出数据驱动的决策*。

#### 软件配置管理 (SCM)

**控制和管理软件产品在整个生命周期内的变更的过程**，包括版本控制、变更管理、配置状态报告和配置审计等活动；*确保所有开发人员在统一的环境中工作，并使软件产品的所有变更都能被有效追踪和管理*。

#### 可重用性管理

识别、开发和维护软件组件或代码段，以便在不同项目中重复使用的过程，包括组件库管理、重用策略制定和重用性评估等；*减少开发时间和成本，提高软件的一致性和质量*。

#### 产品准备和生产

软件开发的最后阶段，涉及 **将开发完成的软件产品转化为可供用户使用的实际产品**，包括产品打包、文档编写、安装程序创建、培训和支持准备等；*确保产品能够顺利交付并在用户环境中正常运行*。

### 实体

#### software 软件

**程序、数据和相关文档的集合**；*执行特定任务或实现特定功能*。

#### component 组件

**软件系统中封装了特定数据和功能的独立单元**，可被独立开发、测试和复用，组件之间通过接口交互；*提高软件系统的模块化程度和可维护性*。

#### class 类

**面向对象编程中定义一组对象的属性和行为的实体**，包括数据（属性）和函数（方法）；*提供了对象结构和行为的模板*。

#### UML 统一建模语言

**一种设计和描述软件系统结构和行为的标准化建模语言**，有用例图、活动图、状态图等；*帮助开发人员和利益相关者有效地沟通和协作*。

### 方法

#### the waterfall model 瀑布模型

一种传统的软件开发生命周期模型，**将软件开发过程分为 5 个顺序的阶段**（沟通 -> 策划 -> 建模 -> 构建 -> 部署），每个阶段完成后才能进入下一个阶段。

#### the prototyping model 原型模型

一种软件开发模型，**通过快速开发一个初步的原型系统，展示系统的界面和功能**，并与用户进行交互，以收集反馈和需求修改；*适用于用户需求不明确的情况，帮助开发团队和客户在早期阶段更好地理解需求，减少误解*。

#### equivalence partitioning 等价类划分

一种黑盒测试技术，用于 **将输入数据划分为若干个等价类**，每个等价类中的数据在逻辑上等效，只需选择每个等价类中的一个代表值进行测试，就能覆盖所有可能的输入情况；*减少测试用例的数量，提高测试效率*。

#### unit testing 单元测试

**对软件中的最小可测试单元（通常为函数）进行测试**，由开发人员在编码阶段进行，以验证各个单元功能正常；*提高测试的覆盖率和代码的可靠性*。

#### top-down integration testing 自顶向下集成测试

一种增量式集成测试方法，**从系统的顶层模块逐步向下测试和集成各个子模块**，用桩模拟还未集成的子模块，逐步替换桩，直到所有模块都被测试并集成；*尽早发现顶层设计和接口的问题*。

#### regression testing 回归测试

一种软件测试方法，用于 **验证在软件修改后，新的代码更改未引入新的错误或破坏原有功能**，在软件系统的维护和更新过程中进行，通过重新执行先前的测试用例，检查软件的功能是否正常；*确保系统的稳定性和一致性*。

#### refactoring 重构

**在不改变软件外部行为的前提下，对代码进行调整和优化**；*改善代码的结构、提高代码的可读性和系统的可维护性、可扩展性*。

#### pair programming 结对编程

一种敏捷软件开发实践，**两名程序员在同一个工作站上编写代码，导航员负责审查和思考代码，驾驶员负责输入代码**，两人轮流交换角色；*提高代码质量，减少错误，促进团队协作*。

### 抽象

#### software engineering 软件工程

**以系统化、规范化和可量化的方式开发、运行和维护软件**；*通过应用工程原理和方法，提高软件的质量、可靠性和可维护性*。

#### software process 软件过程

**开发和维护软件所遵循的一系列活动和任务的集合**，包括需求获取、设计、编码、测试、部署和维护等阶段；*系统化和有序地管理软件开发生命周期中的各个方面*。

#### requirements engineering 需求工程

软件工程的一个子领域，涉及 **系统需求的识别、记录、分析、验证和管理的过程**，包括需求获取、需求分析、需求规格说明和需求验证等活动；*确保软件系统的需求明确、完整、正确并且可验证*。

#### software architecture 软件架构

**对软件系统高层结构的描述，包括系统的主要组件、组件之间的关系以及这些组件的设计和演化的指导原则，定义了系统的组织方式**；*实现系统质量属性（如可扩展性、性能和安全性）的基础*。

#### software testing 软件测试

**评估软件系统或组件是否满足规定要求并识别缺陷的过程**，包括多种方法和技术，如单元测试、集成测试、系统测试和验收测试，涵盖黑盒测试和白盒测试等；*发现错误和缺陷，提高软件质量，验证系统的功能和性能*。

#### design pattern 设计模式

面向对象软件设计中的一种解决特定问题的通用解决方案，是 **一组被反复使用、经过分类和记录的代码设计经验**，分为创建型模式、结构型模式和行为型模式三大类；*帮助开发人员在软件设计中创建高效、灵活和可维护的代码结构*。

#### cohesion 内聚

**衡量模块或组件内部元素彼此之间联系紧密程度的指标**，高内聚表示模块内部的功能和数据高度相关并集中在一起，低内聚则表示模块内部的功能和数据松散且分散；*高内聚有助于提高系统的可维护性、可重用性和可靠性*。

#### functional independence 功能独立性

软件设计中的一个重要原则，指 **系统中的各个模块应当独立完成其特定功能，尽量减少与其他模块的依赖关系**，通过高内聚和低耦合来实现，即每个模块只完成单一功能（高内聚），并且与其他模块的交互最少（低耦合）；*提高系统的可维护性和可扩展性*。

#### separation of concerns 关注点分离

一种设计原则，**将复杂系统的不同功能或行为分离到独立的模块或组件中**，以减少模块之间的依赖性和复杂性；*提高系统的可理解性、可维护性和灵活性*。

#### information hiding 信息隐藏

一种设计原则，**将模块或类的实现细节对外部隐藏，只暴露必要的接口**；*减少模块间的耦合，使得模块可以独立开发、测试和维护，增强系统的可维护性和可扩展性*。

#### usability 可用性

软件产品的一个重要质量属性，指 **用户在特定环境下使用产品时的有效性、效率和满意度**，包括易学性、操作便捷性、用户错误处理能力和用户满意度；*确保软件易于使用、学习和掌握*。