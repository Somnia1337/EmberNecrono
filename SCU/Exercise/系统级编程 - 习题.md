### Week 01

Compared to a sequence of machine code instructions, a fragment of C code **may describe the same algorithm**.

---

Which of the following is able to describe a computation at the highest level of abstraction? **C++ code**

---

When using a debugger to find the cause of a program's incorrect behavior, **it is often necessary to start the program multiple times under the debugger**.

---

In visual C++, a win32 console application is **the simplest type of application visual C+ + can generate**.

---

Consider the following fragment of C++ source code.

```cpp
string msg;
unsigned int x;
int y;
cin >> msg >> x >> y;
cout << x + y;
```

Which of the following is (are) true regarding execution of the segment?

- The input statement will always take the same amount of time to execute.
- The output statement will always be executed immediately after the input statement.
- If `x` and `y` are both positive, an integer greater than both will be printed.

**none**

---

Which of the following visual C++ objects are contained within a "project"?

- Files
- Visual C++ solutions
- Flow charts

**i only**

---

Which of the following does a debugger do?

- Analyze the source code to find programming errors.
- Decode machine code generated by a compiler.
- Stop execution of a program.

**ii and iii only**

---

Integrated programming environments make it difficult to mix and match tools from different sources. This is **bad, because no single vendor is likely to be the source of all the best tools**.

---

The correct sequence of GCC compilation process is **preprocessing -> compilation -> assemble -> linking**.

---

The preprocessor removes the ==**comments**== from the source code.

### Week 02

In C, using default floating point settings, what happens when a floating-point computation results in an overflow? **A special value "infinity" is computed, testable with `_finite()`**.

---

Which of the following numerical operations is most likely to lead to loss of precision? **floating-point addition** (NOT multiplication)

---

Which of the following statements about floating-point numbers in C is true?

- Floating-point numbers are often only approximations of real numbers.
- A 32-bit float only approximates decimal fractions, but a 64-bit double represents them exactly.
- Floating-point numbers can represent any rational real number but not irrationals.

**i only**

---

What is the purpose of the exponent in floating point numbers? **To indicate where the decimal or binary point should be**.

---

What happens in a C program when an addition would cause integer overflow? **An incorrect result is produced and execution continues.**

---

In a computer with 4-byte words, which of the following C expressions tests whether `ptr` contains the address of a word?

- `(ptr & 3) == 0`
- `(ptr | 3) == 0`
- `(ptr % 4) == 0`

**i and iii only**

---

How is `-10` (decimal) represented in an 8-bit 2's complement binary format? **`11110110`**

---

How is `46` (decimal) represented in an 8-bit 2's complement binary format? **`101110`**

---

What is the value of the C expression `0x1234 & 0x5432`? **`0x1030`**

---

What is the value of the C expression `0x1234 ^ 0x5432`? **`0x4606`**

---

In C, what is the binary number `11010101` in hexadecimal? **`0xD5`**

---

Which of the following could be represented by one bit of information? **The position of a light switch**.

---

What is the output of this C code?

```c
int main() {
	int c = 2 ^ 3;
	printf("%d\n", c);
}
```

**1**

---

What is the output of this C code?

```c
int main() {
	unsigned int a = 10;
	a = ~a;
	printf("%d\n", a);
}
```

**-11**

---

What is the output of this C code?

```c
int main() {
	if (7 & 8)
		printf("honesty");
	if ((~7 & 0x000f) == 8)
		printf("is the best policy");
}
```

**is the best policy**

---

What is the output of this C code?

```c
void main() {
	int x = 97;
	int y = sizeof(x++);
	printf("x is %d", x);
}
```

==**x is 97**== (`sizeof()` 在编译时执行，`x++` 只是一个传递给 `sizeof()` 的表达式，它与传递 `x` 没有区别，不会实际执行 `x + 1`)

### Week 03

Which of the following is a good reason (are good reasons) to equip the CPU with small amounts of fast memory?

- To make the design of the compiler simpler.
- To make some CPU instructions smaller
- To make some CPU instructions faster

**ii and iii only**

---

Which of the following must be true if a program is stopped at a specific line within the visual C++ debugger?

- There is at least one breakpoint enabled.
- There is a breakpoint enabled on that line.
- There is a breakpoint enabled on the line preceding that line.

**none**

---

Within visual C++, which of the following will reveal the value of a variable when the program is stopped at a breakpoint?

- Placing the mouse pointer over the variable name in the source file window.
- Inserting a printf() in the program.
- Typing the variable name on the "watch" window.

**i and iii only**

---

Programs compiled for an Intel Pentium processor do not execute properly on a Sparc processor from sun microsystems because **the operation codes understood by the two processors are different**.

---

A branch instruction **sets the program counter to one of two possible values**.

---

A jump instruction **unconditionally sets the program counter to its operand**.

---

The machine code generated from source code by a compiler **does not preserve all the information given in the source code**.

---

Which of the following are true of the effect that optimizations have on the machine code generated by compilers?

- The resulting code will be faster and/or smaller.
- The resulting code will be clearer.
- The resulting code will be harder to debug.

**i and iii only**

---

The program counter contains **the address of the CPU instruction that is about to be fetched**.

---

Immediately after the CPU executes an instruction that is neither a branch nor a jump instruction, the program counter **is incremented to point to the following instruction**.

### Week 04

The visual C++ memory window displays **the contents of memory, interpreted in one of several ways, without the associated variable names**.

---

Consider the following code fragment.

```c
int a;
int b;
int main(int argc, char *argv[]) {
	int c;
	int d;
	// some code
}
```

Which of the following must be true?

**The value of `&d` is closer to the value of `&c` than to the value of `&a`.**

---

Consider the following code.

```c
char a[100];
a[99] = *((char*) (((int) &a[0]) + 4))
```

If integers are 32 bits wide, which of the following values is equal to `a[99]`?

**`a[4]`**

---

Which of the following statements about alignment within C struct's is true?

- Alignment may cause the allocation of unused space.
- Alignment is required by all modern processors.
- Alignment can help processors access data more efficiently.

**i and iii only**

---

In C, assuming that an `int` takes 4 bytes, how many bytes are required to represent the array `int a[12]`?

**48**

---

given the declaration and initialization `char s[] = "string"`, what is the value of the expression `s[6]`?

**`'\0'`**

---

In C, assuming that an `int` takes 4 bytes, if array `a` is declared as `int a[12]` and a has the value `0x10000`, what is the value of the expression `a + 2`?

**`0x10008`**

---

Given the address of a C struct at runtime, how is the address of a member element in the struct determined?

**A constant offset associated with the member is added to the address.**

---

We want the variable `factorialfunc` to hold the address of the first instruction of the following function:

```c
int factorial(int n) {
	if (n == 1) return n;
	return n * factorial(n -1);
}
```

How would we declare the variable?

**`int (*factorialfunc)(int)`**

---

On one computer, the bytes with addresses `a`, `a+1`, `a+2` and `a+3` contain the integer `256`, and the variable declared with `int * a` has the value `a`. On a different computer, the bytes with addresses `b`, `b+1`, `b+2` and `b+3` also contain the integer `256`, and the variable declared with `int * b` has the value `b`. On a computer in which both addresses and integers are 32 bits wide, how many bytes of memory will the compiler allocate for following code fragment?

```c
int a;
int* b = &a;
```

**8**

---

What is the output for the following code:

```c
typedef struct {
	char a;
	int b;
} test_struct_t;

int main(int argc, char *argv[]) {
	test_struct_t a, b;
	a.a = 0;
	a.b = 0;
	memset(&b, '\0', sizeof(b));
	if (0 == memcpy(&a, &b, sizeof(a))) {
		printf("struct a is equal to struct b");
	}
	else {
		printf("struct a is unequal to struct b");
	}
	return 0;
}
```

**struct a is unequal to struct b**

---

For the following piece of code:

```c
typedef union {
	long i;
	int k[5];
	char c;
} date;

struct data {
	int cat;
	date cow;
	double dog;
} too;

int main(int argc, char *argv[]) {
	date max;
	printf("%d", sizeof(struct data) + sizeof(max));
	return 0;
}
```

What is the output for `printf()` statement?

**52**

### Week 05

Consider the program given below.

```c
int callee(void) {
    int count = 5;
    printf("%d ", (int)&count);
    return count;
}
int main(int argc, char *argv[]) {
    int count = 4;
    count = callee();
    printf("%d ", (int)&count);
    return 0;
}
```

**Two different integers are printed, and the value of neither can be determined from the information given.**

---

What does the following program print?

```c
int callee(int *count) {
    count++;
    return *count;
}
int main(int argc, char *argv) {
    int retval;
    int count = 4;
    retval = callee(&count);
    printf("%d", retval);
    return 0;
}
```

**Cannot be determined from the information given.**

---

What is printed as a result of execution of the following program?

```c
void callee(int *count) {
    (*count)++;
}
int main(int argc, char *argv) {
    int count = 4;
    callee(&count);
    printf("%d", count);
    return 0;
}
```

**5**

---

What does the following program print?

```c
void callee(int *count) {
    (*count)++;
}
int main(int argc, char *argv[]) {
    int count = 4;
    callee(count);
    printf("%d", count);
    return 0;
}
```

**Nothing: it will not compile successfully or popup access violation error message.**

---

Consider the following program segment.

```c
int factorial(int *arg) {
    int n = *arg;
    if (n == 1)
        return n;
    return n * factorial(n - 1);
}
```

When the segment is executed, the variable n is allocated to **many addresses none of which is known to the compiler**.

---

At which of the following times is an activation record created?

- When a program starts executing.
- Every time a function is invoked.
- When a variable is declared.

**i and ii only**

---

Consider the following program.

```c
int i;
int j = 1;
int callee(int number) {
    int plusone;
    plusone = number + 1;
    return plusone;
}
int main(int argc, char *argv[]) {
    if (j == 1)
        return callee(i);
    return j;
}
```

Which of the following are allocated in the activation record immediately after the function `callee()` is invoked?

**`plusone` and `number` only**

---

Consider the following program.

```c
int i;
int *jp = &i;
void main(int i, char *argv[]) {
    printf("%d %d\n", (int)&i, (int)jp);
}
```

Which of the following describes what it prints?

**Two very different integers.**

---

Consider the following program.

```c
int square(int *arg) {
    int n = *arg;
    return n * n;
}
int main(int argc, char *argv) {
    int arg = strtol(argv[1], null, 0);
    return square(arg);
}
```

When it is executed with the argument `5`, the variable n is allocated to **exactly one address not known to the compiler.**

---

Consider the following segment of C source code.

```c
int a = 8;
int b = *&a;
```

What is the value of variable `b` at the end of execution of the segment?

**`a`**

### Week 07

Which of the following are true about statically allocated data in C programs?

- Its location is chosen by the compiler.
- Its location may change during execution if more memory is required.
- Its location is not known directly but can be found in a static symbol table.

**I only**

---

Consider a system in which memory consists of the following hole sizes in memory order:

```text
HO  H1  H2   H3   H4  H5  H6   H7
10К 4КВ 20КВ 18KB 7КB 9КB 12КB 15КB
```

and a successive segment request of

- `12` KB
- `10` KB
- `9` KB

Which of the following sentences is true?

- *First Fit* algorithm allocates `H2`, `H0`, `H3` for the mentioned request.
- *Worst Fit* algorithm allocates `H2`, `H3`, `H7` for the mentioned request.
- *Best Fit* algorithm allocates `H6`, `H0`, `H5` for the mentioned request.

**I, II, and III**

---

Consider the `malloc()` function. Which one of the following sentences is correct?

**The `malloc()` allocates the desired amount of memory on the heap.**

---

In C, local variables allocated inside functions are allocated **on the stack**.

---

Suppose a compiler uses static storage to store all variables, function parameters, saved registers, and return addresses. Which of the following language features can this compiler support?

- Local variables.
- Function calls.
- Recursion.

**I and II only**

---

The key feature of implicit memory management is that memory is freed automatically. Which of the following features of C make(s) it difficult to add support for implicit memory management in C?

- Pointers are not always initialized.
- Type casting makes it impossible to know when a value could be a pointer.
- C programs can allocate memory at runtime.

**I and II only**

---

Which of the following features apply to standard heap allocation in C?

- The size of heap objects must be known at compile time.
- Heap memory must be explicitly allocated.
- Heap memory is deallocated when a function returns.

**II only**

---

In C, to allocate an array of 100 `long`s on the heap you should write

**`long* a = (long*) malloc(100 * sizeof(long))`**

---

What is the value of an uninitialized pointer variable declared within a function? **undefined**

---

Consider the following fragment of C code.

```c
int* p = (int*) calloc(100);
int* q = p;
free(p);
```

Immediately after executing it, which of the following are true about `p` and `q`?

- `p` and `q` are identical pointers to freed storage.
- `p` points to freed storage, and `q` points to an allocated block of size `100`.
- `p` should not be freed again, but invoking `free(q)` is all right.

**I only**

---

A memory leak is caused by a **failure to free allocated memory**.

---

In this sequence of C statements:

```c
long a[10];
ptr = a + 5;
*ptr++ = x;
```

the last line could be rewritten as **`a[5] = x; ptr = ptr + 1;`**

### Week 08

Explain the feature of stack.

**All operations are at one end.**

---

When executing a function `callee()`, which of the following are true regarding the value of the frame pointer?

- It marks the top of the stack frame of the function that invoked `callee()`. 
- It marks the bottom of the stack frame of `callee()`.
- It is the top of the stack.

**I and II only**

---

The C expression `a -> b` is equivalent to **`(*a).b`**.

---

What will be the output?

```c
void main() {
	char *p = "Hello world!";
	int *q;
	p++;
	q = (int*) p;
	q++;
	printf("%s%s\n", p, q);
}
```

**`ello world! world!`**

---

Why is it wrong to return the address of a local variable?

**The variable address is invalid after the return.**

---

In C, when a struct is freed, **no pointers within the struct are freed automatically**.

---

To resolve memory leaks in C, one common approach is **to check whether the number of calls to `malloc()` is greater than the number of calls to `free()`**.

---

In C, `calloc()` differs from `malloc()` in that `calloc()` **sets the contents of the block to zero before returning**.

---

What properties of a variable are specified by the static keyword in C?

- The variable will be statically allocated.
- The variable name will be visible only to functions defined within the same file.
- The variable's value does not change very often. The compiler uses this fact to focus optimizations on other variables.

**I and II only**

---

A static variable by default gets initialized to **`0`**.