### Week 01

> Compared to a sequence of machine code instructions, a fragment of C code **may describe the same algorithm**.

> Which of the following is able to describe a computation at the highest level of abstraction? **C++ code**

> When using a debugger to find the cause of a program's incorrect behavior, **it is often necessary to start the program multiple times under the debugger**.

> In visual C++, a win32 console application is **the simplest type of application visual C+ + can generate**.

> Consider the following fragment of C++ source code.
> 
> ```cpp
> string msg;
> unsigned int x;
> int y;
> cin >> msg >> x >> y;
> cout << x + y;
> ```
> 
> Which of the following is (are) true regarding execution of the segment?
> 
> - The input statement will always take the same amount of time to execute.
> - The output statement will always be executed immediately after the input statement.
> - If `x` and `y` are both positive, an integer greater than both will be printed.
> 
> **none**

> Which of the following visual C++ objects are contained within a "project"?
> 
> - Files
> - Visual C++ solutions
> - Flow charts
> 
> **i only**

> Which of the following does a debugger do?
> 
> - Analyze the source code to find programming errors.
> - Decode machine code generated by a compiler.
> - Stop execution of a program.
> 
> **ii and iii only**

> Integrated programming environments make it difficult to mix and match tools from different sources. This is **bad, because no single vendor is likely to be the source of all the best tools**.

> The correct sequence of GCC compilation process is **preprocessing -> compilation -> assemble -> linking**.

> The preprocessor removes the ==**comments**== from the source code.

### Week 02

> In C, using default floating point settings, what happens when a floating-point computation results in an overflow? **A special value "infinity" is computed, testable with `_finite()`**.

> Which of the following numerical operations is most likely to lead to loss of precision? **floating-point addition** (NOT multiplication)

> Which of the following statements about floating-point numbers in C is true?
> 
> - Floating-point numbers are often only approximations of real numbers.
> - A 32-bit float only approximates decimal fractions, but a 64-bit double represents them exactly.
> - Floating-point numbers can represent any rational real number but not irrationals.
> 
> **i only**

> What is the purpose of the exponent in floating point numbers? **To indicate where the decimal or binary point should be**.

> What happens in a C program when an addition would cause integer overflow? **An incorrect result is produced and execution continues.**

> In a computer with 4-byte words, which of the following C expressions tests whether `ptr` contains the address of a word?
> 
> - `(ptr & 3) == 0`
> - `(ptr | 3) == 0`
> - `(ptr % 4) == 0`
> 
> **i and iii only**

> How is `-10` (decimal) represented in an 8-bit 2's complement binary format? **`11110110`**

> How is `46` (decimal) represented in an 8-bit 2's complement binary format? **`101110`**

> What is the value of the C expression `0x1234 & 0x5432`? **`0x1030`**

> What is the value of the C expression `0x1234 ^ 0x5432`? **`0x4606`**

> In C, what is the binary number `11010101` in hexadecimal? **`0xD5`**

> Which of the following could be represented by one bit of information? **The position of a light switch**.

> What is the output of this C code?
> 
> ```c
> int main() {
> 	int c = 2 ^ 3;
> 	printf("%d\n", c);
> }
> ```
> 
> **1**

> What is the output of this C code?
> 
> ```c
> int main() {
> 	unsigned int a = 10;
> 	a = ~a;
> 	printf("%d\n", a);
> }
> ```
> 
> **-11**

> What is the output of this C code?
> 
> ```c
> int main() {
> 	if (7 & 8)
> 		printf("honesty");
> 	if ((~7 & 0x000f) == 8)
> 		printf("is the best policy");
> }
> ```
> 
> **is the best policy**

> What is the output of this C code?
> 
> ```c
> void main() {
> 	int x = 97;
> 	int y = sizeof(x++);
> 	printf("x is %d", x);
> }
> ```
> 
> ==**x is 97**== (`sizeof()` 在编译时执行，`x++` 只是一个传递给 `sizeof()` 的表达式，它与传递 `x` 没有区别，不会实际执行 `x + 1`)

### Week 03

> Which of the following is a good reason (are good reasons) to equip the CPU with small amounts of fast memory?
> 
> - To make the design of the compiler simpler.
> - To make some CPU instructions smaller
> - To make some CPU instructions faster
> 
> **ii and iii only**

> Which of the following must be true if a program is stopped at a specific line within the visual C++ debugger?
> 
> - There is at least one breakpoint enabled.
> - There is a breakpoint enabled on that line.
> - There is a breakpoint enabled on the line preceding that line.
> 
> **none**

> Within visual C++, which of the following will reveal the value of a variable when the program is stopped at a breakpoint?
> 
> - Placing the mouse pointer over the variable name in the source file window.
> - Inserting a printf() in the program.
> - Typing the variable name on the "watch" window.
> 
> **i and iii only**

> Programs compiled for an Intel Pentium processor do not execute properly on a Sparc processor from sun microsystems because **the operation codes understood by the two processors are different**.

> A branch instruction **sets the program counter to one of two possible values**.

> A jump instruction **unconditionally sets the program counter to its operand**.

> The machine code generated from source code by a compiler **does not preserve all the information given in the source code**.

> Which of the following are true of the effect that optimizations have on the machine code generated by compilers?
> 
> - The resulting code will be faster and/or smaller.
> - The resulting code will be clearer.
> - The resulting code will be harder to debug.
> 
> **i and iii only**

> The program counter contains **the address of the CPU instruction that is about to be fetched**.

> Immediately after the CPU executes an instruction that is neither a branch nor a jump instruction, the program counter **is incremented to point to the following instruction**.

### Week 04

> The visual C++ memory window displays **the contents of memory, interpreted in one of several ways, without the associated variable names**.

> Consider the following code fragment.
> 
> ```c
> int a;
> int b;
> int main(int argc, char *argv[]) {
> 	int c;
> 	int d;
> 	// some code
> }
> ```
> 
> Which of the following must be true?
> 
> **The value of `&d` is closer to the value of `&c` than to the value of `&a`.**

> Consider the following code.
> 
> ```c
> char a[100];
> a[99] = *((char*) (((int) &a[0]) + 4))
> ```
> 
> If integers are 32 bits wide, which of the following values is equal to `a[99]`?
> 
> **`a[4]`**

> Which of the following statements about alignment within C struct's is true?
> 
> - Alignment may cause the allocation of unused space.
> - Alignment is required by all modern processors.
> - Alignment can help processors access data more efficiently.
> 
> **i and iii only**

> In C, assuming that an `int` takes 4 bytes, how many bytes are required to represent the array `int a[12]`?
> 
> **48**

> given the declaration and initialization `char s[] = "string"`, what is the value of the expression `s[6]`?
> 
> **`'\0'`**

> In C, assuming that an `int` takes 4 bytes, if array `a` is declared as `int a[12]` and a has the value `0x10000`, what is the value of the expression `a + 2`?
> 
> **`0x10008`**

> Given the address of a C struct at runtime, how is the address of a member element in the struct determined?
> 
> **A constant offset associated with the member is added to the address.**

> We want the variable `factorialfunc` to hold the address of the first instruction of the following function:
> 
> ```c
> int factorial(int n) {
> 	if (n == 1) return n;
> 	return n * factorial(n -1);
> }
> ```
> 
> How would we declare the variable?
> 
> **`int (*factorialfunc)(int)`**

> On one computer, the bytes with addresses `a`, `a+1`, `a+2` and `a+3` contain the integer `256`, and the variable declared with `int * a` has the value `a`. On a different computer, the bytes with addresses `b`, `b+1`, `b+2` and `b+3` also contain the integer `256`, and the variable declared with `int * b` has the value `b`. On a computer in which both addresses and integers are 32 bits wide, how many bytes of memory will the compiler allocate for following code fragment?
> 
> ```c
> int a;
> int* b = &a;
> ```
> 
> **8**

> What is the output for the following code:
> 
> ```c
> typedef struct {
> 	char a;
> 	int b;
> } test_struct_t;
> 
> int main(int argc, char *argv[]) {
> 	test_struct_t a, b;
> 	a.a = 0;
> 	a.b = 0;
> 	memset(&b, '\0', sizeof(b));
> 	if (0 == memcpy(&a, &b, sizeof(a))) {
> 		printf("struct a is equal to struct b");
> 	}
> 	else {
> 		printf("struct a is unequal to struct b");
> 	}
> 	return 0;
> }
> ```
> 
> **struct a is unequal to struct b**

> For the following piece of code:
> 
> ```c
> typedef union {
> 	long i;
> 	int k[5];
> 	char c;
> } date;
> 
> struct data {
> 	int cat;
> 	date cow;
> 	double dog;
> } too;
> 
> int main(int argc, char *argv[]) {
> 	date max;
> 	printf("%d", sizeof(struct data) + sizeof(max));
> 	return 0;
> }
> ```
> 
> What is the output for `printf()` statement?
> 
> **52**