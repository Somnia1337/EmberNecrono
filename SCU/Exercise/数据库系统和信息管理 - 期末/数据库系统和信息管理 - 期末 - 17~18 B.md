### 1. 单选

```text
1 CDDBC
```

### 2. 查询

2.1

2.1.1

$$\rm \large \Pi_{id,\space name}(\sigma_{title\space =\space 'Wechat Programming'}(Project) \Join S\_P \Join Student)$$

2.1.2

$$\rm \Pi_{Student.id,\space name}(\sigma_{Student.id = S\_P.student\_id}(\Pi_{S\_P.student\_id}) \div (\Pi_{S\_P.student\_id}(\sigma_{S\_P.student\_id = 'CS101'}))))$$

2.1.3

$$\rm \large \Pi_{student\_id}(\sigma_{project\_count > 5}({\mathcal{G} \space {\small count\_distinct}(project\_no) \space as \space project\_count}(S\_P)))$$

2.2

```sql
-- 1)
SELECT id, name
FROM Student
WHERE id NOT IN (
	SELECT id
	FROM Student s, S_P sp, Project p
	WHERE s.id = sp.student_id
		AND sp.project_no = p.project_no
		AND p.title = "Wechat Programming"
);

-- 2)
SELECT project_no, title
FROM Project
WHERE title LIKE "Program%";

-- 3)
SELECT id, name
FROM Student s, S_P sp, Project p
WHERE s.id = sp.student_id
	AND sp.project_no = p.project_no
	AND p.title = "Programming of Wechat"
	AND sp.grade = MAX (
		SELECT grade
		FROM S_P sp, Project p
		WHERE sp.project_no = p.project_no
			AND p.title = "Programming of Wechat"
	);

-- 4) ?
-- SELECT id, name
-- FROM Student s, S_P sp1
-- WHERE NOT EXISTS (
-- 	SELECT sp2.student_id, sp2.project_no
-- 	FROM S_P sp2
-- 	WHERE sp1.student_id <> "CS101"
-- 		AND sp2.student_id = "CS101"
-- )

-- 5)
SELECT name, AVG(grade) avg_grade
FROM Student s, S_P
GROUP BY s.id;
```

### 3. 范式

3.1

```text
1)
- id -> {name, dept_name, tot_credit}
- dept_name -> {building, budget}
2) id
3) 不是 3NF, {building, budget} 传递依赖于 id
- id -> {name, dept_name, tot_credit} | FK = dept_name
- dept_name -> {building, budget}
```

3.2

```text
1) (A, C)
2)
- A -> B
- C -> D
3) 是的, 因为不存在非主属性对码的传递依赖
```

### 4. 事务

4.1

```text
1) 是冲突可串行化的, 等效于 T1,T2 的顺序
2) 不是冲突可串行化的
	1. 冲突操作(部分):
		- T1 read(A) & T2 write(A)
		- T1 write(A) & T2 read(A)
	2. 确定依赖关系:
		- T1 read(A) 需先于 T2 write(A)
		- T2 read(A) 需先于 T1 write(A)
	3. 构建图:
		- T1 -> T2
		- T2 -> T1
	依赖图中存在环, 因此不是冲突可串行化的
```

### 5. 设计