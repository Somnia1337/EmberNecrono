### 1. 单选

```text
1 CDBAC | 2 3
6 BBACC | 6 7
```

### 2. 查询

2.1

2.1.1

$$\rm \large \Pi_{id,\space name}(\sigma_{team\space =\space '锦江'}(User))$$
2.1.2

$$\rm \large \Pi_{dNo,\space dName}(\sigma_{name\space =\space '李四'}(User) \Join Borrow \Join Dev)$$

2.1.3

$$\rm \large \Pi_{dNo}(\sigma_{id\space =\space '777' \space and \space no =\space '999'}(Borrow))$$

2.1.4

$$\rm \large \Pi_{id,\space name} (\sigma_{id \in (\Pi_{id} (\Pi_{id, dNo} (Borrow) \div \Pi_{dNo} (\sigma_{id = '888'} (Borrow)))} (User))$$

2.2

```sql
-- 1)
SELECT name
FROM Adm
WHERE salary > 5000;

-- 2)
SELECT store
FROM Adm
GROUP BY store
HAVING AVG(salary) > 5000;

-- 3)
SELECT a1.name
FROM Adm AS a1
GROUP BY store
HAVING a1.salary = ALL(
	SELECT MAX(salary)
	FROM Adm AS a2
	WHERE a1.store = a2.store
);

-- 4)
SELECT dNo, dName
FROM Dev NATURAL JOIN Borrow
WHERE id = "666" AND (date BETWEEN "2022-06-01" AND "2022-06-30"); 

-- 5)
SELECT name
FROM User NATURAL JOIN Borrow
WHERE id NOT IN (
	SELECT id
	FROM Borrow
	WHERE no = "555"
);

-- 6)
-- step 1
WITH DevicesByAdmin555 AS (
    SELECT Borrow.dNo
    FROM Borrow
    JOIN Adm ON Borrow.no = Adm.no
    WHERE Adm.id = '555'
);

-- step 2
WITH UsersWithDevices AS (
    SELECT Borrow.id, Borrow.dNo
    FROM Borrow
    WHERE Borrow.dNo IN (SELECT dNo FROM DevicesByAdmin555)
);

-- step 3
WITH UsersWhoBorrowedAll AS (
    SELECT id
    FROM UsersWithDevices
    GROUP BY id
    HAVING COUNT(DISTINCT dNo) = (SELECT COUNT(*) FROM DevicesByAdmin555)
);

-- step 4
SELECT User.id, User.name
FROM User
WHERE User.id IN (SELECT id FROM UsersWhoBorrowedAll);
```

### 3. 范式

3.1

$$\rm Athlete(id,\space name,\space birth,\space team,\space phone)$$

- $\rm id \rightarrow \{name,\space birth,\space team\}$
- $\rm team \rightarrow phone$

```text
1) 候选码: {id}
2) 范式级别: 2NF
3) 无损分解: 
```

3.2

$$\rm Shop(no,\space name,\space addr,\space owner,\space item)$$

- $\rm no \rightarrow \{name,\space owner,\space addr\}$

```text
1) 候选码: {no}
2? 范式级别: 3NF
3? 无损分解: 无需
```

3.3

```text
1) 候选码: {A, B}, {A, C}
2) 范式级别: 3NF
3) 无损分解: 无需
```

### 4. 事务

4.1

```text
1) 是冲突可串行化的, 等效于 T2,T1 的顺序

2) 日志:
 1 <T1-Start>
 3 <T2-Start>
 5 <T1, C, 100, 95>
 6 <T2, B, 100, 90>
 9 <T2, A, 100, 98>
11 <T2-Commit>
13 <T1, A, 98, 49>
14 <T1-Commit>

3? 恢复后: A = 98, B = 90, C = 100
```

### 5. 设计

```text
1)
```

![[数据库系统和信息管理 - 期末 - ER 图_1.png|400]]

```text
2?
```

```sql
-- 3?
```