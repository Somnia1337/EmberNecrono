@2024.04.25 | Week 09

### Practice 1

1\.

```c
void main()
{
    char *str, *input;
    int *ilist;
    int i, size1, size2;
	
    printf("Number of letters in word: ");
    scanf("%d", &size1); /* user inputs an integer */
    printf("Number of integers: ");
    scanf("%d", &size2); /* user inputs an integer */
	
    str = (char *)malloc(size1);
    ilist = (int *)malloc(size2);
	
    printf("Word: ");
    scanf("%s", str); /* user inputs a string */
    for (i = 0; i < size2; i++)
    {
        printf("Number %d of %d: ", i + 1, size2);
        scanf("%d", ilist + i); /* user inputs an integer */
    }
}
```

- 越界错误
	- 应为 `str` 分配 `size1 + 1`
	- 应为 `ilist` 分配 `sizeof(int) * size2`
- 内存泄漏：2 次 `malloc()` 调用分配的内存空间都没有对应的 `free()` 调用

2\.

```c
/* return 1 if str is "1", 0 otherwise */
int checkIf1(char *str)
{
    char *newstr = malloc(strlen(str) + 1);
    strcpy(newstr, str);          /* set newstr to str */
    if (strcmp(newstr, "1") == 0) /* newstr is "l" */
    {
        return 1;
    }
    free(newstr);
    return 0;
}

void main()
{
    char *strArr[4] = {"1", "2", "3", "4"};
    int i;
    for (i = 0; i < 4; i++)
    {
        printf("%d\n", checkIf1(strArr[i]));
    }
}
```

- 内存泄漏：`checkIf1()` 的 `if` 语句中应调用 `free(newstr)`

3\.

```c
struct data
{
    char *str1, *str2;
};

/* returns two strings concatenated if they are not the same, NULL otherwise */
char *mergeSingleIfDifferent(char *s1, char *s2)
{
    char *str = (char *)malloc(strlen(s1) + strlen(s2) + 1);
    if (strcmp(s1, s2) == 0)
    { /* strings are equal */
        str = NULL;
    }
    else
    {
        strcpy(str, sl);
        strcat(str, s2);
    }
    return str;
}

/* copies merged strings (or NULL) into array of strings passed in (results) */
void mergeArrayIfDifferent(char *results[], char *strA1[], char *strA2[], int size)
{
    int i;
    for (i = 0; i < size; i++)
    {
        results[i] = mergeSingleIfDifferent(strA1[i], strA2[i]);
    }
}

void printAndFree(int c, char *str)
{
    if (str != NULL)
    {
        printf("%d: %s\n", c, str);
        free(str);
    }
}

void main()
{
    char *strArr1[8] = {"1", "2", "3", "4", "5", "6", "7", "8"};
    char *strArr2[8] = {"a", "2", "c", "4", "e", "6", "g", "8"};
    char *results[8];
    int i;
    mergeArrayIfDifferent(results, strArr1, strArr2, 8);
    for (i = 0; i < 8; i++)
    {
        printAndFree(i, results[i]);
    }
}
```

- 内存泄漏：`mergeSingleIfDifferent()` 的 `if` 语句中应先调用 `free(str)`

### Practice 2

2.1

```c
void getMemory(char *p)
{
    p = (char *)malloc(100);
}

void test()
{
    char *str = NULL;
    getMemory(str);
    strcpy(str, "hello world");
    printf(str);
}
```

程序将出错，因为 `getMemory()` 中对 `p` 的赋值不会改变 `test()` 中 `p` 的值，随后的 `strcpy()` 调用将尝试向地址 `0` 写入一个字符串，导致程序出错。

2.2

```c
char *getMemory()
{
    char p[] = "hello world";
    return p;
}

void test()
{
    char *str = NULL;
    str = getMemory();
    printf(str);
}
```

程序将出错，因为 `getMemory()` 中对 `p` 的赋值存储在栈上，随着调用返回将被释放，`str` 由此成为 *悬垂指针*，导致程序出错。

2.3

```c
char *getMemory2(char **p, int num)
{
    *p = (char *)malloc(num);
}

void test()
{
    char *str = NULL;
    getMemory2(&str, 100);
    strcpy(str, "hello");
    printf(str);
}
```

成功打印出 `"hello"`。

2.4

```c
void test()
{
    char *str = (char *)malloc(100);
    strcpy(str, "hello");
    free(str);
    if (str != NULL)
    {
        strcpy(str, " world");
        printf(str);
    }
}
```

虽然成功打印出 `" world"`，但实际上存在严重的问题：`free(str)` 后，已经释放了 `str` 指向的内存空间，随后的写入可能覆盖该空间中的其他值，导致潜在的问题。