@2024.05.30 | Week 13

## Part 1

When a cache is full and a new cache line needs to be fetched into it, which of the following is a pretty good, practical approach? **Randomly selecting a cache location for the new line.**

About the cache in a computer system, which is true?

- Every computer system has 3 level cache, that is L1, L2, L3 cache
- Every computer systems' cache system have data cache and instruction cache
- Every computer systems' cache system has 2 level cache, that is L1, and L2 cache

**none**

Consider the following fragments from two versions of a program.

```c
// version A
for (i = 0; i < n; i++) {
	read(i);
	calculate(i);
	write(i);
}

// version B
for (i = 0; i < n; i++) {
	read(i);
}
for (i = 0; i < n; i++) {
	calculate(i);
}
for (i = 0; i < n; i++) {
	write(i);
}
```

Which of the following are true of version B, compared to version A?

- B may be faster because of cache effects.
- B may be slower because of cache effects.
- B may execute at essentially the same speed as A.

**i, ii and iii**

A program whose code and data together occupy fewer than 256 KB is executed on a computer with a 512 KB direct cache. Which of the following is true? **There is no telling, from the information given, how many bytes will be fetched from main memory.**

Which facts about the cache can be determined by calling the following function?

```c
int data[1 << 20];
void callee(int x) {
	int i, result;
	for (i = 0; i < (1 << 20); i += x) {
		result += data[i];
	}
}
```

- cache line size
- cache size
- cache speed

**i only**

Which is the fastest cache mapping function? **direct mapping**

A computer system has a 4KB cache organized in block-set-associative manner with $4$ lines per set, $64$ bytes per line. The number of bis in the `SET` and `OFFSET` fields of the main memory address format is: **`4`, `6`**

Your computer has 32-bit integers and a direct cache containing 128 32-byte cache lines. In the following code fragment, the compiler allocates `a` at address `0x800000` and `b` at address `0x801000`. Before the execution of the code fragment, the arrays `a` and `b` have never been used, so they are not in the cache. what is the minimum number of bytes from each of the arrays `a` and `b` that could be fetched into the cache from main memory, during the execution of the code?

```c
int b[1024];
int a[1024];
for (i = 0; i < 17; sum += a[i] + b[i], i++);
```

**1088**

The principle of locality justifies the use of **cache memory**.

Which cache write mechanism allows an updated memory location in the cache to remain out of date in memory until the block containing the updated memory location is replaced in the cache? **write back**

When the following code fragment is executed on a computer with 32-bit integers and a fully-associative cache with 32-byte cache lines, how many bytes of the array a will be fetched into the cache from main memory?

```c
int a[100];
for (i = 0; i < 17; sum += a[i], i++);
```

**at most 96**

Assume a memory access to main memory on a cache "miss" takes 30 ns and a memory access to the cache on a cache "hit" takes 3 ns. If 80% of the processor's memory requests result in a cache "hit", what is the average memory access time? **8.4 ns**

## Part 2

### Q1.

3M decides to make Post-Its by printing yellow squares on white pieces of paper. As part of the printing process, they need to set the CMYK (cyan, magenta, yellow, black) value for every point in the square. 3M hires you to determine the efficiency of the following algorithms on a machine with a 2048-byte direct-mapped data cache with 32-byte blocks. You are given the following definitions:

```c
struct point_color {
	int c;
	int m;
	int y;
	int k;
};

struct point_color square[16][16];
int i, j;
```

Assume the following:

- `sizeof(int) == 4`
- Square begins at memory address `0`
- The cache is initially empty
- The only memory accesses are to the entries of the array square, variables `i` and `j` are stored in registers.

Determine the cache performance of the following code:

```c
for(i = 0; i < 16; i++) {
	for(j = 0; j < 16; j++) {
		square[i][j].c = 0;
		square[i][j].m = 0;
		square[i][j].y = 1;
		square[i][j].k = 0;
	}
}
```

> [!question] A. What is the total number of writes?

$1024$

> [!question] B. What is the total number of writes that miss in the cache?

$128$

> [!question] C. What is the miss rate?

$\large \frac{1}{8}$

### Q2.

Given the assumptions in Q1, determine the cache performance of the following code:

```c
for(i = 0; i < 16; i++) {
	for(j = 0; j < 16; j++) {
		square[j][i].c = 0;
		square[j][i].m = 0;
		square[j][i].y = 1;
		square[j][i].k = 0;
	}
}
```

> [!question] A. What is the total number of writes?

$1024$

> [!question] B. What is the total number of writes that miss in the cache?

$256$

> [!question] C. What is the miss rate?

$\large \frac{1}{4}$

### Q3.

Given the assumptions in Q1, determine the cache performance of the following code:

```c
for(i = 0; i < 16; i++) {
	for(j = 0; j < 16; j++) {
		square[i][j].y = 1;
	}
}

for(i = 0; i < 16; i++) {
	for(j = 0; j < 16; j++) {
		square[i][j].c = 0;
		square[i][j].m = 0;
		square[i][j].k = 0;
	}
}
```

> [!question] A. What is the total number of writes?

$1024$

> [!question] B. What is the total number of writes that miss in the cache?

$256$

> [!question] C. What is the miss rate?

$\large \frac{1}{4}$