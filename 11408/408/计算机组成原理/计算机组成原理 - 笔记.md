## 01 计算机系统概述

### 计算机系统层次结构

计算机硬件系统：控制器、运算器、存储器、输入设备、输出设备。

CPU 中的特殊存储器：

- **存储器地址寄存器**(**MAR**) 存放访存地址，其位数与 PC 相同，反映最多可寻址的存储单元数目。
- **存储器数据寄存器**(**MDR**) 暂存要读写的数据，其位数等于存储字长。

### 计算机的性能指标

指标：

- **CPI**：执行一条指令平均所需的时钟周期数。
- **IPS**：每秒执行的指令数，$= {\large \frac{主频}{CPI}}$。
	- **MIPS**：每秒执行的（百万）指令数。
- **FLOPS**：每秒执行的浮点运算数。

| 缩写  | 数量级       |
| --- | --------- |
| $M$ | $10^6$    |
| $G$ | $10^9$    |
| $T$ | $10^(12)$ |
| $P$ | $10^(15)$ |
| $E$ | $10^(18)$ |
| $Z$ | $10^(21)$ |

> [!warning] 大 $K$ 与小 $k$
> 
> - 描述 *存储容量* 时，用 $K$，$M$，$G$ 等，表示 $2^n$，如 $1 Kb = 2^{10} b$
> - 描述 *速率频率* 时，用 $k$，$M$，$G$ 等，表示 $10^n$，如 $1 kb/s = 10^3 b/s$

> [!info] 问答
> 
> - 主频高的 CPU 不一定更快，因为运算速度还与架构、缓存、指令集、字长、cache 有关。
> - 不同的程序：
> 	- 编译程序：高级编译语言 -> 汇编语言 / 机器语言。
> 	- 汇编程序：汇编语言 -> 机器语言。
> 	- 解释程序：逐行翻译高级语言 -> 机器语言，并立即执行。

## 02 数据的表示和运算

### 数制与编码

浮点数的进制转换：整数部分 **除基取余**，小数部分 **乘基取整**。

| 码      | 描述（$n+1$ 位）                                         | `min`      | `max`     |
| ------ | --------------------------------------------------- | ---------- | --------- |
| **原码** | 最高位表示符号，其余表示大小                                      | $-2^n + 1$ | $2^n - 1$ |
| **补码** | 正数：原补反相同<br>负数：$2^{n+1} - \lvert x \rvert$（取反加 $1$） | $-2^n$     | $2^n - 1$ |
| **反码** | 正数：原补反相同<br>负数：补码减 $1$（取反不加 $1$）                    | $-2^n + 1$ | $2^n - 1$ |
| **移码** | 真值 $+$ 偏移 $2^n$                                     | $-2^n$     | $2^n - 1$ |

- 原码、反码的表示范围比补码、移码少 1 个值，因为前者有 2 种方式表示 $0$。
- 计算机中有符号整数、无符号整数都采用 *补码* 表示。
- `char` 默认为无符号整数。

### 运算方法和运算电路

| 移位       | 左移                                                      | 右移                                 |
| -------- | ------------------------------------------------------- | ---------------------------------- |
| **逻辑移位** | 高位移出，低位补 $0$                                            | 低位移出，高位补 $0$                       |
| **算术移位** | 高位移出，低位补 $0$<br>移位前若高两位 $X_1 X_2$ 有 $X_1 != X_2$<br>则溢出 | 低位移出，高位补 $["符号位"]$<br>移出 $1$ 时损失精度 |

补码加减法：

- $(X + Y)_C = X_C + Y_C space "mod" space 2^(n+1)$
- $(X - Y)_C = X_C + (-Y)_C space "mod" space 2^(n+1)$

判断溢出：无论加减法，如果参与运算的两个数符号相同、结果又与之相反，则溢出。

| 标志位         | 含义                              | 作用范围        |
| ----------- | ------------------------------- | ----------- |
| `ZF` 零标志    | 结果是否为 $0$                       | 有符号数 & 无符号数 |
| `OF` 溢出标志   | 有符号数的运算是否溢出<br>是符号位进位与最高数位进位的异或 | 有符号数        |
| `SF` 符号标志   | 结果的符号                           | 有符号数        |
| `CF` 进/借位标志 | 无符号数的运算是否溢出<br>加法时产生进位，或减法时产生借位 | 无符号数        |

用 `ZF` 和 `CF` 比较无符号数 $A$，$B$：计算 $A - B$，

|          | `ZF = 0`               | `ZF = 1`           |
| -------- | ---------------------- | ------------------ |
| `CF = 0` | 结果非 $0$，无借位<br>$A > B$ | 结果为 $0$<br>$A = B$ |
| `CF = 1` | 结果非 $0$，有借位<br>$A < B$ | 不可能出现              |

原码乘法：符号位异或，绝对值相乘。

### 浮点数的表示与运算

浮点数由符号 $S$、阶码 $E$ 和尾数 $M$ 构成：

$$N = (-1)^S times R^E times M$$

$R$ 为基数，约定为 $2$ 的幂。位数一定，$R$ 越大，$N$ 的范围越大、精度越低。

IEEE 754 标准下浮点数的表示（指数 $e$ 即为 $2^E$）：

| 类型  |  位数  | 符号 $s$ | 指数 $e$ | 尾数 $f$ |  偏置值   | 表示值                                   |
| --- | :--: | :----: | :----: | :----: | :----: | ------------------------------------- |
| 单精度 | $32$ |  $1$   |  $8$   |  $23$  | $127$  | $(-1)^s times 1.f times 2^(e - 127)$  |
| 双精度 | $64$ |  $1$   |  $11$  |  $52$  | $1023$ | $(-1)^s times 1.f times 2^(e - 1023)$ |

- 标准下的浮点数都是规格化的，尾数最高位（小数点前）总为 $1$，因此将其隐藏，从而可以获得额外的一位有效位。
- 指数 $e$ 用移码表示，但其偏置值取 $2^n - 1$（而非 $2^n$），从而 $e$ 的允许值为 $1 \sim 254$（单精度）/ $1 \sim 2046$（双精度）

特殊数：

| 阶码    | 尾数    | 含义            |
| ----- | ----- | ------------- |
| 全 $0$ | 全 $0$ | $+0$ / $-0$   |
| 全 $0$ | 非 $0$ | 非规格化数         |
| 全 $1$ | 全 $0$ | $+oo$ / $-oo$ |
| 全 $1$ | 非 $0$ | `NaN`         |

加减运算对阶：小阶看齐大阶，持续右移尾数（但保留移出的部分）同时阶码加 $1$，直到阶码相同。

*判断溢出*：指数上溢（超过最大允许值）（指数下溢时结果为 $0$）。

**大小端存储**：“端”指低位端，“大/小”指地址大小。

- 大端：低位在大地址
- 小端：低位在小地址

## 03 存储系统

### 存储器概述

- 按层次分：
	- **主存** / 内存
	- **辅存** / 外存
	- **高速缓冲存储器**(cache)
- 按存取方式分：
	- **随机存储器**(RAM)
		- 静态 RAM(SRAM)（*高速缓冲存储器*）
		- 动态 RAM(DRAM)（*主存*）
	- **只读存储器**(ROM)（*BIOS*）
	- **串行访问存储器**
		- 顺序存取存储器（*磁带*）
		- 直接存取存储器（*磁盘*、*光盘*）

`存储容量 = 存储字数 * 字长 = 地址空间大小 * 一次存取操作的数据量`

时间：

- **存取时间**：完成一次读 / 写操作的用时。
- **存取周期**：连续两次访存之间的最小时间间隔，包含并大于 *存取时间*。

### 主存储器

DRAM 需要读后再生，刷新方式：

- **集中刷新**：用刷新周期内的一段固定时间（死时间）对所有行依次再生，期间暂停访存。
- **分散刷新**：将存储器的工作周期一分为二，前半用于访存，后半用于刷新，加长了系统的存取周期。
- **异步刷新**：用刷新周期除以行数得到刷新间隔 $t$，每隔 $t$ 才刷新一行，使死时间更分散。

| 比较点   | SRAM（cache） | DRAM（主存） |
| ----- | :---------: | :------: |
| 存储单元  |     触发器     |    电容    |
| 破坏性读出 |      否      | 是（需读后再生） |
| 需要刷新  |      否      |    是     |
| 送行列地址 |     并行送     | 串行送（复用）  |
| 速度    |      快      |    慢     |
| 集成度   |      低      |    高     |
| 存储成本  |      高      |    低     |

### 主存储器与 CPU 的连接

主存通过数据总线、地址总线、控制总线与 CPU 连接：

- *数据总线* 的位宽度和工作频率决定数据传输速率。
- *地址总线* 的位宽度决定可寻址的内存空间大小。

主存容量的扩展方法：

- **位扩展法**：扩展字长。
- **字扩展法**：扩展字数。

### 外部存储器

一块磁盘有若干记录面（每个对应一个磁头），每个划分为圆形磁道，每条划分为扇区（块）。扇区是磁盘读写的最小单位。

磁盘的存取时间：寻道时间 + 旋转延迟时间 + 传输时间。

固态硬盘(SSD)：

- 读写以页为单位，擦除以块为单位。
- 耐久度低，引入磨损均衡以延长寿命。

### 高速缓冲存储器

cache：

- 由 SRAM 组成，集成在 CPU 中。
- 和主存划分为大小相同的块。
- CPU 与 cache 以字为单位交换，cache 与主存以块为单位交换。

cache 和主存的映射（设主存有 $2^m$ 块，cache 有 $2^c$ 行，每块有 $2^b$ 字）：

![[cache-memory-mapping.png|600]]

多路组相联映射：cache 分为 $Q$ 组，组内全相联映射，组间直接映射。设每组有 $r$ 行，称为 $r$ 路组相联映射。

cache 替换算法：

- 随机
- 先进先出(FIFO)
- 最近最少使用(LRU)
- 最不常使用(LFU)

cache 与主存保持内容一致的方法：cache 写命中 `match`

- 命中 =>
	- **直写法** / 全写法：将数据同时写入 cache 和主存。实现简单；增加访存次数（低效）。
	- **回写法**：只写入 cache，该块被替换出时才写回主存。高效；需要设置额外的修改位（脏位），有数据不一致的隐患。
- 未命中 =>
	- **写分配法**：更新主存并调入 cache。常与 *回写法* 合用。
	- **非写分配法**：只更新主存。常与 *直写法* 合用。

### 虚拟存储器

主存和辅存在逻辑上共同构成虚拟存储器，二者统一编址，虚地址空间 $>>$ 实地址空间。

虚拟存储机制采用 *全相联映射* 和 *回写法*。

**页表** 记录程序的虚页调入主存时存放的位置，页表本身长期驻留在主存中。

页表的位：

- 有效位 / 装入位：标记页面是否在主存中，为 `0` 时发生缺页异常。
- 脏位 / 修改位：标记页面是否被修改过。
- 引用位 / 使用位：配合替换策略（FIFO / LRU / LFU）。

虚拟地址和物理地址的页面大小相同，因此页内偏移地址（低位）相同。

每个进程有一个页表基址寄存器，存放该进程的页表首地址。

将经常访问的页放入高速缓冲器组成的 **快表**(**TLB**) 中可以提高效率。

TLB、cache、page 可能的缺失组合：

| TLB | cache | page |    需要的访存次数    |
| :-: | :---: | :--: | :-----------: |
| $1$ |  $1$  | $1$  |      $0$      |
| $1$ |  $0$  | $1$  |      $1$      |
| $0$ |  $1$  | $1$  |      $1$      |
| $0$ |  $0$  | $1$  |      $2$      |
| $0$ |  $0$  | $0$  | $>= 2$，还需访问辅存 |

缺失 `match` 的处理方：

- TLB => 软件 / 硬件
- cache => 硬件
- page => 软件（OS 的缺页异常处理程序）

| 比较项 | cache    | 虚拟存储器     |
| --- | -------- | --------- |
| 目的  | 提高系统速度   | 扩展主存容量    |
| 实现  | 硬件       | OS 和硬件    |
| 透明性 | 对所有程序员透明 | 对系统程序员不透明 |

> [!todo] 问答 P153

## 04 指令系统

### 指令系统

扩展操作码：短码不能是长码的前缀。

转移指令：无条件转移 `JMP`，条件转移 `BRANCH`，调用 `CALL`，返回 `RET`，陷阱 `TRAP`。

### 指令的寻址方式

- **指令寻址**：寻找下一条要执行的指令地址。
	- 顺序寻址：程序计数器 `PC` 自动 `+1`（与编址方式和指令字长有关，若按字节（$8$ 位）编址、指令字长为 $16$，则 `PC` 要 `+2`）。
	- 跳跃寻址：通过转移指令修改 `PC`。
- **数据寻址**：寻找本条指令的数据地址。

寻址方式比较（`A` 代表形式地址 Address）：

| 数据寻址方式      | 有效地址 `EA`             |       访存次数       | 备注                                   |
| ----------- | --------------------- | :--------------: | ------------------------------------ |
| **立即寻址**    | `A` 本身为数据             |        0         | `A` 为补码                              |
| **直接寻址**    | `A`                   |        1         |                                      |
| **间接寻址**    | `(A)`                 |        2         |                                      |
| **寄存器寻址**   | `R`                   |        0         |                                      |
| **寄存器间接寻址** | `(R)`                 |        1         |                                      |
| **相对寻址**    | `(PC) + A`            |        1         | `A` 为补码                              |
| **基址寻址**    | `(BR) + A`            |        1         | `A` 变化<br>基址寄存器 `BR` 不变              |
| **变址寻址**    | `(IX) + A`<br>`IX` 变化 |        1         | 变址寄存器 `IX` 变化<br>`A` 不变<br>适合 `loop` |
| **堆栈寻址**    | 栈顶                    | 0（硬堆栈）<br>1（软堆栈） | 硬堆栈：寄存器实现<br>软堆栈：主存实现                |

3 种偏移寻址：相对寻址，基址寻址，变址寻址。

### 程序的机器级代码表示

> [!todo] P183

### CISC 和 RISC 的基本概念

| 比较项      | CISC               | RISC                 |
| -------- | ------------------ | -------------------- |
| 指令系统     | 复杂，庞大              | 简单，精简                |
| 指令数目     | 一般大于 200 条         | 一般小于 100 条           |
| 指令字长     | 不固定                | 定长                   |
| 可访存指令    | 不加限制               | 只有 `LOAD`/`STORE` 指令 |
| 各种指令执行时间 | 相差较大               | 绝大多数在一个周期内完成         |
| 各种指令使用频度 | 相差很大               | 都比较常用                |
| 通用寄存器数量  | 较少                 | 多                    |
| 目标代码     | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效   |
| 控制方式     | 绝大多数为微程序控制         | 绝大多数为组合逻辑控制          |
| 指令流水线    | 可以通过一定方式实现         | 必须实现                 |

## 05 中央处理器

### CPU 的功能和基本结构

CPU 由 **控制器** 和 **运算器** 组成。

- 控制器：程序计数器(PC)，指令寄存器(IR)，指令译码器(ID)，存储器地址寄存器(MAR)，存储器数据寄存器(MDR)，时序电路，微操作信号发生器。
- 运算器：算术逻辑单元(ALU)，暂存寄存器，累加寄存器(ACC)，通用寄存器组(GPRs)，程序状态字寄存器(PSW)，移位寄存器，计数器(CT)。

寄存器：

- 用户可见寄存器：GPRs（含基址/变址寄存器），PSW，PC，ACC，移位寄存器。
- 用户不可见寄存器：MAR，MDR，IR，暂存寄存器。

> [!info] P207：各寄存器的功能

### 指令执行过程

**指令周期**：CPU 取出并执行完一条指令的用时。

*指令周期* 可用若干 *机器周期* 表示，不同指令的指令周期可能不同。

一个完整的定长指令周期包含 4 个阶段：取指，间址，执行，中断。

处理器：

- **单周期** ~：每条指令都在 $1$ 个时钟周期内完成（设计时，指令周期取决于执行时间最长的指令，$"CPI" = 1$），每执行完一条指令才能开始下一条。效率较低。
- **多周期** ~：指令需要几个周期就分配几个（设计时，机器周期长度可变，$"CPI" > 1$），指令间仍串行。
- **流水线** ~：在每个时钟周期启动一条指令，指令间并行执行，力求在每个时钟周期都有一条指令完成（力求 $"CPI" = 1$）。

> [!tip] 时钟周期、机器周期、指令周期、总线周期
> 
> - **时钟周期**：CPU 完成一个基本操作的用时，为主频的倒数，实现同步，为四者里的最小。
> - **机器周期**：CPU 完成一个有实际意义的操作（如内存访问、寄存器读写、ALU 运算）的用时，包含若干 *时钟周期*。
> - **指令周期**：CPU 取出并执行完一条指令的用时，包含若干 *机器周期*。
> - **存取周期**：对内存完成一次读/写操作的用时，包含若干 *时钟周期*。
> 	- 设计时，通常 *存取周期 = 机器周期*
> - **总线周期**：CPU 与内存或 I/O 设备通过总线进行数据传输所需的时间，包含若干 *时钟周期*。

### 数据通路的功能和基本结构

CPU 在逻辑功能上可视为由 **数据通路** 和 **控制部件** 组成，后者控制前者。

数据通路：数据在指令执行过程中所经过的路径，包括该路径上的部件。

- **组合逻辑元件** / **操作元件**：不含存储信号的记忆单元，不受时钟信号控制。如加法器，ALU，译码器，多路选择器，三态门。
- **时序逻辑元件** / **状态元件**：含记忆单元，与时钟同步工作。如各类寄存器和存储单元。

通路结构：

- **单总线**：将数据通路部件连接到一条总线上。结构简单；冲突多，效率低。
	- 单周期处理器不能采用单总线，因为一个时钟周期内只允许一次操作，无法完成一条指令。
- **多总线**：同时在多条总线上传输不同的数据。较高效。
- **专用数据通路**：不使用共享总线，而是根据数据流动方向安排专用电路。高效；设计复杂。

### 控制器的功能和工作原理

功能：

- 取指
- 译指，产生操作控制信号
- 控制数据通路

控制器分类：

- **硬布线** ~：由复杂的组合逻辑门电路和触发器组成，所有操作由实际电路实现。速度快；结构复杂。一般 RISC 采用。
- **微程序** ~：将微操作信号代码化，每条机器指令对应于控制存储器(CM) 的一段微程序。
	- 控制存储器：存放微程序，在 CPU 内部，ROM 实现。
	- 微命令：控制部件向执行部件发出的命令。
	- 微操作：执行部件收到命令执行的操作。
	- 微指令：若干微命令的集合。
	- 微周期：从控制存储器取出并执行完一条微指令的用时，通常为一个时钟周期。

### 异常和中断机制

- **异常** / **内中断**：CPU 内部的意外事件，与 CPU 同步。
- **中断** / **外中断**：外部设备向 CPU 发出的中断请求，与 CPU 异步。

CPU 执行用户程序的第 $i$ 条指令时发生异常，或执行完成后发现中断请求，则打断当前程序，转而执行相应的异常或中断处理程序 `match`

- 问题解决 => 回到第 $i$（异常）或第 $i + 1$（中断）条指令继续执行。
- 问题未解决 => 终止用户程序。

异常的分类：

- **硬故障中断**：由硬连线异常引起。
	- **终止**(abort)：执行指令的过程中发生了计算机硬件故障，如控制器出错，总线错误，将终止当前程序。
- **程序性异常** / **软件中断**：由指令执行引起。
	- **故障**(fault)：引起故障的指令执行完毕前发生的异常，如译码时出现非法操作码，取数据时发生缺段 / 缺页，除法运算时除数为 `0`。
	- **自陷**(trap)：事先安排好的陷阱，执行到陷阱指令时作对应处理，然后返回到下一条指令 / 转移目标指令（当陷阱指令为转移指令时）。

中断的分类：

- 可屏蔽中断：可以被屏蔽（不送达 CPU）。
- 不可屏蔽中断：不能被屏蔽，通常为紧急硬件故障。

| 比较项       | 异常         | 中断   |
| --------- | ---------- | ---- |
| 与指令执行的相关性 | 在指令执行过程中产生 | 无关   |
| CPU 获知途径  | CPU 自检测    | 外部通知 |

CPU 响应异常和中断的过程：

1. 关中断：禁止响应新的中断，以免后续处理过程被打断。
2. 保存断点和程序状态：保存程序的断点（返回地址）和 PSW 的内容。
3. 识别异常或中断、转到处理程序。

### 指令流水线

利于实现指令流水线的指令集特性：

- 指令长度固定
- 指令格式规整
- 只用 `LOAD/STORE` 型指令访存
- 数据和指令按边界对齐存放

流水线的设计原则：

- 流水段数量 = 最复杂指令的功能段数量
- 流水段长度 = 最复杂操作用时

| 冒险                   | 描述                                             | 解决方法                             |
| -------------------- | ---------------------------------------------- | -------------------------------- |
| **结构冒险** / **资源冲突**  | 不同指令同时争用同一功能部件                                 | 延迟执行相关指令<br>设置多个部件               |
| **数据冒险**：写后读(RAW)冲突  | 后面的指令用到前面指令的结果时，该结果尚未产生                        | 延迟执行相关指令<br>采用转发（旁路）技术           |
| **数据冒险**：load-use 冒险 | `LOAD` 指令及其后紧邻的运算类指令之间的数据冒险                    | 在后面的运算指令前插入 `NOP` 指令<br>编译调整指令顺序 |
| **控制冒险**             | 转移指令 / 返回指令 / 异常和中断改变了 `PC`，导致指令执行顺序改变，从而流水线断开 | 插入 `NOP` 指令<br>分支预测              |

在按序执行的流水线中，只可能出现 *数据冒险：RAW 冲突*。

流水线的性能指标（流水段数 $k$，时钟周期 $Delta t$）：

- **吞吐率**：单位时间内完成的任务数量 $$"TP" = n/T_k = n/((k + n - 1) Delta t)$$ 显然 $n -> oo$ 时 $"TP" -> 1$。
- **加速比**：完成相同的任务，不使用流水线的用时与使用流水线的用时之比 $$S = T_0/T_k = (k n)/(k + n - 1)$$

高级流水线技术：

- **超标量流水线** / **动态多发射**：每个时钟周期内并发多条独立的指令，乱序执行，需多个部件堆叠。
- **超长指令字** / **静态多发射**：组合多条能够并行的指令为一条具有多个操作码字段的超长指令，需多个部件堆叠。
- **超流水线**：提高流水线主频。

超流水线的最优 $"CPI" = 1$；多发射技术的最优 $"CPI" < 1$，但成本更高。

### 多处理器的基本概念

- S / M：Single / Multiple
- I / D：Instruction / Data

计算机体系结构：

- SISD：一个处理器和一个存储器，一次执行一条指令。
- SIMD：一个指令控制部件和多个处理单元，同时处理多个数据流。
- MISD：不存在。
- MIMD：多处理器系统，是共享存储多处理器(SMP) 系统的简称。

**硬件多线程**：每个线程有单独的寄存器组、PC 等部件，切换线程时只需激活其部件。

**多核处理器**：将多个处理单元集成到一块 CPU，可选地共享 cache，并共享主存。

**共享存储多处理器(SMP)**：

- **统一存储访问(UMA)多处理器**：每个处理器对所有存储单元的访问时间相同。
- **非统一存储访问(NUMA)多处理器**：某些存储器的访存速度更快。

> [!info] 问答
> 
> - 流水段数越多，指令不一定执行越快，因为流水段缓冲之间的额外开销更大、段间控制逻辑更复杂。

## 06 总线

### 总线概述

**总线**：一组能为多个部件分时和共享的公共信息传送线路，*分时* 指同一时刻只允许一个部件发出信息，*共享* 指多个部件可以同时接收信息。

按功能层次分类：

- 片内 ~：芯片内部的总线。
- 系统 ~：计算机系统各功能部件互联的总线
	- 数据 ~：双向传输，位数 => 一次能传输的数据量。
	- 地址 ~：单向传输，位数 => 寻址空间。
	- 控制 ~
- I/O ~：连接低速的 I/O 设备。
- 通信 ~：也称外部总线。

按时序控制方式分类：

- 同步 ~：通过统一的时钟同步。
- 异步 ~：以信号握手方式协调。

按数据传输方式分类：

- 串行 ~：只有一条双向传输 / 两条单向传输的数据线。
- 并行 ~：有多条双向传输的数据线。

系统总线的结构：

- 单总线结构：将 CPU，主存，I/O 设备都挂在一组总线上。
- 双总线结构：主存总线，I/O 总线。
- 三总线结构：主存总线，I/O 总线，直接内存访问(DMA) 总线。

总线性能指标：

- ~ 周期 / ~ 频率：同于时钟周期 / 时钟频率。
- ~ 传输周期：一次总线操作的用时。
- ~ 工作频率：$1$ 秒内传送数据的次数。
- ~ 宽度：数据总线的条数。
- ~ 带宽：$1$ 秒内最多传输的字节数。
	- $"带宽" = "宽度" times "工作频率"$

### 总线事务和定时

**总线事务**：从请求总线到完成总线使用的操作序列。

1. 请求
2. 仲裁
3. 寻址
4. 传输
5. 释放

数据传送方式：

- **非突发**：每个传送周期都先传送地址、再传送数据，每次一个字。
- **突发** / **猝发**：寻址阶段发送多个连续数据单元的首地址，传输阶段传送多个连续单元的数据。

定时方式：

- **同步**：用统一时钟信号协调。
- **异步**：依靠双方握手信号协调，每个字符都要用开始位和停止位作为字符开始和结束的标志。根据请求和回答信号的撤销是否互锁：
	- 不互锁
	- 半互锁：主设备发出请求后，需收到从设备的回答信号才撤销请求。
	- 全互锁：在半互锁的条件下，从设备的回答信号需获知主设备撤销了请求信号后才撤销。
- **半同步**：增设一条 wait 响应信号线，每个时钟周期开始时采样 wait 信号，有效时从数据线上取数据。
- **分离式**：将总线事务分解为请求和应答两个过程，设备传送完毕后释放总线，不存在空闲时间。

## 07 输入/输出系统

### I/O 接口

**I/O 接口**：主机和外设之间的交接界面，实现二者的信息交换。

#### I/O 接口的功能

I/O 接口的功能：

- 地址译码和设备选择
- 通信联络控制
- 数据缓冲
- 信号格式转换
- 传送控制命令和状态信息
- I/O 过程中错误与状态检测

#### I/O 接口的基本结构

寄存器：

- **数据缓冲** 寄存器：暂存数据。
- **状态** ~：记录接口和设备的状态信息。
- **控制** ~：记录 CPU 对外设的控制信息。
	- *状态* ~ 和 *控制* ~ 传送方向相反、访问时间不重叠，可以合为一个。

数据线：

- **数据线**：读/写数据，状态信息，控制信息，中断类型号。
- **地址线**：要访问 I/O 接口中的寄存器的地址。
- **控制线**：读/写控制信号，中断请求，响应信号，仲裁信号，握手信号。

==I/O 指令是特权指令==，只能在 OS 底层的 I/O 软件中使用。

#### I/O 端口及其编址

**I/O 端口**：I/O 接口电路中可被 CPU 直接访问的寄存器。

- **数据** 端口：可读可写（CPU <-> 外设）。
- **状态** ~：只读（外设 -> CPU）。
- **控制** ~：只写（CPU -> 外设）。

I/O 端口的编址：

- **独立编址**：也称 I/O 映射，I/O 端口的地址空间与主存的地址空间相互独立，因此范围可能重叠，需设置专门的 I/O 指令表明要访问 I/O。==译码简单，寻址快速；程序设计灵活性差==。
- **统一编址**：也称存储器映射，二者的地址在同一空间的不同分段。==访问 I/O 的操作更灵活方便；主存可用容量降低，译码复杂==。

### I/O 方式

I/O 方式：

- 程序查询
- 程序中断
- DMA

#### 程序查询

CPU 执行程序控制信息交换，需要数据缓冲寄存器、程序状态寄存器。

分类：

- **独占查询**：CPU 持续查询接口状态，即所有时间用于与外设串行工作。
- **定时查询**：CPU 周期性地查询接口状态，满足条件时进行数据传送。

==设计简单，硬件量少；CPU 花费很多时间查询和等待，且同一时间只能与一个外设交互==。

#### 程序中断

**程序中断**：执行程序的过程中出现急需处理的异常情况或特殊请求，CPU 将暂时停止当前程序，处理该情况后返回当前程序。

中断用于实现：

- CPU 与外设并行工作
- 人机交互
- 多道程序
- 应用程序和 OS 的切换（软中断）

当外设准备好数据时，发出中断请求，CPU 接收数据，完成一次数据传送。

为记录中断并区分不同的中断源，需对每个中断源设置 **中断请求标记触发器**，其为 `1` 时表示该中断源有请求，一系列触发器构成 **中断请求标记寄存器**。

- **可屏蔽中断**：通过 INTR 线发出。
- **不可屏蔽中断**：通过 NMI 线发出（优先级最高，无视关中断）。

当同时出现多个中断请求，通过中断判优逻辑（硬件排队器实现）确定响应顺序。

- **响应优先级**：由硬件线路或查询程序的查询顺序决定，不可动态改变。
- **处理优先级**：可利用中断屏蔽技术动态调整，以实现多重中断。

CPU 响应中断必须满足条件：

- 中断源发出请求
- 开中断（*异常*、*不可屏蔽中断* 无视）
- CPU 执行完当前指令（*异常* 无视）

**中断隐指令**：CPU 响应中断后，执行中断服务程序之前的一系列硬件自动操作（不是真的指令）。

中断的识别：

- **非向量中断**：即软件查询方式，见 Ch 5。
- **向量中断**：称中断对应的 *中断服务程序的入口地址* 为 **中断向量**。
	- **中断向量表**：系统中的全部中断向量集中存放在存储器的区域。

中断处理过程：

1. 关中断。
2. 保存断点。
3. 中断服务程序寻址。
4. 保存现场和屏蔽字。
5. 开中断（允许更高级中断请求得到响应，以实现中断嵌套）。
6. 执行中断服务程序。
7. 关中断。
8. 恢复现场和屏蔽字。
9. 开中断。
10. 中断返回。

- `2.` ~ `4.`、`8.` 这 4 个步骤在关中断保护下进行。
- `1.` ~ `3.` 由中断隐指令（硬件自动）完成，`4.` ~ `10.` 由中断服务程序完成。
- 单重中断的处理流程没有 `5.` 和 `7.`。

要具备多重中断需满足的条件：

- 在中断服务程序中提前开中断（`5.`）。
- 优先级高的中断源可以打断优先级低的源。

**中断屏蔽技术**：每个中断源都有一个屏蔽触发器（掩码），`1` 表示屏蔽该中断源的请求，`0` 表示可以正常请求，所有屏蔽触发器构成屏蔽字寄存器，其内容称为屏蔽字。

假设 4 种中断的优先级为 `A > B > C > D`，则它们的屏蔽字：

| 中断源 | 屏蔽字（`ABCD`） |
| --- | ----------- |
| A   | `1111`      |
| B   | `0111`      |
| C   | `0011`      |
| D   | `0001`      |

解释：`A` 能屏蔽所有 `<= A` 的中断，即 `ABCD` 全部，所以为 `1111`，以此类推。

#### DMA

**直接存储器存取**(**DMA**)：一种由硬件实现的、成组传送数据的控制方式，传送过程不涉及 CPU，适用于磁盘、显卡、声卡、网卡等高速设备进行大批量数据传送。

DMA 下，中断只用于正常传送结束 / 故障时的通知。

**DMA 控制器**(**DMAC** / DMA 接口)：控制 DMA 数据传送过程的硬件。

DMAC 控制数据传输的过程：

1. DMAC 接收外设发出的 *DMA 请求*。
2. ~ 向 CPU 发出 *总线请求*。
3. CPU 响应并发出总线响应信号，DMA 接管总线，进入 DMA 操作周期。
4. ~ 确定传送数据的主存起始地址及长度，并自动修改主存地址计数和传送长度计数。
5. ~ 发出读/写等控制信号，执行数据传送操作。
6. ~ 向 CPU 报告 DMA 操作结束。

DMA 与 CPU 共享主存的方式：

- **停止 CPU 访存**：有 DMA 请求时，DMAC 向 CPU 发送一个停止信号，使 CPU 放弃总线控制权，暂停访存直到 DMA 传送结束。==控制简单，适用于高速外设；DMA 过程中 CPU 完全闲置==。
- **周期挪用**：挪用一个 *存取周期*，传送完一个数据字后即释放总线。（访存请求冲突时 `match` CPU 正在访存 => 等待其完成；CPU 没有访存 => CPU 放弃占有权。）==效率较平衡；每传输一次，DMA 接口都要重新申请、建立和归还总线控制权==。
- **交替访存**：将 CPU 工作周期分成两个时间片，分别用于 CPU 访存、DMA 访存，==适用于 CPU 工作周期 > 主存存取周期==。==无需反复申请、建立和归还总线控制权；硬件逻辑复杂==。

DMA 下，整个数据传送过程都不需要 CPU 参与，只有最初的 DMAC 初始化及最后的结束处理需要 CPU 介入，因此 ==CPU 用于 I/O 的开销较小==。

DMA 方式和中断方式的区别：

| 比较项       | 中断              | DMA                   |
| --------- | --------------- | --------------------- |
| 程序切换和现场保护 | 切换程序<br>保护和恢复现场 | 不中断现行程序<br>无需保护现场     |
| 响应时机      | 每条指令执行结束时       | 任意一个机器周期结束时           |
| CPU 参与    | 程序传送，需要 CPU 参与  | 除了预处理和后处理，其他时段不占用 CPU |
| 优先级       | 低               | 高                     |

> [!info] 问答
> 
> - 开中断前提下，CPU 检测到中断就会立即响应（因为开中断时，能检测到说明优先级更高）。
