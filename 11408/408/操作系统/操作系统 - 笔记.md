## 01 计算机系统概述

### 操作系统的基本概念

#### 操作系统的特征

- **并发**：多个事件在同一时段发生。
    - *并发* 在同一时刻执行一个操作，*并行* 在同一时刻执行多个操作。
- **共享**：系统中的资源可供多个并发执行的进程共用。
    - *互斥共享*：如打印机。
    - *同时访问共享*：如磁盘。
- **虚拟**：将一个物理实体抽象为若干逻辑对应。
- **异步**：多个程序并发执行，执行顺序具有不可预知性。

#### 操作系统的目标和功能

OS 提供的接口：**命令接口**（联机命令接口 / 脱机命令接口）/ **程序接口**。

### 操作系统发展历程

![[OS-evolution.png|300]]

### 操作系统的运行环境

#### 处理器运行模式

特权指令和非特权指令：

- **特权指令**：不允许用户程序执行的指令，有 I/O 指令 / 关中断指令 / 内存清零指令 / 存取用于内存保护的寄存器的指令 / 送 `PSW` 的指令等。
- **非特权指令**：允许用户直接使用的指令，仅限访问用户的地址空间，不能直接访问系统软硬件资源，防止用户程序破坏系统。

CPU 的运行模式：

- **内核态**：可以执行特权指令（=> 切换用户态的指令是特权的）。
- **用户态**：只能执行非特权指令（=> 切换内核态的指令是非特权的）。

引发切换内核态的事件：系统调用 / 中断 / 用户程序出错 / 请求执行特权指令。

#### 中断和异常的概念

发生中断或异常时，处于用户态的 CPU 立即切换内核态（硬件实现）。

#### 系统调用

系统调用的功能：设备管理 / 文件管理 / 进程控制 / 进程通信 / 内存管理。

> [!example] 系统调用的处理
> 
> 1. 将系统调用号和所需的参数压栈，调用实际的调用指令，执行陷入指令，CPU 切换内核态，保护被中断进程的现场。
> 2. 分析系统调用类型，执行相应的系统调用处理子程序。
> 3. 恢复被中断的进程的现场，返回继续执行。

### 操作系统结构

- **分层法**：将 OS 分为若干层，每层只能调用紧邻它的低层的功能和服务。
    - 👍 便于调试 / 可扩展 / 可维护
    - 👎 灵活性差 / 低效
- **模块化**：将 OS 按功能划分为若干具有一定独立性的模块，每个模块具有某方面的管理功能，各模块通过接口通信。
    - 👍 可维护 / 可适应
    - 👎 接口混乱
- **宏内核**：将 OS 的主要功能模块作为一个紧密联系的整体运行在核心态，为用户程序提供高性能的系统服务。
    - 👍 高效
    - 👎 庞杂
- **微内核**：将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。移出内核的 OS 代码根据分层的原则被划分成若干服务程序，相互独立，通过微内核通信。
    - 👍 可扩展 / 可靠 / 可移植
    - 👎 性能差于宏内核

### 操作系统引导

> [!example] OS 的引导
> 
> 1. 激活 CPU，执行 BIOS。
> 2. BIOS 构建中断向量表，通电自检。
> 3. 加载带有 OS 的硬盘。
> 4. 加载主引导记录(MBR)。
> 5. 加载硬盘活动分区。
> 6. 加载分区引导记录(PBR)。
> 7. 加载启动管理器。
> 8. 加载 OS。

### 虚拟机

- **第一类虚拟机管理程序**：直接运行在裸机上，相当于 OS。
- **第二类虚拟机管理程序**：运行在宿主 OS 上，相当于一个用户程序。

![[OS-virtual_machine.png|300]]

<div style="page-break-after: always"></div>

## 02 进程与线程

### 进程与线程

#### 进程的概念和特征

**进程实体** / 进程映像的构成：

- **进程控制块**(**PCB**)：每个进程专有的数据结构，描述进程的基本情况和运行状态，进而控制和管理进程。
- 程序段
- 数据段

#### 进程的组成

PCB 的内容：

- 进程描述信息：进程标识符(PID)，用户标识符(UID)。
- 进程控制和管理信息：进程当前状态，，进程优先级，代码运行入口地址，程序的外存地址，进入内存时间，CPU 占用时间，信号量使用。
- 资源分配清单：代码段指针，数据段指针，堆栈段指针，文件描述符。
- 处理机相关信息：各寄存器值。

#### 进程的状态与转换

进程的 5 种状态（前 3 种为基本状态）：

- **运行**：进程正在 CPU 上运行。
- **就绪**：进程获得了除 CPU 外的一切所需资源，一旦获得 CPU 即可运行。
- **阻塞**：进程正在等待某一事件而暂时无法运行，如等待 I/O 完成。
- **创建**
- **终止**

区别 *就绪* 和 *阻塞*：

- 就绪：仅缺少 CPU，一旦获得 CPU 即可运行。
- 阻塞：需要其他资源或等待某一事件。

![[OS-thread.png|450]]

#### 进程控制

父进程与子进程的关系：

- 进程创建另一个进程，创建者和被创建者为父子进程。
- 子进程继承父进程的资源。
- 撤销子进程时，将其资源归还父进程。
- 撤销父进程时，同时撤销所有子进程。

引发进程创建的事件：登录系统 / 作业调度 / 系统提供服务 / 用户程序请求。

> [!example] 进程创建
> 
> 1. 分配进程标识号。
> 2. 申请空白 PCB（失败时，创建失败）。
> 3. 分配资源（失败时，进程处于创建态）。
> 4. 初始化 PCB。
> 5. 插入就绪队列。
> 
> IBRIQ (Id -> Block -> Resource -> Init -> enQueue)

引发进程终止的事件：正常结束 / 异常结束 / 外界干预。

> [!example] 进程终止
> 
> 1. 读取 PCB。
> 2. 终止。
> 3. 终止子孙。
> 4. 归还资源（OS / 父进程）。
> 5. 删除 PCB。

引发进程阻塞的事件：请求系统资源失败 / 等待某种操作的完成 / 新数据尚未到达 / 无新任务可做。

> [!example] 进程阻塞
> 
> 1. 读取 PCB。
> 2. 保护现场。
> 3. 入等待队。

引发进程唤醒的事件：被阻塞进程期待的事件发生，如 I/O 完成或数据到达。

> [!example] 进程唤醒
> 
> 1. 读取 PCB。
> 2. 出等待队。
> 3. 入就绪队。

#### 进程的通信

高级通信方式：高效传输大量数据的通信方式。

- **共享存储**：通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读写而通信。
- **消息传递**：利用 OS 提供的消息传递方法通信。
    - 直接通信方式：直接将消息发送到接收进程。
    - 间接通信方式：将消息发送到某个中间实体。
- **管道通信**：管道是一个特殊的共享文件，又称 pipe 文件，数据在管道中 FIFO，进程按生产者-消费者方式进行通信。
    - 管道只允许单向通信，若要双向，需要两个管道。

#### 线程和多线程模型

**线程**：

- 是轻量级进程。
- 是进程中的一个实体。
- 是被 OS 独立调度和分派的基本单位。
- （几乎）不拥有资源。
- 与同进程中的其他线程共享进程资源。
- 同进程中的多个线程可以并发。
- 也有就绪 / 运行 / 阻塞三种基本状态。
- 也有唯一的标识符和控制块（**线程控制块**，TCB）。

线程与进程：

- 线程切换的开销远小于进程（只需保存和设置少量寄存器内容，且在同一进程中切换线程不会引发进程切换）。
- 线程有更好的并发性，提高了系统资源的利用率和系统的吞吐量。
- 线程之间的同步和通信更易实现。

线程的实现：

- **用户级线程**(**ULT**)：用户可见，内核意识不到线程的存在，所有管理工作由应用程序在用户态完成，无须 OS 干预。
    - 👍 无模式切换 / 调度算法进程独立 / 实现与 OS 无关
    - 👎 系统调用时该进程内所有线程阻塞 / 无法利用多 CPU 的优势
- **内核级线程**(**KLT**)：在内核支持下运行，所有管理工作在内核态完成。
    - 👍 能利用多 CPU 的优势 / 不会“一阻全阻”
    - 👎 模式切换开销

多线程模型：

- **多对一**：将多个 ULT 映射到一个 KLT。
    - 👍 无模式切换
    - 👎 “一阻全阻”
- **一对一**：将一个 ULT 映射到一个 KLT。
    - 👍 高并发
    - 👎 开销大
- **多对多**：将 $n$ 个 ULT 映射到 $m$ 个 KLT（$n >= m$）。
    - 👍 均衡

### CPU 调度

#### 调度的概念

**CPU 调度**：从就绪队列中按某种算法选择进程并分配 CPU，实现进程并发。

三级调度：

- 高级调度 / 作业调度：为一个作业创建进程，为多道批处理系统特有。
- 中级调度 / 内存调度：将暂时无法运行的进程调入外存（挂起）。
- 低级调度 / 进程调度：按某种算法从就绪队列选择一个进程使其运行。

三级调度的特点：

- 作业调度次数少，中级调度次数略多，进程调度频率最高。
- 进程调度是最基本的，不可或缺。

#### 调度的实现

调度程序的构成：

- **排队器**
- **分派器**
- **上下文切换器**：对 CPU 进行切换时，会发生两次上下文切换——
    - 保存当前进程上下文，装入分派程序上下文。
    - 移出分派程序上下文，装入新选进程上下文。

需要进程调度与切换的情况：

- 创建新进程时。
- 进程正常结束 / 异常终止 / 阻塞时。
- I/O 完成后唤醒对应进程时。

不能进行进程的调度与切换的情况：

- 处理中断时。
- 执行原语时。

进程调度的方式：

- **非抢占式**：一个进程执行时，优先级更高的就绪进程也需等待其结束或阻塞。
- **抢占式**：上述条件发生时，立即暂停原进程，将 CPU 让给优先级更高者。

两种线程的调度：

- ULT：内核选择一个进程，由进程本身的调度程序决定线程调度。
- KLT：内核选择一个线程，不考虑其所属进程。

#### 调度的目标

评价调度算法的指标：

- **CPU 利用率**：$\large \frac{{\rm CPU}\space 有效工作时间}{{\rm CPU}\space 有效工作时间 + {\rm CPU}\space 空闲时间}$
- **系统吞吐量**：单位时间内 CPU 完成作业的数量。
- **周转时间**：从作业提交到完成的时间，一般取平均值。
    - **带权周转时间**：$\large \frac{作业周转时间}{作业实际运行时间}$
- **等待时间**：进程排队的时间。
- **响应时间**：从用户提交请求到系统首次响应的时间。

#### 进程切换

*调度* 和 *切换*：

- 调度：决定资源分配，是决策。
- 切换：实际执行分配，是执行。

#### 典型的调度算法

| 调度算法       | 抢占  | 优点                        | 缺点                 | 适用    |
| ---------- | --- | ------------------------- | ------------------ | ----- |
| **先来先服务**  | 否   | 公平<br>简单                  | 不利于短作业             | 无     |
| **短作业优先**  | 可以  | 平均等待时间<br>和平均周转时间最短       | 长作业会饥饿<br>估计时间不易确定 | 批处理系统 |
| **高响应比优先** | 可以  | 兼顾长短作业                    | 计算响应比有开销           | 无     |
| **时间片轮转**  | 必须  | 兼顾长短作业                    | 平均等待时间长<br>上下文切换开销 | 分时系统  |
| **多级反馈队列** | 可以  | 队列自定义算法<br>响应时间较短<br>可行性强 | 实现复杂               | 通用    |

- 高响应比优先：$响应比 = {\Large \frac{等待时间 + 要求服务时间}{要求服务时间}}$
- **优先级**
    - 抢占式 / 非抢占式
    - 静态 / 动态
- **多级队列**
    - 设置多个就绪队列，按进程性质分配，每个队列的调度策略独立。
    - 队列中的进程和队列本身都可以设置优先级。
    - 在多 CPU 系统中，可以为每个 CPU 设置一个单独的队列，实施各自不同的调度策略，从而利用多 CPU 的优势。
- 多级反馈队列
    - 多个就绪队列
    - 各队列进程分配的时间片不同
    - 每个队列采用 FCFS
    - 按队列优先级调度

### 同步与互斥

#### 同步与互斥的基本概念

**临界资源**：一次仅允许一个进程访问的资源，如共享数据和打印机等。

对临界资源的访问分为 4 部分（区）：

1. 进入 ~
2. 临界 ~
3. 退出 ~
4. 剩余 ~

```rust
loop {
    // entry
    // ! critical
    // exit
    // remainder
}
```

同步与互斥：

- **同步**：也称直接制约关系，为完成任务建立多个进程，它们由于需要协调运行次序而等待、传递信息所产生的制约关系。源于进程的 *合作*。
- **互斥**：也称间接制约关系，当一个进程访问临界资源时，另一个进程必须等待其退出临界区。源于进程的 *竞争*。

#### 实现临界区互斥的基本方法

- 软件实现方法
    - **单标志法** 👎 两个进程必须交替进入临界区，若其中一个不再进入，另一个也将无法进入。
    - **双标志先检查法** 👎 检查对方标志后、设置自己标志前可能发生进程切换，导致双方都检查通过，同时进入临界区。
    - **双标志后检查法** 👎 设置自己标志后、检查对方标志前可能发生进程切换，导致双方都检查失败，无一进入临界区。
    - **Peterson 算法**
        - 👍 遵循了“空闲让进”“忙则等待”“有限等待”
        - 👎 未遵循“让权等待”

```rust
// P0                            // P1
flag[0] = true;                  flag[1] = true;
turn = 1;                        turn = 0;
while flag[1] && turn == 1 {}    while flag[0] && turn == 0 {}
// ! critical                    // ! critical
flag[0] = false;                 flag[1] = false;
// remainder                     // remainder
```

- 硬件实现方法
    - **中断屏蔽方法**：当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简单方法是关中断。
    - **硬件指令方法——TestAndSet 指令**
    - **硬件指令方法——Swap 指令**

> [!error] P98

#### 互斥锁

进程进入临界区时调用 `acquire()` 上锁，退出临界区时调用 `release()` 解锁，`available` 表示锁的可用性。

```rust
fn acquire() {
    while !available {}
    available = false;
}

fn release() {
    available = true;
}
```

`acquire()` 和 `release()` 必须为原子操作。

- 👎 忙等待
- 常用于多 CPU 系统，一个线程可以在一个 CPU 上运转，而不影响其他线程。

#### 信号量

只能由原语 `wait()` 和 `signal()` 访问，简写为 `P()` 和 `V()`（P 和 V 操作）。

##### 整型信号量

用于表示资源数目的整型量 `S`。

```rust
fn wait(S) {
    while S <= 0 {}
    S -= 1;
}

fn signal(S) {
    S += 1;
}
```

##### 记录型信号量

除了整型信号量 `value`，还需一个进程链表 `L`，链接所有等待该资源的进程。

```rust
struct Semaphore {
    value: i32,
    L: std::collections::VecDeque<Process>,
}
```

对信号量 `S` 进行 P 操作，表示进程请求该类资源，先执行 `S.value -= 1`，若 `S.value < 0`，表示资源没有剩余，调用 `block` 原语自我阻塞，并插入 `S.L`。

```rust
fn wait(S: &Semaphore) {
    S.value -= 1;
    if S.value < 0 {
        S.L.push_back(P);
        block(S.L);
    }
}
```

对信号量 `S` 执行 V 操作，表示进程释放该类资源，先执行 `S.value += 1`，此时若 `< 0`，表示有进程在等待，调用 `wakeup` 原语唤醒 `S.L` 中的一个进程。

```rust
fn signal(S: &Semaphore) {
    S.value += 1;
    if S.value <= 0 {
        P = S.L.pop_front();
        wakeup(P);
    }
}
```

##### 利用信号量实现同步

- 将信号量初值设为 `0`。
- 申请资源前执行 P 操作，提供资源后执行 V 操作。

```rust
let mut S = Semaphore::new(0);

fn P1(S: &mut Semaphore) {
    // 执行 x
    V(S); // 标记已执行 x
}

fn P2(S: &mut Semaphore) {
    P(S); // 等待 x
    // 使用 x 的结果执行 y
}
```

##### 利用信号量实现进程互斥

- 将信号量初值设为资源总量。
- 申请资源时执行 P 操作，释放资源时执行 V 操作。
- P 和 V 操作夹紧临界区（中间不能有其他代码）。

```rust
let mut S = Semaphore::new(1);

fn P1(S: &mut Semaphore) {
    P(S); // 加锁
    // ! critical
    V(S); // 解锁
}

fn P2(S: &mut Semaphore) {
    P(S); // 加锁
    // ! critical
    V(S); // 解锁
}
```

#### 经典同步问题

##### 生产者-消费者问题

- 一组生产者和一组消费者共享一个大小为 `n`、初始为空的缓冲区。
- 缓冲区有空余时，生产者才能放入消息，否则阻塞。
- 缓冲区有内容时，消费者才能取出消息，否则阻塞。

```rust
let mut mutex = Semaphore::new(1); // 互斥
let mut empty = Semaphore::new(n); // 空余数量
let mut full = Semaphore::new(0);  // 内容数量

fn producer() {
    loop {
        // 生产
        P(empty);
        P(mutex);
        // ! 放入
        V(mutex);
        V(full);
    }
}

fn consumer() {
    loop {
        P(full);
        P(mutex);
        // ! 取出
        V(mutex);
        V(empty);
        // 消费
    }
}
```

- 有一个盘子，最多能放一个水果。
- 爸爸只放苹果，妈妈只放橘子；儿子只取橘子，女儿只取苹果。
- 盘子为空时，爸爸或妈妈才可放入；盘子不空时，儿子或女儿才可取出。

```rust
let mut plate = Semaphore::new(1);
let mut apple = Semaphore::new(0);
let mut orange = Semaphore::new(0);

fn dad() {
    loop {
        // 生产(苹果)
        P(plate);
        // ! 放入(苹果)
        V(apple);
    }
}

fn mom() {
    loop {
        // 生产(橘子)
        P(plate);
        // ! 放入(橘子)
        V(orange);
    }
}

fn son() {
    loop {
        P(orange);
        // ! 取出(橘子)
        V(plate);
        // 消费(橘子)
    }
}

fn daughter() {
    loop {
        P(apple);
        // ! 取出(苹果)
        V(plate);
        // 消费(苹果)
    }
}
```

##### 读者-写者问题

- 同一时间，允许多个读者读取，或者一个写者写入。
- 写者写入前，等待已有的读者或写者完成。
- 写者写入时，其它读者或写者等待其完成。

```rust
let mut count = 0;
let mut mutex = Semaphore::new(1);
let mut rw = Semaphore::new(1);

fn writer() {
    loop {
        P(rw);
        // ! 写入
        V(rw);
    }
}

fn reader() {
    loop {
        P(mutex);
        
        if count == 0 {
            P(rw);
        }
        count += 1;
        
        V(mutex);
        // ! 读取
        P(mutex);
        
        count -= 1;
        if count == 0 {
            V(rw);
        }
        
        V(mutex);
    }
}
```

##### 哲学家进餐问题

仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子。

```rust
let mut chopstick = [1, 1, 1, 1, 1].map(|x| Semaphore::new(x))
                                   .collect();
let mut mutex = Semaphore::new(1);

fn Pi() {
    loop {
        P(mutex);
        P(chopstick[i]);
        P(chopstick[(i + 1) % 5]);
        
        V(mutex);
        // ! 进餐
        V(chopstick[i]);
        V(chopstick[(i + 1) % 5]);
    }
}
```

#### 管程

**管程**：一种抽象数据结构，它封装了共享资源和对资源操作的过程，通过互斥访问和进程同步来确保资源的安全使用。

> [!info] 类比 *管程* 为 *银行柜台*
> 
> - 柜台是共享资源，客户（进程）想要操作它。
> - 柜台有明确的规则：一次只能服务一个客户（互斥访问）。
> - 如果客户太多，有的客户需要排队等待资源可用（阻塞与唤醒）。
> - 柜台操作的所有细节都由银行员工（管程的操作）来处理，客户不直接接触后台系统（共享数据结构）。

管程的构成：

- 管程的名称。
- 管程内部的共享数据结构说明。
- 操作数据结构的一组过程（函数）。
- 初始化管程内部共享数据的语句。

### 死锁

#### 死锁的概念

**死锁**：一组进程互相等待其它进程释放资源，而都无法继续执行的情况。

**饥饿**：一个进程可以执行而长时间不得以执行（源于不公平的分配策略）。

死锁和饥饿：

- 存在饥饿 $arrow.r.double.not$ 存在死锁。
- 饥饿的进程可以只有一个，死锁的进程必至少为两个。
- 饥饿的进程可能处于就绪态（长期得不到 CPU）或阻塞态（长期得不到 I/O 设备），死锁的进程必处于阻塞态。

> [!example] 死锁的必要条件
> 
> - **互斥**：进程独占资源。
> - **不可剥夺**：资源只能由进程主动释放。
> - **请求并保持条件**：进程获得部分资源并请求更多资源时，保持已获得的部分，即使处于阻塞态。
> - **循环等待条件**：存在一条进程的循环等待链，链中每个进程保持的资源同时被下一个进程请求。

死锁的处理策略：

| 策略          | 程度  | 模式                         | 优点     | 缺点            |
| ----------- | --- | -------------------------- | ------ | ------------- |
| ~ **预防**    | 严格  | 一次请求所有资源<br>资源剥夺<br>资源按序分配 | 不剥夺    | 延长初始化<br>灵活性差 |
| ~ **避免**    | 均衡  | 寻找安全序列                     | 不剥夺    | 需要预知需求        |
| ~ **检测和解除** | 宽松  | 检查死锁的存在                    | 不延长初始化 | 剥夺            |

#### 死锁预防

> [!example] 死锁预防（破坏任一必要条件）
> 
> - 互斥：允许共享资源。（👎 不切实际）
> - 不可剥夺：当一个进程请求更多资源失败时，必须释放已保持的资源。（可用于状态易于保存和恢复的资源，如 CPU 的寄存器及内存资源）
> - 请求并保持
>     - 预先静态分配（👎 可能浪费资源 / 饥饿）
>     - 运行时动态分配（👍 改进）
> - 循环等待：给资源编号，规定进程必须按编号递增的顺序请求，且同类资源一次性申请。（👎 浪费资源 / 不便于增加新类型设备）

#### 死锁避免

##### 系统安全状态

每次分配资源前，先分析此次分配是否可能导致死锁，只在不可能时才执行分配。（👍 限制弱，性能好）

**安全状态**：系统能按某种运行顺序 $P_1, dots.c, P_n$ 为每个进程 $P_i$ 分配其所需的资源，直至满足每个进程对资源的最大需求（使每个进程都可完成运行），称该顺序为 **安全序列**。若系统无法找到一个安全序列，则称系统处于 **不安全状态**。

系统处于 `match`

- 安全状态 => *不可能* 死锁
- 不安全状态 => *有可能* 死锁

##### 银行家算法

> [!example] 银行家算法
> 
> 1. 进程声明对各类资源的需求量。
> 2. 进程申请资源时，系统检查是否有足够的可分配资源，若没有则拒绝。
> 3. 系统再检查执行分配后是否会进入不安全状态，若是则拒绝。
> 4. 系统执行资源分配。

#### 死锁检测和解除

##### 死锁检测

**资源分配图**：

- 圆圈表示进程，框表示一类资源，框中的一个圆表示该类资源中的一个。
- 请求边：进程 -> 资源的有向边，表示该进程申请一个该类资源。
- 分配边：资源 -> 进程的有向边，表示该进程持有一个该类资源。

![[OS-resource_assignment_graph.png|350]]

> [!example] 资源分配图简化规则
> 
> 1. 找到一个系统的剩余资源能满足其要求的进程 $P_i$（其所有出边 $e$ 指向的资源 $R_e$ 的余量都能满足其要求），找不到时 `end`。
> 2. 消除 $P_i$ 的所有入边和出边，释放 $P_i$ 原先占有的资源。
> 3. 转 `1.`。

**可完全简化**：能够根据简化规则消除图中的所有边。

**死锁定理**：系统状态 $S$ 为死锁 <=> $S$ 的资源分配图不可完全简化。

##### 死锁解除

- **资源剥夺法**：*挂起* 某些死锁进程，剥夺资源并分配给其余死锁进程。
- **撤销进程法**：*终止* 某些或全部死锁进程，剥夺资源。
- **进程回退法**：*回退* 一部分死锁进程到足以避免死锁的状态，自愿释放资源。

<div style="page-break-after: always"></div>

## 03 内存管理

### 内存管理概念

#### 内存管理的基本原理和要求

**内存管理**：OS 对内存的划分和动态分配。

内存管理的功能：分配/回收/扩充内存空间 / 地址转换 / 内存共享 / 存储保护。

##### 程序的链接与装入

> [!example] 从源程序到在内存中执行的程序
> 
> 1. **编译**：编译程序将源代码编译为若干目标模块。
> 2. **链接**：链接程序将编译结果链接到它们所需的库函数，形成装入模块。
> 3. **装入**：装入程序将装入模块装入内存运行。

链接方式：

- **静态链接**：程序运行之前，将各目标模块及库函数链接为完整的装入模块。
- **装入时动态链接**：在装入源程序编译得到的模块时，边装入边链接。
- **运行时动态链接**：在程序运行时，需要某目标模块时才进行链接。

装入方式：

- **绝对装入**：只适用于单道程序环境，编译程序产生绝对地址的目标代码，程序中的逻辑地址与物理地址相同。
- **可重定位装入** / **静态重定位**：起始地址从 `0` 开始，程序中指令和数据的地址相对始址偏移，根据内存实际情况将装入模块装入适当位置。
- **动态运行时装入** / **动态重定位**：装入程序将装入模块装入内存后，推迟到程序执行时再进行重定位，装入的地址仍为相对地址。

##### 逻辑地址与物理地址

- **逻辑地址**：从 `0` 地址开始编址的相对地址。
- **物理地址**：内存中物理单元的实际地址。
- **重定位**：逻辑地址转换为物理地址的过程。

逻辑地址通过页表映射到物理内存，页表由 OS 维护并被 CPU 引用。

##### 进程的内存映像

- 只读代码段
    - `.init`：程序初始化时调用的 `_init()`。
    - `.text`：用户程序的机器代码。
    - `.rodata`：只读数据。
- 读/写数据段
    - `.data`：已初始化的全局变量和静态变量。
    - `.bss`：未初始化及所有初始化为 `0` 的全局变量和静态变量。

##### 内存保护

**内存保护**：确保每个进程都有一个独立的内存空间。

内存保护方法：

- 设置一对上、下限寄存器，存放进程在主存中的地址界限，访存时分别和两个寄存器的值比较，判断越界。
- 用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）检查越界：
    - 逻辑地址 `+` 重定位寄存器 `等于` 物理地址
    - 逻辑地址 `>` 界地址寄存器 `说明` 越界

##### 内存共享

**可重入代码** / **纯代码**：允许多个进程同时访问、但不允许修改的代码。

#### 连续分配管理方式

- **连续分配**：为程序分配地址连续的内存空间。
    - 👎 当空闲总大小满足但不连续时分配失败
- **非连续分配**：为程序分配的内存可以分散在各个区域。
    - 分页存储管理：固定分区大小
        - 基本分页存储管理：运行前一次装入
        - 请求分页存储管理：运行时请求装入
    - 分段存储管理：可变分区大小

**内部碎片** 和 **外部碎片**：

![[OS-fragment.png|400]]

连续分配方式：

- **单一连续分配**：内存分为系统区和用户区。系统区仅供 OS 使用，通常在低地址部分；用户区仅有一道用户程序，即用户程序独占整个用户区。
    - 👍 简单 / 无外部碎片 / 无需内存保护
    - 👎 只能单用户、单任务 / 内部碎片 / CPU 利用率极低
- **固定分区分配**：将用户内存空间划分为若干固定分区，每个分区装入一道作业，有空闲分区时从外存的作业队列中选择适当大小的作业装入。
    - 固定分区大小：灵活性差。
    - 可变分区大小：用一张分区使用表维护，按分区大小排队，标记起始地址、大小和分配状态。
    - 👎 可能因程序太大而无法放入任何分区 / 内部碎片
- **动态分区分配** / **可变分区分配**：进程装入内存时，根据实际需要动态分配内存，使分区的大小适合进程的需要，系统中分区的大小和数量都是可变的。
    - 分配时，从空闲分区中分割请求的大小。
    - 回收时，根据起始地址找到插入点，与其它空闲分区 `match`
        - 前相邻 => 合并，修改前一分区表项的大小
        - 后相邻 => 合并，修改后一分区表项的起始地址和大小
        - 前后都相邻 => 合并，修改前一分区大小，取消后一分区
        - 前后不相邻 => 新建表项
    - 👎 外部碎片

基于顺序搜索的分配算法：

- 顺序分配算法
    - **首次适配**(First Fit)：空闲分区按 *地址递增排列*，分配时顺序查找第一个满足大小的分区（即最低地址分区）。
        - 👍 开销小 / 性能较好
        - 👎 低地址碎片
    - **下次适配**(Next Fit) / 邻近适配 / 循环首次适配：与首次适配相同，但是从上次查找结束的位置开始继续查找。
        - 👎 导致高地址没有大空闲分区可用
    - **最佳适配**(Best Fit)：空闲分区按 *容量递增排序*，分配时顺序查找第一个满足大小的分区（即最小分区）。
        - 👎 最多的外部碎片
    - **最坏适配**(Worst Fit)：空闲分区按 *容量递减排序*，分配时顺序查找第一个满足大小的分区（即最大分区）。
        - 👎 导致没有大空闲分区可用
- 索引分配算法：系统较大时，空闲分区链很长，顺序分配算法太慢。索引方式根据大小对空闲分区分类，每类单设一个链，用索引表管理各个链。
    - **快速适配**：从表中查找满足要求的最小空闲分区，取链中第一块分配。
        - 👍 高效 / 无内部碎片
        - 👎 回收时开销大
    - **伙伴系统**：规定所有分区大小为 $2^k$，请求大小为 $n$（$2^(i-1) < n <= 2^i$）时，从 $2^i$ 开始查找最小的空闲分区，设为 $2^j$（$j >= i$），将该分区拆分到有一个 $2^i$ 的分区，分配后余量入链。
    - **哈希算法**：根据空闲分区链的分布规律，设计哈希函数，构建一张以大小为 `key` 的哈希表，`value` 为对应链的头指针。

#### 基本分页存储管理

**分页**：将物理内存空间分为固定大小（如 $4 space "KB"$）的分区，称为 **页框**、**页帧** 或 **物理块**；将进程的逻辑地址空间分为相同大小的若干区域，称为 **页面** 或 **页**；OS 以页框为单位为各个进程分配内存空间。（👍 无外部碎片 / 内部碎片极小）

##### 分页存储的几个基本概念

- **页框号** / **物理块号**：物理内存空间中每个页框的编号，从 `0` 开始。
- **页号**：进程的逻辑地址空间中每个页面的编号，从 `0` 开始。
- 进程执行时申请内存空间，即为每个 *页面* 分配内存中的可用 *页框*，使 *页号* 和 *页框号* 一一对应。

逻辑地址：

| 页号 $P$ | 页内偏移 $W$ |
| ------ | -------- |

**页表**：为实现从页号到物理块号的地址映射，系统为 *每个进程建立的一张* 映射表，*一个页面对应一个页表项*，一个页表项包含 *页号和物理块号*，记录着一个页面在内存中对应的物理块号。

##### 基本地址变换机构

为加快地址变换速度，在系统中设置一个 **页表寄存器**(**PTR**)，存放页表在内存的起始地址 `F` 和长度 `M`。进程未执行时，其页表 `F` 和 `M` 存放在 PCB 中，被调度执行时才装入 PTR。

> [!question] 由页表项计算物理地址
> 
> 页面大小为 $1 space "KB"$，页号 $2$ 对应的物理块号为 $8$，计算逻辑地址 $A = 2500$ 对应的物理地址。

> [!done] 解答
> 
> 页号 $P = A div 1 "KB" = 2$，题给页号 $2$ 对应的物理块的块号为 $8$；页内偏移 $W = 2500 "mod" 1 "KB" = 452$，故 $E = 8 times 1 "KB" + W = 8644$。

##### 具有快表的地址变换机构

**快表**(**TLB**) / 相联存储器：为加快地址变换速度，在地址变换机构中增设的具有并行查找能力的高速缓冲存储器，存放当前访问的若干页表项。

> [!example] 快表参与的地址变换
> 
> 1. CPU 给出逻辑地址，硬件进行地址转换，将页号与所有快表项比较。
> 2. 若找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。（一次访存）
> 3. 若未找到匹配的页号，则需访问主存中的页表，读出页表项后，将其存入快表（若快表已满，按照特定的算法淘汰一个旧表项）。

##### 两级页表

分页管理下，页表本身占用 $upright(K)$ 数量级的连续页面，很难分配。

解决思路：用一级页表（外层，页表的页表）管理二级页表（原页表）

- 二级页表本身离散存放，用一级页表索引二级页表。
- 只将当前需要的部分二级页表项装入内存。

**外层页表** / **页目录**：为管理离散存放的页表而建立的页表的页表。

为加快地址变换速度，在系统中设置一个 **外层页表寄存器** / **页目录基址寄存器**，存放外层页表始址。

二级页表下的地址转换：

- 将逻辑地址中的页目录号作为外层页表的索引，从中找到对应页表的始址，再用二级页号从页表中找到对应的页表项。
- $3$ 次访存。

#### 基本分段存储管理

##### 分段

**分段**：将进程的逻辑地址空间划分为大小不等的段，段求连续，段间可以不连续，进程的地址空间是二维的。

逻辑地址：

| 段号 $S$ | 段内偏移量 $W$ |
| ------ | --------- |

与分页方式不同，$S$ 和 $W$ 必须由用户显式提供（高级语言中由编译器完成）。

##### 段表

**段表**：每个进程都有一张，用于逻辑地址空间与物理地址空间的映射，每个段对应一个段表项，后者包含段号 / 段长 / 本段在主存的起始地址。

##### 地址变换机构

设置一个 **段表寄存器**，存放段表始址 $F$ 和段表长度 $M$。

> [!example] 从逻辑地址 $A$ 到物理地址 $E$ 的变换
> 
> 1. 从 $A$ 中分解出段号 $S$ 和段内偏移量 $W$。
> 2. 比较 $S$ 与段表长度 $M$（必须 $S < M$）。
> 3. 比较 $W$ 与段表项的长度 $C$（必须 $W < C$）。
> 4. 取出段表项中的起始地址 $b$，$E = b + W$。

##### 分页和分段的对比

| 对比项  | 分页                | 分段                         |
| ---- | ----------------- | -------------------------- |
| 概念   | 页是物理单位            | 段是逻辑单位                     |
| 目标   | 提高内存利用率           | 满足用户需求                     |
| 可见性  | 对用户透明             | 用户可见                       |
| 大小   | 页大小固定<br>由 OS 决定  | 段长度不固定<br>由用户程序决定          |
| 地址空间 | 一维<br>1 个参数即可确定地址 | 二维（因为段长不固定）<br>2 个参数才能确定地址 |
| 越界判断 | 1 次：页号            | 2 次：段号，段内偏移                |

##### 段的共享与保护

为分页系统实现共享的难度远大于为分段系统实现共享，因为对于后者，无论段有多大，都只需设置一个段表项。

**可重入代码** / **纯代码**：可以被多个进程在任意时刻共享的代码，不允许修改，不属于临界资源。

#### 段页式存储管理

**段页式存储管理**：结合分页与分段，进程的地址空间先分段，每段再分页，分配内存时以页为单位。

逻辑地址：

| 段号 $S$ | 页号 $P$ | 页内偏移量 $W$ |
| ------ | ------ | --------- |

地址变换：

- 每个进程一张段表，每个段一张页表。
    - 因此，$"进程" : "段表" : "页表" = 1 : 1 : n$
- 段表项包含段号、页表长度和页表始址，页表项包含页号和块号。
- 用一个段表寄存器，记录进程的段表始址和段表长度。
- $3$ 次访存。

### 虚拟内存管理

#### 虚拟内存的基本概念

传统存储管理方式的特点：

- 一次性：作业必须一次性全部装入内存后，才能开始运行
- 驻留性：作业一直驻留在内存中，任何部分都不会被换出，直至运行结束。

**局部性原理**：

- **时间局部性**：某指令执行 / 某数据访问不久后，可能再次执行 / 访问。
- **空间局部性**：某存储单元被访问后，其附近的存储单元也可能被访问。

**虚拟存储器**：通过以下手段，OS 为程序提供的一个比实际容量大很多的存储器。

- 仅需装入程序当前运行需要的少数页面 / 段，即可启动程序执行。
- **请求调页** / **请求调段**：执行过程中，由 OS 将缺失内容从外存调入内存。
- **页面置换** / **段置换**：内存紧缺时，由 OS 将暂时不用的内容换出到外存。

虚拟存储器的特点：

- 多次性：无需将作业一次装入，只需装入当前需要的部分。
- 对换性：无需使作业常驻内存，而是在作业运行过程中将内容换入换出。
- 虚拟性：从逻辑上扩充内存的容量，使用户感知的内存容量远大于实际容量。

虚拟内存依赖于离散分配的内存管理方式，有 3 种实现：

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

虚拟内存依赖于硬件支持：

- 物理内存和外存
- 页表 / 段表机制
- 中断机构（缺页中断）
- 地址变换机构

#### 请求分页管理方式

##### 页表机制

OS 需要了解：

- 每个页面是否已调入内存（若否，该页在外存中的存放地址）
- 一些指标，以决定换出哪个页面（以及 victim 是否被修改过）

页表项：

| 页号  | 物理块号 | 状态位 $P$ | 访问字段 $A$ | 修改位 $M$ | 外存地址 |
| --- | ---- | ------- | -------- | ------- | ---- |

- 状态位 $P$：标记该页是否已调入内存，供程序访问时参考。
- 访问字段 $A$：记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出时参考。
- 修改位 $M$：标记该页是否被修改过，决定换出时是否写回外存。
- 外存地址：记录该页在外存的存放地址（物理块号），供调入时参考。

##### 缺页中断机构

内存是否有空闲页框 `match`：

- 是 => 读取所缺页面，装入该页框，修改页表的相应表项。
- 否 => 由页面置换算法选择一个页面淘汰（若该页在内存期间被修改过，则还要将其写回外存）从而获得空闲页框。

缺页中断与一般中断的区别：

- 在指令执行期间产生和处理，属于内部异常。
- 一条指令的执行可能产生多次缺页中断。

##### 地址变换机构

请求分页系统的地址变换过程

> [!error] P241 图 3.21

#### 页框分配

OS 必须决定读取多少页，即决定给特定的进程分配几个页框。给一个进程分配的页框的集合就是这个进程的 **驻留集**。驻留集越大，缺页率越低，但并发度也越低。

内存分配策略：

- **固定分配**：为进程分配固定数目的物理块，在运行期间不变。
- **可变分配**：为进程分配可变数目的物理块，在运行期间适当增减。

页面置换策略：

- **局部置换**：发生缺页时，只能从分配给该进程的页面中选择 victim。
- **全局置换**：发生缺页时，可以从全部空闲的页面中选择 victim。

物理块调入算法：

- **平均分配**：将所有可分配物理块平均分配给各个进程。
- **按比例分配**：根据进程的大小比例分配物理块。
- **优先权分配**：为重要和紧迫的进程分配较多的物理块。

页面调入策略：

- **预调页**：预测将来可能访问的页面，预先调入内存。用于进程的首次调入。
- **请求调页**：进程运行时缺页便提出请求，调入所需页面。

请求分页系统中的外存分为用于存放文件的 **文件区** 和用于存放对换页面的 **对换区** / **交换区**，后者的 I/O 速度更快。

缺页时，调入缺页的来源情况：

- 对换区空间充足：全部从对换区调入。
- 对换区空间不足：凡是不会被修改的文件都直接从文件区调入。
- UNIX 方式：与进程有关的文件都放在文件区，未使用过的页面都从文件区调入；使用过的页面从对换区调入。

#### 页面置换算法

- **最佳**(OPT)：淘汰以后永不使用的页面，或最长时间内不再访问的页面。
    - 无法实现，用于评价其他算法。
- **先进先出**(FIFO)：淘汰最早装入的页面。
    - 👍 实现简单
    - 👎 性能较差（没有利用局部性原理）
- **最近最久未使用**(LRU)：为每个页面设置一个访问字段，记录自上次访问该页面以来所经历的时间，淘汰最近最长时间未使用的页面。
    - 👍 性能较好（需要寄存器和栈的硬件支持）
- **时钟**(CLOCK)：
    - **简单 CLOCK**：为页面设置访问位 $A$，首次装入和每次访问时置 `1`；所有页面链接成一个循环队列，选择淘汰一页时，用替换指针循环扫描访问位，为 `0` 则选为 victim，为 `1` 则置 `0`（给予第二次机会）。
    - 改进 **CLOCK**：考虑到替换已修改页面的代价更大，为每个页面增设一个修改位 $M$，在选择 victim 时，优先考虑既未使用过又未修改过的页面。
        - 淘汰优先级 $(A, M)$：$(0, 0) > (0, 1) > (1, 0) > (1, 1)$。
        - 👍 减少了磁盘 I/O
        - 👎 算法本身开销较大

**Belady 异常**：缺页次数随分配的物理块增多而增多。只有 FIFO 可能出现。

#### 内存映射文件

**内存映射文件**：OS 向应用程序提供的一个系统调用，与虚拟内存相似，在磁盘文件与进程的虚拟地址空间之间建立映射；将一个文件当作内存中的一个大字符数组来访问，而不通过文件 I/O 访问，以加快速度；对进程透明。

进程间共享内存通信通过映射相同文件到它们的虚拟地址空间实现。

#### 虚拟存储器性能影响因素

- 缺页率
    - 页面大小
    - 分配给进程的物理块数
    - 页面置换算法
- 写回磁盘的频率：批量写回已修改页面以提高效率。

#### 地址翻译

> [!error] P221

<div style="page-break-after: always"></div>

## 04 文件管理

### 文件系统基础

#### 文件的基本概念

**文件**：存储在计算机上的信息集合，程序的 I/O 以文件为基本单位。

文件的构成：

- 数据
- 分类和索引信息
- 访问权限信息

#### 文件控制块和索引节点

**文件控制块**(**FCB**)：存放控制文件所需信息的数据结构，以实现文件的按名存取。FCB 的有序集合称为 **文件目录**（本身也是一个文件，**目录文件**），一个 FCB 就是一个文件目录项。

检索目录时只需文件名，可将文件描述信息单独形成 **索引节点**(**inode**)。

文件目录中的项仅包含文件名和索引节点号。

#### 文件的操作

文件操作：

- 创建：分配空间，新建 FCB。
- 删除：按名查找目录，删除 FCB，回收空间。
- 读取：按名查找目录，获得外存地址。
- 写入：按名查找目录，用 FCB 中的写指针进行写入。
- 打开：
    - 通过系统调用 `open()` 打开文件。
    - 系统维护一个包含所有打开文件信息的表，称为 **打开文件表**。文件的所谓“打开”指系统将目录项从外存复制到内存的打开文件表中，并返回该项的索引号（**文件描述符**）。
- 关闭：
    - 通过系统调用 `close()` 关闭文件。
    - 删除单个进程的打开文件表中的相应条目，并对打开计数器 `-= 1`，为 `0` 时表示该文件不再被使用，从系统表中删除条目。

访问打开文件表的索引号称为 **文件描述符** / **文件句柄**。

在外存定位到 FCB 后，文件名就不再使用，所有操作通过文件描述符进行，即：调用 `open()` 打开文件后，再调用 `read()` / `write()` / `Lseek()` / `close()` 时均使用文件描述符（传参列表不含文件名）。

#### 文件保护

**访问控制**：精简的访问控制列表采用 *拥有者*、*组* 和 *其他* 三种用户类型。

- 拥有者：创建文件的用户。
- 组：一些有相同访问权限的用户。
- 其他：所有其他用户。

创建文件时，OS 将文件拥有者及其所属组名记录在 FCB 中。

安全性：

- **口令**：用户在建立一个文件时提供一个口令，系统在 FCB 中附上口令，同时告诉其他有权访问的用户。用户访问时需提供口令。
    - 👍 开销小
    - 👎 不够安全
- **密码**：对文件进行编码加密，文件被访问时需用密钥解码。
    - 👍 保密性强 / 空间开销小
    - 👎 编码和解码费时

#### 文件的逻辑结构

按逻辑结构，文件分为无结构文件和有结构文件。

- **无结构文件** / **流式文件**
    - 由字符流构成的文件，长度以字节为单位，只能遍历访问。
    - 运行的源程序、可执行文件、库函数等都是无结构文件。
- **有结构文件** / **记录式文件**
    - 由记录构成的文件，各记录包含一定的数据项。
    - 按记录长度：
        - **定长记录**：检索速度快，方便处理。
        - **变长记录**：只能顺序检索，速度慢。
    - 按记录组织形式：
        - **顺序文件**：文件的记录顺序排列，记录可以定长或变长。
            - 👍 大批量读写高效
            - 👎 CRUD 性能差
        - **索引文件**：文件本身用变长记录，用一张索引表索引指针和记录长度。表本身是定长记录的顺序文件，按关键字排序。
            - 👍 将对变长记录顺序文件的顺序检索，转换成对定长记录索引文件的随机检索，加快速度。
        - **索引顺序文件**：顺序文件和索引文件的结合。采用若干级索引，为文件建立一张索引表，将变长记录顺序文件的记录分组，索引每组首条记录。组内关键字无序，组间关键字有序。
            - 👍 检索时，先找记录所在组，再在组内顺序查找，速度快。
        - **直接文件** / **散列文件**：给定记录的键值或通过散列函数转换的键值，直接得到物理地址。
            - 👍 存取快
            - 👎 可能冲突

#### 文件的物理结构

磁盘的存储单元分为 **磁盘块**，大小与内存的页面相同，磁盘 I/O 以块为单位。

几个块为一个 **簇**，按簇分配（👍 查找速度快 👎 内部碎片多）。

为文件分配磁盘块的方式：

- **连续分配**：文件占有一组连续的块。磁盘地址定义了一个线性排序，使进程访问磁盘时的寻道数和寻道时间最小。
    - 👍 支持顺序访问和随机访问 / 顺序访问容易且速度快
    - 👎 必须连续 / 无法动态增长 / 增删时需要移动相邻记录
- **链接分配**：文件占有离散的块。
    - 👍 无外部碎片 / 可动态分配 / 增删开销小
    - 按链接是否显式：
        - **隐式链接**：文件对应一个磁盘块的链表，每个盘块存有指向下个盘块的指针，指针对用户透明。
            - 👎 只支持顺序访问
        - **显式链接**：显式地存放上述指针到内存的一张表中，称为 **文件分配表**(**FAT**)，整个磁盘一张。文件目录中记录起始块号，后续需查找 FAT。
            - 👍 支持顺序访问和随机访问 / 速度快
- **索引分配**
    - **单级索引分配**：每个文件有一个索引块，记录其所有盘块号。
        - 👍 支持随机访问 / 无外部碎片
    - **多级索引分配**：为原索引块再建立一级索引，称为主索引。
        - 👍 查找大型文件速度快
        - 👎 访盘所需磁盘 I/O 次数随着索引级数的增加而增多
    - **混合索引分配方式**
        - 小文件：将每个盘块地址直接放入 FCB（直接寻址）。
        - 中文件：单级索引分配（一次间址）。
        - 大文件：多级索引分配（多次间址）。

> [!error] P261 计算题

### 目录

#### 目录的基本概念

**文件目录**：FCB 的有序集合。

#### 目录结构

- **单级** ~
    - 文件系统有一张目录表，每个文件占一项。
    - 👎 速度慢 / 不允许重名 / 不便于共享
- **两级** ~
    - 将文件目录分成 **主文件目录**(Master ~，MFD)和 **用户文件目录**(UFD)两级，MFD 项记录所有用户名及文件目录的位置，UFD 项记录一个用户所有文件的 FCB。
    - 👍 速度快 / 用户间文件可以重名 / 访问限制
    - 👎 不够灵活 / 不能分类
- **树形** ~
    - 用文件的路径名标识文件，即 `/` 分隔的多级目录，系统中的每个文件都有唯一的路径名。为每个进程设置其工作目录，其对各文件的访问都只须相对于工作目录进行，即相对路径名。
    - 👍 层级权限
    - 👎 需逐级访问（增加磁盘 I/O 次数）/ 不便共享
- **无环图** ~
    - 在树形目录结构中增加一些指向同一节点的有向边，使整个目录成为一个有向无环图。允许目录共享子目录或文件，每个共享节点持一个共享计数器，增加共享链时计数 `+= 1`，删除共享链计数 `-= 1`，为 `0` 时删除。
    - 👍 方便共享

#### 文件共享

- **硬链接**
    - 将文件的物理地址和属性等放在 inode，另放一个引用计数 `count` 表示链接到本 inode 的用户目录项计数。
    - A 创建文件时 `count == 1`；B 共享此文件时，在 B 的目录中增加一个目录项，并设置一个指针指向文件的 inode，计数 `+= 1`；一个用户退出共享时，删除自己目录中的相应目录项，计数 `-= 1`；为 `0` 时删除。
- **软链接** / **符号链接**
    - B 共享 A 的文件 F 时，系统创建一个 LINK 类型的文件 L，L 只有 F 的路径名，写入 B 的目录，类似 Windows 的快捷方式。只有文件主拥有指向其 inode 的指针，共享用户只有路径名；文件主删除 F 后，共享用户的尝试访问会失败，此时将软链接删除。

对比：

- *硬链接*：多个指针指向一个 inode，保证只要还有一个指针指向 inode 就不能删除；所有指向同一个 inode 的硬链接计数均与 inode 计数同步；速度快。
- *软链接*：保存到达共享文件的路径，访问文件时根据路径查找；任何软链接计数恒为 `1`；速度慢。

### 文件系统

#### 文件系统结构

**文件系统**：提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。

![[OS-FileSystem.png|400]]

#### 文件系统布局

##### 文件系统在磁盘中的结构

- **主引导记录**(Master ~，**MBR**)
    - 位于磁盘的 `0` 号扇区，用来引导计算机。其后为分区表，表中的一个分区标记为活动分区。
    - 计算机启动时，BIOS 读入并执行 MBR。MBR 首先确定活动分区，读入它的第一块，即引导块。
- **引导块**：每个分区都是统一从一个引导块开始，MBR 执行引导块中的程序，后者启动该分区中的 OS。
- **超级块**：包含 FS 的所有关键信息，包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的 FCB 数量和 FCB 指针等，在启动 FS 时被读入内存。

![[OS-Partition.png|600]]

##### 文件系统在内存中的结构

- 安装表：包含每个已安装 FS 分区的信息。
- 目录结构的缓存：包含最近访问目录的信息。
- 整个系统的打开文件表：包含每个打开文件的 FCB 副本、打开计数等。
- 每个进程的打开文件表：包含进程打开文件的文件描述符和指向 OS 的打开文件表中对应表项的指针。

#### 外存空闲空间管理

**卷**：包含文件系统的分区，可以是部分磁盘 / 整个磁盘 / RAID，须由对应的文件程序初始化，划分目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块。

磁盘空闲空间的管理：

- **空闲表法**
    - 为每个文件分配一块连续的存储空间（类似内存的动态分区分配），为外存上的所有空闲区建立一张空闲表，每项包括序号、该空闲区的第一个盘块号、该空闲区的盘块数等，表项按起始盘块号递增排列。
    - 分配：首次适配、最佳适配。
    - 回收：考虑回收区是否由前后相邻区（同样的 4 种情况）。
    - 👍 速度快 / 减少磁盘 I/O
- **空闲链表法**
    - 将空闲盘区串为一条空闲链，分为
        - **空闲盘块链**
            - 每个盘块有指向下个盘块的指针。
            - 分配：从链首开始，依次摘下适当数目的空闲盘块。
            - 回收：依次插入链尾。
            - 👍 实现简单
            - 👎 低效
        - **空闲盘区链**
            - 每个盘区含连续盘块，记录盘块数，并指向下个盘区。
            - 分配：首次适配。
            - 回收：合并相邻块。
            - 👍 高效
            - 👎 实现复杂
- **位示图法**
    - 磁盘上的所有盘块都有一个二进制位与之对应，`0` 表示空闲，`1` 表示已分配。记录 $m times n$ 的盘块分配情况只需 $(m times n) "bit"$。
    - 分配：顺序扫描位示图，查找一组空闲块，将行列号转换为盘块号分配，并修改位示图。
    - 回收：将盘块号转换为行列号，修改位示图。
    - 👍 易查找一组相邻空闲块 / 内存开销小
- **成组链接法**
    - 思想
        - 将空闲盘块分组，如 $100 "块/组"$，每组首块记录下一组的块数和块号，将各组首块串为一条链。首组的块数和块号保存在内存的专用栈（空闲盘块号栈）；次末组首块存放的第一个盘块号为 `0`，表示链结束。
    - 分配：根据空闲盘块号栈的指针分配，块数 `-= 1` 并移动指针。
    - 回收：回收的块号压入空闲盘块号栈，块数 `+= 1` 并移动指针。
    - 👍 链长较短

#### 虚拟文件系统

**虚拟文件系统**：抽象出的一个通用的 FS 模型，定义通用的接口，新的 FS 只要实现这些接口即可安装使用。

为实现虚拟 FS，OS 抽象了四种对象类型：

- **超级块** ~：表示一个已挂载的特定 FS，存储其元信息。
- **索引节点** ~：表示一个特定的文件。
- **目录项** ~：表示一个特定的目录项。
    - 不同于前两个对象，目录项对象在磁盘上没有对应的数据结构，而是 VFS 在遍历路径的过程中，将它们逐个解析为目录项对象。
- **文件** ~：表示一个与进程相关的已打开文件，存储其 FS、指针和操作函数。

VFS 对进程隐藏了 FS 细节，并不是一种实际的 FS，只存在于内存。

#### 文件系统挂载

FS 使用前需安装，也称 **挂载**(Mounting)。将逻辑设备的 FS 挂载到某个目录后，通过该目录访问设备。

<div style="page-break-after: always"></div>

## 05 I/O 管理

### I/O 管理概述

#### I/O 设备

##### 设备的分类

- 按信息交换单位
    - **块设备**：信息交换以数据块为单位，如磁盘、磁带。高速、可寻址。
    - **字符设备**：信息交换以字符为单位，如打印机。低速、不可寻址。
- 按传输速率
- 按设备特性
- 按设备共享属性
    - **独占设备**：同一时刻只能由一个进程访问的设备。如打印机。
    - **共享设备**：同一时段内可由多个进程访问的设备（分时共享），如磁盘。
    - **虚拟设备**：通过 SPOOLing 技术将独占设备改造为共享设备，将一个物理设备变为多个逻辑设备。

##### I/O 接口

**I/O 接口** / **设备控制器**：CPU 与设备间的接口，接收 CPU 命令，控制设备工作。

- 设备控制器与 CPU 的接口
- 设备控制器与设备的接口
- IO 逻辑

##### I/O 接口的类型

- 按数据传送方式（外设和接口侧）
    - 并行：一个字节 / 字的所有位同时传送。
    - 串行：位之间串行传送。
- 按主机访问 I/O 设备的控制方式
    - 程序查询
    - 中断
    - DMA
- 按功能选择的灵活性
    - 可编程
    - 不可编程

##### I/O 端口

**I/O 端口**：设备控制器中可由 CPU 直接访问的寄存器

- 数据寄存器：缓存设备输入数据 / CPU 输出数据。
- 状态寄存器：保存设备的执行结果或状态信息，由 CPU 读取。
- 控制寄存器：由 CPU 写入，执行命令或更改设备模式。

I/O 端口的编址方式（“独立”/“统一”的对象为主存）：

- **独立编址**
    - 👍 只需少量地址线 / 速度快
    - 👎 需专用指令 / 控制复杂
- **统一编址**
    - 👍 无需专用指令 / 编址空间大
    - 👎 主存的可用容量变小 / 速度慢

#### I/O 控制方式

> [!info] 参见 [[计算机组成原理 - 笔记]]

#### I/O 软件层次结构

![[OS-IO.png|350]]

**设备独立性** / **设备无关性**：应用所用的 **逻辑设备** 与实际的 **物理设备** 无关，前者用逻辑设备名发出请求，OS 将其映射为物理设备名访问。

#### 应用程序 I/O 接口

##### I/O 接口的分类

- **字符设备接口**：字符设备都属于独占设备，接口中需要提供打开和关闭操作，以实现互斥共享。
- **块设备接口**：磁盘设备的 I/O 常采用 DMA。
- **网络设备接口**

##### 阻塞 I/O 和非阻塞 I/O

- **阻塞 I/O**：当用户进程调用 I/O 时，进程被阻塞并入阻塞队列，I/O 操作完成后进程被唤醒并入就绪队列。
- **非阻塞 I/O**：当用户进程调用 I/O 时，不被阻塞，但不断询问操作是否完成，同时可以做有用工作。

### 设备独立性软件

#### 设备独立性软件

也称与设备无关的软件，包括执行所有设备公有操作的软件。

#### 高速缓存与缓冲区

##### 磁盘高速缓存

利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息，逻辑上属于磁盘，物理上是驻留在内存中的盘块。

##### 缓冲区

下设各项时间：设备 -> 缓冲区 $T$，缓冲区 -> 工作区 $M$，CPU 处理 $C$。

- **单缓冲**
    - 每当用户进程发出一个 I/O 请求，操作系统便在内存中为之分配一个缓冲区。通常，一个缓冲区的大小就是一个块。
    - 每块数据的平均处理时间为 $upright(max)(C, T) + M$。
- **双缓冲** / **缓冲对换**
    - 设置两个缓冲区，I/O 向其中一个输入时，进程可读取另一个。
    - 平均 $upright(max)(C + M, T)$。
- **循环缓冲**：多缓冲，让多个缓冲区组成循环队列的形式。
- **缓冲池**：缓冲区仅是一块内存空间，缓冲池则包含一个用于管理自身的数据结构和一组操作函数的管理机制，用于管理多个缓冲区，可供多个进程共享。

高速缓存和缓冲区都介于高、低速设备之间，区别：

| 对比项  | 高速缓存                        | 缓冲区                    |
| ---- | --------------------------- | ---------------------- |
| 存放数据 | 低速设备部分数据副本<br>高速缓存有的，低速设备必有 | 两种设备互相传送的数据<br>不一定互有备份 |
| 目的   | 高速设备经常要访问的数据                | 两种设备的通信                |

#### 设备分配与回收

##### 设备分配的数据结构

- 设备控制表(DCT)
- 控制器控制表(COCT)
- 通道控制表(CHCT)
- 系统设备表(SDT)

##### 设备分配时应考虑的因素

- 设备的固有属性：独占 / 共享 / 虚拟
- 设备分配算法：FCFS / 优先级
- 安全性

##### 设备分配的步骤

> [!example] 设备分配的步骤
> 
> 1. 分配设备：查 SDT 找 DCT。
> 2. 分配控制器：根据 DCT 找 COCT。
> 3. 分配通道：根据 COCT 找 CHCT。

#### SPOOLing 技术（假脱机技术）

一项将独占设备改造成共享设备的技术，利用专门的外围控制机，将 CPU 与低速设备的数据交换转化为二者分别与高速磁盘的交换，进程都认为自己独占了设备，从而实现数据共享。

![[OS-SPOOLing.png|500]]

SPOOLing 的特点：

- 以空间换时间，提高 I/O 速度
- 将独占设备改造为共享设备
- 实现虚拟设备

#### 设备驱动程序接口

设备驱动程序的功能：

- 检查用户 I/O 合法性。
- 将上层软件发出的命令转换为与设备相关的具体命令。
- 发出 I/O 命令。
- 响应设备控制器的中断请求。

### 磁盘和固态硬盘

#### 磁盘

磁盘地址用“柱面号·盘面号·扇区号”表示。

#### 磁盘的管理

> [!example] 磁盘可用前的 3 步操作
> 
> 1. 低级（物理）格式化
> 2. 分区
> 3. 高级（逻辑）格式化

##### 磁盘初始化

**低级格式化** / **物理格式化**：将磁盘分为扇区。

##### 分区

**分区**：将磁盘分为 C/D 等分区，每个分区由多个柱面组成，其起始扇区和大小记录在磁盘主引导记录的分区表。

**高级格式化** / **逻辑格式化**：将初始文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配空间以及一个初始为空的目录，建立根目录、对保存空闲磁盘块信息的数据结构进行初始化。

#### 磁盘调度算法

##### 磁盘的存取时间

- **寻道时间** $T_s$：在读/写前，将磁头移动到目的磁道所需的时间。
- **旋转延迟时间** $T_r$：磁头定位到要读/写扇区所需的时间，设转速 $r$，$T_r = {\large \frac{1}{2 r}}$。
- **传输时间** $T_t$：磁盘读出或向磁盘写入数据所需的时间，设字节数 $b$、转速 $r$、每磁道字节数 $N$，$T_t = {\large \frac{b}{r N}}$。

$T_r$ 和 $T_t$ 主要取决于转速 $r$，所以磁盘调度算法的目标是减少 $T_s$。

##### 磁盘调度算法

- **先来先服务**(**FCFS**)
- **最短寻道时间优先**(**SSTF**)：选择与当前磁头位置最接近的磁道。
- **扫描**(**SCAN**)：向初始方向移动到底，再反向移动并提供服务。
- **循环扫描**(**C-SCAN**)：移动到底后，反向时不提供服务，而是移动到另一端，再次反向时再恢复服务。

#### 固态硬盘

> [!info] 参见 [[计算机组成原理 - 笔记]]
