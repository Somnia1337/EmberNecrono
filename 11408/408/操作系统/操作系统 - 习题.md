## 01 计算机系统概述

### 操作系统的运行环境

从内核态切换用户态是由操作系统程序执行后完成的，而从用户态切换内核态则是由 **硬件** 完成的。

下列中断事件中，能引起外部中断的事件是 **时钟中断**。

系统调用时要保存 `PSW` 和 `PC` 内容，而一般过程调用只保存 `PC`。

能在用户态执行的是 **命令解释程序**。

处理外部中断时，由 OS 保存的是 **通用寄存器的内容**（`PC` 由中断隐指令，TLB 和 cache 由硬件）。

定时器产生时钟中断后，更新所有有关“时间”的内容。

保存被中断程序的中断点由 **硬件** 完成（`not` OS）。

通过系统调用完成的操作是 **创建进程**（进程调度完全由 OS 自主完成）。

### 操作系统引导

计算机操作系统的引导程序位于 **硬盘**（设备的引导程序才位于 ROM）。

## 02 进程与线程

### 进程与线程

单处理机系统中，如果有 10 个进程，则某一时刻处于就绪队列中的进程最多为 **9** 个（不可能 10 个都就绪而不运行）。

进程通信方式中速度最快的是 **共享内存**。

正确的是 **同一进程或不同进程内的线程都可以并发执行**（注意不是“并行”）。

不属于线程优点的是 **增强进程安全性**（“一阻全阻”）。

一个进程被唤醒意味着 **它可以重新竞争 CPU**（`not` 变为运行态）。

正确的是 **无论系统是否支持线程，进程都是资源分配的基本单位**。

可能阻塞当前进程的事件有 **申请临界资源 / 读取磁盘**（“将 CPU 分配给高优先级的进程”会导致当前进程 *就绪* `not` *阻塞*）。

可能唤醒一个进程的事件有 **I/O 结束 / 另一个进程退出临界区**（“当前进程超时”可能导致一个进程 *运行* `not` *唤醒(阻塞 -> 就绪)*）

### CPU 调度

> [!warning] 本节计算类习题见书 P78 ~ P80

时间片轮转调度算法是为了 **多个用户能及时干预系统**。

临界区中的进程在退出临界区前 **可能被调度**（中断 / 抢占）。

**FCFS 调度算法** 有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业（每次请求 I/O 都要阻塞，I/O 完成后重新排队）。

**时间片轮转调度算法** 是必须可抢占的。

降低进程优先级的合理时机为 **进程超时**。

### 同步与互斥

一个临界区中的进程因申请 I/O 而被中断时，**允许其它进程抢占处理器，但不能进入该临界区**（即使被阻塞，临界区仍为它独占）。

可重入代码 / 纯代码：可以被多个进程在任意时刻共享的代码。，不允许修改

某进程执行 `V(mutex)` 导致唤醒另一个进程，则此时 `mutex` **小于或等于 0**（唤醒 => 原本有进程在等待 => 原 `mutex <= -1` => `mutex += 1` 后 `<= 0`）。

互斥信号量 `mutex` 的初值 **总设置为 1**。

哲学家就餐问题中，左右撇子解法破坏的是 **循环等待**。

### 死锁

> [!error] 本节习题见书 P158 ~ P159
