## 1. 基本数据类型

```python
b1 = 'A' == 65 # False
b2 = True + 1 == 2 and not False != 0 # True

d1 = 5 / 2 # 2.5
d2 = 5 // 2 # 2

p1 = 5 ** 3 # 125
p2 = 2 ** 1024 # 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216

x++ # not OK
x += 1 # OK

s1 = "ABC"
s1 += "XYZ" # "ABCXYZ"
b3 = "CX" in s1 # True
l = len(s1) # 6
s2 = """A line.
Another line.""" # "A line.\nAnother line."
s3 = s1[1] * 3 + s2[2] + s2[-1] # "BBBl."
s4 = s1[0:6:2] # "ACY"
s1 = "IJK" # Error

nums = [1, 1, 2, 3]
nums.append(nums[-2] + nums[-1]) # [1, 1, 2, 3, 5]
last = nums.pop() # 5
nums.insert(0, 2) # [2, 1, 1, 2, 3]
nums.remove(1) # 按值移除首个，若不存在将出错 # [2, 1, 2, 3]
nums.reverse() # 原地反转list，返回为空 # [3, 2, 1, 2]
sorted(nums) # 返回排序结果，不修改原list # [1, 2, 2, 3]
nums.sort() # 原地排序原list # [1, 2, 2, 3]
nums.count(2) # 按值计数 # 2
nums.index(1) # 按值寻找首索引，若不存在将出错 # 0
nums.clear() # []
nums_reversed = nums[::-1] # 将反转后的list赋给新变量 # [3, 2, 2, 1]
del nums[2:] # 删除部分list # [1, 2]

vis = [[0] * 3] * 3 # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
vis[0][0] = 1 # [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
# Python中赋值只是传递引用，而非创建新值。不可变类型——如数值、字符串——赋新值时，实际上创建了新的对象，因此两个变量互不干扰。而列表为可变类型，如果两个列表变量引用同一个对象，那么对象改变时二者都将变化。此例中，创建vis时是将同一个列表[0]复制了3份，又将该列表复制了3份，因此它们指向同一个对象，将同步改变。正确的做法是在创建列表时使用列表推导式。

vis1 = [[0] * 3 for _ in range(3)] # 将用不到的循环计数变量设为下划线 _ 是一种惯例 # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
vis1[0][0] = 1 # [[1, 0, 0], [0, 0, 0], [0, 0, 0]]
```

## 2. NumPy

NumPy是Python科学计算库，提供高性能的数值及矩阵运算。

```python
import numpy as np
np.empty(3) # 开容量为3的空数组，但未初始化为0
np.zeros((3, 3)) # 开容量为3*3的数组，并初始化为0
```

## 3. 控制流程