ğŸ‘ˆ [[15 é¢å‘å¯¹è±¡]]

## æ‰€æœ‰å¯èƒ½ä¼šç”¨åˆ°æ¨¡å¼çš„ä½ç½®

### `match`

åŒ¹é…ä¸€ä¸ª `Option<i32>`ï¼Œå¦‚æœä¸º `Some(n)`ï¼Œè¿”å› `Some(n + 1)`ï¼Œå¦åˆ™è¿”å› `None`ï¼š

```rust
let x = Some(2);
match x {
    None => None,
    Some(n) => Some(n + 1),
}
```

ç¼–è¯‘å™¨è¦æ±‚ `match` è¿›è¡Œç©·å°½åŒ¹é…ï¼Œå…·åå˜é‡å¯ä»¥åŒ¹é…ä»»ä½•æ¨¡å¼ï¼ŒåŒ¿åå˜é‡åˆ™ä¸¢å¼ƒä»»ä½•æ¨¡å¼ã€‚

### `if let`

ä¸€ä¸ªå¤æ‚çš„ `if let` è¯­å¥ï¼ŒåŒ…å«å¾ˆå¤šå¯é€‰å­å¥ï¼š

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();
    
    if let Some(color) = favorite_color {
        println!("{color}");
    } else if is_tuesday { // å¯ä»¥æœ‰ else if
        println!("green");
    } else if let Ok(age) = age { // è¿˜å¯ä»¥æœ‰ else if let
        if age > 30 { // ä¸èƒ½å½’å…¥ else if let, å› ä¸º age åªåœ¨ {} å†…æœ‰æ•ˆ
            println!("purple");
        } else {
            println!("orange");
        }
    } else { // æœ€å, å¯ä»¥æœ‰ else
        println!("blue");
    }
}
```

ç¼–è¯‘å™¨ä¸ä¼šæ£€æŸ¥ `if let` çš„ç©·å°½æ€§ï¼Œé€‚ç”¨äºä¸è¦æ±‚ç©·å°½çš„æƒ…å†µã€‚

### `while let`

ç±»ä¼¼äº `if let`ï¼Œä½†åªè¦æ¨¡å¼åŒ¹é…å°±ä¸€ç›´æ‰§è¡Œ `while`ã€‚

åœ¨æ ˆéç©ºæ—¶æŒç»­å¼¹å‡ºå¹¶æ‰“å°å…ƒç´ ï¼š

```rust
let mut stk = Vec::new();
stk.push(1);
stk.push(2);
stk.push(3);
while let Some(top) = stk.pop() {
	println!("top={top}");
}
```

### `for`

è§£æ„å…ƒç»„å¹¶ç”¨äº `for`ï¼š

```rust
let arr = vec!['a', 'b', 'c'];
for (i, x) in arr.iter().enumerate() {
	println!("arr[{}]={}", i, x);
}
```

### `let`

è¿™ä¹Ÿæ˜¯æ¨¡å¼åŒ¹é…ï¼š

```rust
let x = 0;
```

è§£æ„å…ƒç»„ï¼š

```rust
let (x, y) = (3, 4);
```

è§£æ„å…ƒç»„ï¼Œç”¨åŒ¿åå˜é‡ `_` æˆ– `..` å¿½ç•¥éƒ¨åˆ†å…ƒç´ ï¼š

```rust
let (a, b, _) = (6, 2, 0);
```

### å‡½æ•°å‚æ•°

åœ¨å‡½æ•°å‚æ•°ä¸­è§£æ„å…ƒç»„ï¼š

```rust
fn main() {
    let v = (3.0, 4.0);
    assert!((len(&v) - 5.0).abs() <= 0.00001);
}

fn len(&(x, y): &(f64, f64)) -> f64 {
    (x * x + y * y).sqrt()
}
```

## å¯åé©³æ€§ï¼šæ¨¡å¼æ˜¯å¦ä¼šåŒ¹é…å¤±æ•ˆ

æ¨¡å¼æœ‰ä¸¤ç§å½¢å¼ï¼š**å¯åé©³çš„**(refutable) å’Œ **ä¸å¯åé©³çš„**(irrefutable)ï¼Œç§°èƒ½åŒ¹é…ä»»ä½•ä¼ é€’çš„å¯èƒ½å€¼çš„æ¨¡å¼ä¸ºä¸å¯åé©³çš„ã€‚

`for` / `let` / å‡½æ•°å‚æ•°åªèƒ½æ¥å—ä¸å¯åé©³çš„æ¨¡å¼ï¼ˆå¦åˆ™ï¼Œå¦‚æœæ¨¡å¼ä¸åŒ¹é…ï¼Œç¨‹åºå°†æ— æ³•æ‰§è¡Œï¼‰ï¼Œè€Œ `if let` / `while let` å¯¹ä¸¤ç§å½¢å¼éƒ½èƒ½æ¥å—ï¼Œä½†æ˜¯é€šå¸¸è¦æ¥å—å¯åé©³çš„æ¨¡å¼æ‰æœ‰æ„ä¹‰ï¼ˆå¦‚æœä¸å¯åé©³ï¼Œ`if` å°±ä¸ä¼šå¤±è´¥ï¼Œ`while` ä¹Ÿä¸ä¼šç»ˆæ­¢ï¼Œç¼–è¯‘å™¨å°†å‘å‡ºè­¦å‘Šï¼‰ã€‚

å°è¯•åœ¨ `let` ä¸­ä½¿ç”¨å¯åé©³çš„æ¨¡å¼ï¼š

```rust
let Some(x) = Some(1);
println!("x={x}");
```

è§†è§‰ä¸Šï¼Œä¼¼ä¹åº”è¯¥æ‰“å° `x = 1`ï¼Œä½†æ˜¯æ— æ³•è¿‡ç¼–ï¼š

```text
error[E0005]: refutable pattern in local binding
 --> src\main.rs:2:9
  |
2 |     let Some(x) = Some(1);
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
  = note: the matched value is of type `Option<i32>`
help: you might want to use `let else` to handle the variant that isn't matched    
  |
2 |     let Some(x) = Some(1) else { todo!() };
  |                           ++++++++++++++++
```

åº”è¯¥ä½¿ç”¨ `if let`ï¼š

```rust
if let Some(x) = Some(1) {
	println!("x={x}");
}
```

## æ‰€æœ‰çš„æ¨¡å¼è¯­æ³•

#### `match`

```rust
match x {
	1 => {}                 // å­—é¢å€¼
	2 | 3 => {}             // å¤šä¸ªæ¨¡å¼
	1..=10 => {}            // èŒƒå›´å€¼
	Some(n) => {}           // å‘½åå˜é‡(æšä¸¾)
	Point { x: 0, y } => {} // å‘½åå˜é‡(ç»“æ„ä½“) // åŒ¹é… y è½´ä¸Šçš„ç‚¹
	_ => {}                 // åŒ¿åå˜é‡
}
```

### è§£æ„

è§£æ„ç»“æ„ä½“ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };
    let Point { x, y } = p; // ç­‰æ•ˆäºå…ƒç»„è§£æ„ let (x, y) = (0, 7)
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

è§£æ„æšä¸¾ï¼š

```rust
enum Message {
    Quit,
    Write(String),
    Move { x: i32, y: i32 },
}

fn main() {
    let msg = Message::Move { x: 1, y: 2 };
    match msg {
        Message::Quit => {}
        Message::Write(text) => {}
        Message::Move { x, y } => {}
    }
}
```

### å¿½ç•¥æ¨¡å¼ä¸­çš„å€¼

#### ç”¨ `_` å¿½ç•¥å…¨éƒ¨å€¼

åœ¨å‡½æ•°ç­¾åä¸­ç”¨ `_` å¿½ç•¥æŸä¸ªå‚æ•°ï¼š

```rust
fn main() {
    foo(3, 4);
}

fn foo(_: i32, y: i32) {
    println!("Only y matters: y={y}");
}
```

åœ¨å˜é‡åå‰ç”¨ `_` å¿½ç•¥æœªä½¿ç”¨å˜é‡ï¼š

```rust
fn main() {
	let _x = 5; // no warning
	let y = 10; // warning
}
```

#### ç”¨ `..` å¿½ç•¥å‰©ä½™å€¼

å¦‚æœæœ‰è¾ƒå¤šå€¼éœ€è¦ç”¨ `_` å¿½ç•¥ï¼Œå¯ä»¥æ”¹ç”¨ `..`ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

fn main() {
    let p = Point { x: 0, y: 0, z: 0 };
    match p {
        Point { x, .. } => println!("x={x}"),
    }
}
```

åœ¨ä¸äº§ç”Ÿæ­§ä¹‰çš„å‰æä¸‹ï¼Œ`..` å°†è‡ªåŠ¨æ‰©å±•ä¸ºæ‰€éœ€è¦çš„å€¼çš„æ•°é‡ï¼š

```rust
fn main() {
    let arr = (2, 4, 8, 16, 32);
    match arr {
        (first, .., last) => {
            println!("first={first}, last={last}");
        }
    }
}
```

### åŒ¹é…å®ˆå«æä¾›çš„é¢å¤–æ¡ä»¶

**åŒ¹é…å®ˆå«**(match guard) æ˜¯ `match` çš„æ¨¡å¼åˆ†æ”¯å†…é¢å¤–çš„ `if`ï¼Œè¿›é—¨ï¼ˆåŒ¹é… `match` åˆ†æ”¯ï¼‰åï¼Œè¿˜è¦é€šè¿‡å®ˆå«çš„æ£€æŸ¥ï¼ˆæ»¡è¶³ `if`ï¼‰ï¼Œæ‰èƒ½æ‰§è¡Œåˆ†æ”¯ï¼š

```rust
let num = Some(4);
match num {
	Some(x) if x % 2 == 0 => println!("{x} is even"),
	Some(x) => println!("{x} is odd"),
	None => (),
}
```

ä¹Ÿå¯ä»¥åŒæ—¶ä½¿ç”¨ `|` æŒ‡å®šå¤šä¸ªæ¨¡å¼ï¼š

```rust
let x = 4;
let y = false;
match x {
	4 | 5 | 6 if y => println!("yes"),
	_ => println!("no"),
}
```

### `@` ç»‘å®š

`@`ï¼šåˆ›å»ºä¸€ä¸ªå­˜æ”¾å€¼çš„å˜é‡çš„åŒæ—¶æµ‹è¯•å…¶å€¼æ˜¯å¦åŒ¹é…æ¨¡å¼ã€‚

```rust
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };
    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Id in [3,7]: {id_variable}"),
        Message::Hello { id: 10..=12 } => {
            println!("Id is in [10,12]")
        }
        Message::Hello { id } => println!("Invalid Id: {id}"),
    }
}
```

`id_variable` çš„å‘½åæ˜¯ä¸ºäº†æ¼”ç¤ºç”¨ï¼Œå…¶å®å®ƒå¯ä»¥ä¸å­—æ®µ `id` åŒåã€‚

ğŸ‘‰ [[17 é«˜çº§ç‰¹å¾]]