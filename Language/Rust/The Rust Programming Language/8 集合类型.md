ğŸ‘ˆ [[7 æ³›å‹å’Œç‰¹å¾]]

## å­—ç¬¦ä¸² `String`

`String` è¢«å®ç°ä¸ºä¸€ä¸ªå¸¦æœ‰ä¸€äº›é¢å¤–ä¿è¯ã€é™åˆ¶å’ŒåŠŸèƒ½çš„ `Vec<u8>` çš„å°è£…ã€‚

åˆ›å»ºï¼š

```rust
// new()
let s = String::new();

// from()
let s = String::from("Rust");

// to_string()
let s = "Rust".to_string();
```

é™„åŠ ï¼š

```rust
// push_str()
// æ¥æ”¶ &str, ä¸ç§»åŠ¨æ‰€æœ‰æƒ
let mut s = String::from("R");
s.push_str("us"); // "Rus"

// push()
// æ¥æ”¶ char
s.push('t'); // "Rust"
```

æ‹¼æ¥ï¼š

```rust
// + è¿ç®—ç¬¦
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // s1 è¢«ç§»åŠ¨, ä¸èƒ½ç»§ç»­ä½¿ç”¨
// + é‡è½½äº† String::add:
fn add(self, s: &str) -> String {
// è°ƒç”¨æ—¶, &s2 ç”± &String å¼ºè½¬ä¸º &str

// format! å®
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let ttt = format!("{s1}-{s2}-{s3}");
```

éå†ï¼š

```rust
// chars()
for c in "Rust".chars()

// bytes()
for b in "Rust".bytes()
```

## åŠ¨æ€æ•°ç»„ `Vector`

### åˆ›å»º

åŠ¨æ€æ•°ç»„ç±»å‹ä¸º `Vec<T>`ï¼š

```rust
let v: Vec<i32> = Vec::new();
```

åœ¨è¿™é‡Œæ˜¾å¼åœ°æ ‡æ³¨äº† `i32`ï¼Œå› ä¸ºä» `Vec:new()` æ— æ³•æ¨æ–­å…ƒç´ ç±»å‹ï¼Œä¸è¿‡å¯ä»¥åœ¨åˆ›å»ºåå‘å…¶ä¸­åŠ å…¥å…ƒç´ ä»¥çœå»ç±»å‹æ ‡æ³¨ï¼š

```rust
let mut v = Vec::new();
v.push(1);
```

å¦‚æœé¢„å…ˆçŸ¥é“å…ƒç´ ä¸ªæ•°ï¼Œå¯ä»¥è°ƒç”¨ `Vec::with_capacity(capacity)`ï¼Œæå‡æ€§èƒ½ã€‚

è¿˜å¯ä»¥ç”¨å® `vec!` åˆ›å»ºï¼Œè¿™ç§æ–¹å¼å¯ä»¥æ¥å—åˆå§‹å€¼ï¼ŒåŒæ—¶ä¹Ÿæ— éœ€æ ‡æ³¨ç±»å‹ï¼š

```rust
let v = vec![1, 2, 3];
```

### è®¿é—®

è®¿é—®å…ƒç´ æ—¶ï¼Œå¯ä»¥ç”¨ç´¢å¼•æˆ–è€… `get`ï¼š

```rust
let v = vec![1, 2, 3];

// ç´¢å¼•
let rval: &i32 = &v[1];

// get
match v.get(1) {
	Some(val) => println!("v[1] = {val}"),
	None => println!("v[1] does not exist"),
}
// æˆ–è€…
let some_num = v.get(1).unwrap();
```

| æ–¹å¼ | è¶Šç•Œæ—¶ | è§£æ„ |
| ---- | ---- | ---- |
| ç´¢å¼• | `panic` | æ— éœ€ |
| `get` | å¾—åˆ° `None` | éœ€è¦ |

åœ¨ç´¢å¼•å¯èƒ½è¶Šç•Œæ—¶ï¼Œåº”ä½¿ç”¨ `get` è®¿é—®ï¼Œå¦åˆ™åº”ä½¿ç”¨æ€§èƒ½æ›´å¥½çš„ç´¢å¼•è®¿é—®ã€‚

### å€Ÿç”¨

```rust
let mut v = vec![1, 2, 3];
let first = &v[0];
v.push(4);
println!("v[0]={}", first);
```

è¿™æ®µä»£ç æ— æ³•è¿‡ç¼–ï¼š

```text
let first = &v[0];
            - immutable borrow occurs here

v.push(4);
^^^^^^^^^ mutable borrow occurs here

println!("v[0]={}", first);
                    ----- immutable borrow later used here
```

è§£é‡Šå¦‚ä¸‹ï¼š

```rust
let mut v = vec![1, 2, 3];
let first = &v[0]; // ä¸å¯å˜å€Ÿç”¨ // ok
v.push(4); // å¯å˜å€Ÿç”¨ // ok
println!("v[0]={}", first); // å†æ¬¡ä½¿ç”¨ä¸å¯å˜å€Ÿç”¨ // not ok
```

è¿™æ ·è®¾è®¡æ˜¯æœ‰é“ç†çš„ï¼šæ•°ç»„çš„å¤§å°æ˜¯å¯å˜çš„ï¼Œå½“æ—§æ•°ç»„çš„å¤§å°ä¸å¤Ÿç”¨æ—¶ï¼ŒRust ä¼šé‡æ–°åˆ†é…ä¸€å—æ›´å¤§çš„å†…å­˜ç©ºé—´ï¼Œç„¶åæŠŠæ—§æ•°ç»„æ‹·è´è¿‡æ¥ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œä¹‹å‰çš„å¼•ç”¨ä¼šæŒ‡å‘ä¸€å—æ— æ•ˆçš„å†…å­˜ã€‚

> åœ¨é•¿å¤§ä¹‹åï¼Œæˆ‘ä»¬æ„Ÿæ¿€äººç”Ÿè·¯ä¸Šé‡åˆ°è¿‡çš„ä¸¥å¸ˆç›Šå‹ï¼Œæ­£æ˜¯å› ä¸ºä»–ä»¬ï¼Œæˆ‘ä»¬æ‰åœ¨æ­£ç¡®çš„é“è·¯ä¸Šä¸æ–­å‰è¡Œï¼Œè™½ç„¶åœ¨é‚£ä¸ªæ—¶å€™ï¼Œå¹¶ä¸èƒ½ç†è§£ä»–ä»¬ã€‚è€Œ Rust å°±å¦‚é‚£ä¸ªè‰¯å¸ˆç›Šå‹ï¼Œå®ƒä¸æ–­çš„åœ¨çº æ­£æˆ‘ä»¬ä¸å¥½çš„ç¼–ç¨‹ä¹ æƒ¯ï¼Œç›´åˆ°æŸä¸€å¤©ï¼Œä½ å‘ç°è‡ªå·±èƒ½å†™å‡ºä¸€æ¬¡æ€§é€šè¿‡çš„æ¼‚äº®ä»£ç æ—¶ï¼Œå°±èƒ½æ˜ç™½å®ƒçš„è‰¯è‹¦ç”¨å¿ƒã€‚

### è¿­ä»£éå†

å¯¹ `Vector` çš„è¿­ä»£éå†æ›´åŠ å®‰å…¨ã€é«˜æ•ˆï¼š

```rust
let mut v = vec![1, 2, 3];

// ä¸å¯å˜è¿­ä»£éå†
for x in &v {
	// ...
}

// å¯å˜è¿­ä»£éå†
for x in &mut v {
	*x += 10;
	// ...
}
```

### å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ 

æšä¸¾å®ç°ï¼š

```rust
#[derive(Debug)]

enum IpAddr {
    V4(String),
    V6(String),
}

fn main() {
    let ips = vec![
        IpAddr::V4("127.0.0.1".to_string()),
        IpAddr::V6("::1".to_string()),
    ];
    for ip in ips {
        display_ip(ip)
    }
}

fn display_ip(ip: IpAddr) {
    println!("{:?}", ip);
}
```

å°† `V4`ã€`V6` ç±»å‹çš„å…ƒç´ å­˜å‚¨åœ¨æšä¸¾ `IpAddr` ä¸­ï¼Œå†å°†æšä¸¾çš„å®ä¾‹å­˜å‚¨åœ¨åŠ¨æ€æ•°ç»„ `ips` ä¸­ã€‚

ç‰¹å¾å¯¹è±¡å®ç°ï¼š

```rust
trait IpAddr {
    fn display(&self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&self) {
        println!("ipv4: {:?}", self.0)
    }
}

struct V6(String);
impl IpAddr for V6 {
    fn display(&self) {
        println!("ipv6: {:?}", self.0)
    }
}

fn main() {
    let ips: Vec<Box<dyn IpAddr>> = vec![
        Box::new(V4("127.0.0.1".to_string())),
        Box::new(V6("::1".to_string())),
    ];
    for ip in ips {
        ip.display();
    }
}
```

ä¸ºç»“æ„ä½“ `V4` å’Œ `V6` å®ç°ç‰¹å¾ `IpAddr`ï¼Œ`ips` çš„å…ƒç´ ç±»å‹ä¸º `Box<dyn IpAddr>`ï¼Œæ„ä¸ºç”¨ `Box` åŒ…è£¹çš„ç‰¹å¾ `IpAddr` å¯¹è±¡ã€‚

ç‰¹å¾å¯¹è±¡åŠ¨æ€æ•°ç»„æ›´çµæ´»ï¼Œä¹Ÿæ›´å¸¸è§ã€‚

### æ’åº

Rust çš„åº“ä¸­æœ‰ä¸¤ç§æ’åºï¼šç¨³å®šçš„ `sort`ã€`sort_by`ï¼Œä¸ç¨³å®šçš„ `sort_unstable`ã€`sort_unstable_by`ã€‚

ç¨³å®šæ’åºçš„ç¼ºç‚¹åœ¨äºéœ€è¦é¢å¤–åˆ†é…åŸæ•°ç»„ä¸€åŠå¤§å°çš„ç©ºé—´ï¼Œä¸”é€Ÿåº¦æ›´æ…¢ã€‚

å¯¹ `Vec<i32>` æ’åºï¼š

```rust
let mut i32s = vec![1, 10, 4, 7];
i32s.sort_unstable();
assert_eq!(i32s, vec![1, 4, 7, 10]); // success
```

ç±»ä¼¼åœ°ï¼Œå°è¯•å¯¹ `Vec<f32>` æ’åºï¼š

```rust
// not ok
let mut f32s = vec![1.3, 8.9, 4.5, 7.2];
f32s.sort_unstable();
assert_eq!(f32s, vec![1.3, 4.5, 7.2, 8.9]); // fail
```

æ— æ³•è¿‡ç¼–ï¼Œå› ä¸º `f32` æœ‰ç‰¹æ®Šå€¼ `NAN`ï¼Œæ— æ³•ä¸å…¶ä»–å€¼æ¯”è¾ƒï¼Œå› æ­¤ `f32` å®ç°çš„æ˜¯éƒ¨åˆ†å¯æ¯”è¾ƒçš„ç‰¹æ€§ `PartialOrd`ï¼Œä½†æ’åºè¦æ±‚å®ç°å…¨éƒ¨å¯æ¯”è¾ƒçš„ç‰¹æ€§ `Ord`ã€‚

éœ€è¦æ”¹ä¸ºä½¿ç”¨ `partial_cmp`ï¼š

```rust
let mut f32s = vec![1.0, 5.6, 10.3, 2.0, 15f32];    
f32s.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());    
assert_eq!(f32s, vec![1.0, 2.0, 5.6, 10.3, 15f32]); // success
```

å¯¹ `Vec<struct>` æ’åºï¼š

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn new(name: String, age: u32) -> Person {
        Person { name, age }
    }
}

fn main() {
    let mut people = vec![
        Person::new("Zoe".to_string(), 25),
        Person::new("Al".to_string(), 60),
        Person::new("John".to_string(), 1),
    ];
    // è‡ªå®šä¹‰æŒ‰å¹´é¾„å€’åºæ’åº
    people.sort_unstable_by(|a, b| b.age.cmp(&a.age));
    println!("{:?}", people);
}
```

å¦‚æœä¸º `Person` å®ç° `Ord` ç‰¹æ€§ï¼Œå°±æ— éœ€è‡ªå®šä¹‰æ’åºäº†ã€‚å®ç° `Ord` éœ€è¦å®ç° `Ord`ã€`Eq`ã€`PartialOrd`ã€`PartialEq` è¿™äº›å±æ€§ï¼Œä½†å®ƒä»¬éƒ½å¯ä»¥ `derive`ï¼š

```rust
#[derive(Debug, Ord, Eq, PartialOrd, PartialEq)]
struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn new(name: String, age: u32) -> Person {
        Person { name, age }
    }
}

fn main() {
    let mut people = vec![
        Person::new("Zoe".to_string(), 25),
        Person::new("Al".to_string(), 60),
        Person::new("Al".to_string(), 30),
        Person::new("John".to_string(), 1),
        Person::new("John".to_string(), 25),
    ];
    people.sort_unstable();
    println!("{:?}", people);
}
```

## å“ˆå¸Œè¡¨ `HashMap`

### åˆ›å»º

#### ä½¿ç”¨ `new()` åˆ›å»º

ä¸åŒäº `String` æˆ– `Vec` ç­‰ï¼Œ`HashMap` æ²¡æœ‰åŒ…å«åœ¨ `prelude` ä¸­ï¼Œéœ€è¦æ‰‹åŠ¨å¼•å…¥ã€‚

```rust
use std::collections::HashMap; // å¼•å…¥

// åˆ›å»º HashMap
let mut gems = HashMap::new();

// å¡«å…¥é”®å€¼å¯¹
gems.insert("ruby", 1);
gems.insert("emerald", 2);
gems.insert("wastestone", 18);
```

#### ä½¿ç”¨è¿­ä»£å™¨å’Œ `collect()` åˆ›å»º

è®¾æƒ³æœ‰ä¸€ä¸ª `Vec<(String, u32)>` å­˜å‚¨äº†çƒé˜Ÿåç§°ä¸å¾—åˆ†çš„å…ƒç»„ï¼Œç°éœ€è¦å°†å…¶å†™å…¥ä¸€ä¸ª `HashMap<String, u32>`ã€‚

å¯ä»¥è¿™æ ·æ‰‹å†™ï¼š

```rust
let mut teams_map = HashMap::new();
for team in &teams_list {
	teams_map.insert(&team.0, team.1);
}
```

è¿™å¾ˆä¸ Rustyï¼Œå¯ä»¥æ”¹ç”¨ `collect`ï¼š

```rust
let teams_map: HashMap<_, _> = teams_list.into_iter().collect();
```

`into_iter()` å°†åˆ—è¡¨è½¬æ¢ä¸ºè¿­ä»£å™¨ï¼Œå†ç”¨ `collect()` æ”¶é›†ï¼Œåè€…å®é™…ä¸Šæ”¯æŒç”Ÿæˆå¤šç§ç›®æ ‡ç±»å‹çš„é›†åˆï¼Œå› æ­¤éœ€è¦æ˜¾å¼åœ°å°† `teams_map` æ ‡æ³¨ä¸º `HashMap<_,_>`ï¼Œè¡¨ç¤ºéœ€è¦ä¸€ä¸ª `HashMap`ï¼Œå¦åˆ™ä¼šå‡ºé”™ï¼š

```text
error[E0282]: type annotations needed

let teams_map = teams_list.into_iter().collect();
    ^^^^^^^^^

help: consider giving `teams_map` an explicit type
```

### æ‰€æœ‰æƒè½¬ç§»

è§„åˆ™æ˜¯ç›¸åŒçš„ï¼Œå°†ä¸€ä¸ªæœªå®ç° `Copy` ç‰¹å¾çš„å˜é‡ä¼ å…¥ `HashMap` åï¼Œæ‰€æœ‰æƒè¢«è½¬ç§»ã€‚

```rust
let name = String::from("Sunface");
let age = 18;
let mut handsome_boys = HashMap::new();
handsome_boys.insert(name, age);
println!("{name}"); // not ok
```

å¦‚æœåœ¨ `HashMap` ä¸­ä½¿ç”¨å¼•ç”¨ç±»å‹ï¼Œè¦ç¡®ä¿è¯¥å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸çŸ­äºå“ˆå¸Œè¡¨ï¼š

```rust
let name = String::from("Sunface");
let age = 18;
let mut handsome_boys = HashMap::new();
handsome_boys.insert(&name, age);
std::mem::drop(name); // not ok // åæ–‡ä¸­å†æ¬¡å€Ÿç”¨
println!("{:?}", handsome_boys);
```

### è®¿é—®

ç”¨ `get()` è®¿é—®å…ƒç´ ï¼š

```rust
let mut gems = HashMap::new();
gems.insert("ruby", 1);
gems.insert("emerald", 2);
let rubies: Option<&i32> = gems.get("ruby");
```

ç”¨ `&i32` å€Ÿç”¨ `value`ï¼Œé˜²æ­¢æ‰€æœ‰æƒè½¬ç§»ã€‚

ä¹Ÿå¯ä»¥ç›´æ¥è·å¾—å€¼ç±»å‹ï¼š

```rust
let rubies: i32 = gems.get("ruby").copied().unwrap_or(0);
```

`copied()` é€šè¿‡å¤åˆ¶å†…å®¹å°† `Option<&T>` è½¬æ¢ä¸º `Option<T>`ï¼Œ`unwrap_or()` è§£æ„ `Option<T>`ï¼Œå¦‚æœå¾—åˆ° `None`ï¼Œå°±è¿”å›æŒ‡å®šçš„é»˜è®¤å€¼ `0`ã€‚

ç”¨ `for-in` éå† `HashMap`ï¼š

```rust
for (gem, cnt) in &gems {
	// ...
}
```

### æ›´æ–°

```rust
let mut gems = HashMap::new();
gems.insert("ruby", 1);
gems.insert("emerald", 2);

// æ›´æ–°, åŒæ—¶è¿”å›æ—§å€¼
let rubies_old = gems.insert("ruby", 6);
// rubies_old == Some(1)

// æŸ¥è¯¢, ä¸å­˜åœ¨æ—¶æ’å…¥
let sapphires = gems.entry("sapphire").or_insert(0);
// *sapphires == 0
let emeralds = gems.entry("emerald").or_insert(1);
// *emeralds == 2
```

`or_insert()` è¿”å› `&mut v` å¼•ç”¨ï¼Œå¯ä»¥é€šè¿‡è¯¥å¯å˜å¼•ç”¨ç›´æ¥ä¿®æ”¹ `HashMap` ä¸­å¯¹åº”çš„å€¼ï¼Œä¾‹å¦‚ï¼š

```rust
let cnt = gems.entry("ruby").or_insert(0);
*cnt += 1; // gems[ruby] == 1
```

è¦å¯¹ `cnt` å…ˆè§£å¼•ç”¨å†æ›´æ–°ï¼Œå¦åˆ™ç±»å‹ä¸åŒ¹é…ã€‚ç­‰ä»· Java ä»£ç ï¼š

```java
map.merge(key, 1, Integer::sum);
```

### å“ˆå¸Œå‡½æ•°

ä¸€ä¸ªç±»å‹èƒ½å¦ä½œä¸º `key` çš„å…³é”®åœ¨äºèƒ½å¦è¿›è¡Œç›¸ç­‰æ¯”è¾ƒï¼ˆèƒ½å¦ç¡®è®¤ç›¸åŒå’ŒåŒºåˆ†ä¸åŒï¼‰ï¼Œå¯¹åº”çš„ç‰¹å¾ä¸º `std::cmp::Eq`ã€‚

> `f32` å’Œ `f64` ç”±äº `NAN` çš„å­˜åœ¨ï¼Œæ²¡æœ‰å®ç° `std::cmp::Eq`ï¼Œå› æ­¤æ— æ³•ä½œä¸º `key`ã€‚

å“ˆå¸Œå†²çªè¶Šå°‘ï¼Œå“ˆå¸Œå‡½æ•°è¶Šå®‰å…¨ã€‚

ç›®å‰ï¼Œ`HashMap` ä½¿ç”¨çš„å“ˆå¸Œå‡½æ•°æ˜¯ `SipHash`ï¼Œå®ƒçš„æ€§èƒ½ä¸€èˆ¬ï¼Œè€Œå®‰å…¨æ€§å¾ˆå¥½ã€‚å®ç°ç®—æ³•æ—¶ï¼Œå¯ä»¥è€ƒè™‘æ€§èƒ½æ›´å¥½çš„å“ˆå¸Œå‡½æ•°ï¼Œä¾‹å¦‚ `ahash`ã€‚

ğŸ‘‰ [[9 ç”Ÿå‘½å‘¨æœŸ]]