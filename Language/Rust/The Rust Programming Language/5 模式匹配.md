ğŸ‘ˆ [[4 æµç¨‹æ§åˆ¶]]

### `match` å’Œ `if let`

#### `match` åŒ¹é…

`match` çš„é€šç”¨å½¢å¼ï¼š

```rust
match tar {
	æ¨¡å¼ 1 => è¡¨è¾¾å¼ 1, // å•æ¡è¡¨è¾¾å¼
	æ¨¡å¼ 2 => { // è¡¨è¾¾å¼å—
		è¯­å¥ 1;
		è¯­å¥ 2;
		è¡¨è¾¾å¼ 2
	},
	_ => è¡¨è¾¾å¼ 3 // ç”¨ _ æŒ‡ä»£é»˜è®¤æƒ…å†µ
}
```

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dir = Direction::South;
    match dir {
        Direction::East => println!("East"),
        Direction::North | Direction::South => { // åŒ¹é…å¤šä¸ªæ¨¡å¼
            println!("South / North");
        },
        _ => println!("West"),
    };
}
```

ç”¨ `match` åŒ¹é…æšä¸¾ç±»å‹æ—¶ï¼š

- æ‰€æœ‰åˆ†æ”¯éœ€è¦å®Œå…¨è¦†ç›–æšä¸¾å˜é‡çš„æ‰€æœ‰æˆå‘˜ç±»å‹ã€‚
- ç”¨é€šé…ç¬¦ `_` è¡¨ç¤ºæœªåˆ—å‡ºçš„å…¶ä»–æ¨¡å¼ã€‚
- åœ¨åŒä¸€åˆ†æ”¯ä¸­å¯ä»¥ç”¨ `|` åŒ¹é…å¤šä¸ªæ¨¡å¼ã€‚
- æ¯ä¸ªåˆ†æ”¯å¿…é¡»è¿”å›ä¸€ä¸ªè¡¨è¾¾å¼ç»“æœï¼Œä¸”ç±»å‹å¿…é¡»ç›¸åŒã€‚

`match` æœ¬èº«ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼Œå¯ç”¨äºèµ‹å€¼è¯­å¥ï¼š

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip = IpAddr::Ipv6;
    let my_ip = match ip {
        IpAddr::Ipv4 => "127.0.0.1",
        IpAddr::Ipv6 => "::1",
    };
    println!("{my_ip}");
}
```

ä¹Ÿå¯ç”¨äºå‡½æ•°è¿”å›å€¼ï¼š

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

å¯¹äºæšä¸¾ `Coin`ï¼Œ25 ç¾åˆ†ç¡¬å¸ä¸Šæœ‰å„ç§å·çš„å›¾æ¡ˆï¼Œå¯å°†æšä¸¾ `UsState` ç»‘å®šåˆ° `Coin::Quarter` æˆå‘˜ï¼Œç§°ä¸ºæ¨¡å¼ç»‘å®šï¼š

```rust
enum UsState {
    Alabama,
    Alaska,
    // ...
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // quarter ç‰¹æœ‰ä¸åŒçš„å·å›¾æ¡ˆ
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => { // ç”¨ state åŒ¹é… UsState å®ä¾‹
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```

æ›´å¤æ‚çš„ä¾‹å­ï¼š

```rust
enum Action {
    Note(String),
    MoveTo(i32, i32),
    SetColor(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Note("Match!".to_string()),
        Action::MoveTo(1, 2),
        Action::SetColor(255, 255, 0),
    ];
    for action in actions {
        match action {
            Action::Note(s) => {
                println!("{s}");
            }
            Action::MoveTo(x, y) => {
                println!("point moved to ({x}, {y})");
            }
            Action::SetColor(r, g, _) => {
                println!("set color to '(r:{r}, g:{g}, b:0)', 'b' has been ignored");
            }
        }
    }
}
```

æœ‰äº›æ¨¡å¼ä¸é‡è¦ï¼Œä½†åˆå¿…é¡»è¦†ç›–ï¼Œå¯ä»¥ä½¿ç”¨é€šé…æ¨¡å¼æˆ– `_` å ä½ç¬¦ï¼š

```rust
// é€šé…æ¨¡å¼: åŒ¹é…ä»»ä½•å€¼å¹¶ä½¿ç”¨
let difficulty = 3;
match difficulty {
	1 => println!("Easy~"),
	2 => println!("Hard!"),
	other => println!("{other} is not valid"),
};

// _ å ä½ç¬¦: åŒ¹é…ä»»ä½•å€¼å¹¶ä¸¢å¼ƒ
let difficulty = 3;
match difficulty {
	1 => println!("Easy~"),
	2 => println!("Hard!"),
	_ => println!("not valid"),
};
```

#### `if let` åŒ¹é…

åªæƒ³åŒ¹é…ä¸€ç§æ¨¡å¼æ—¶ï¼Œä½¿ç”¨ `match` å°†æ¯”è¾ƒå¤æ‚ï¼š

```rust
let v = Some(3u8);
match v {
	Some(3) => println!("v = 3"),
	_ => (),
};
```

è€Œä½¿ç”¨ `if let` åˆ™ç®€æ´ä¸€äº›ï¼š

```rust
let v = Some(3u8);
if let Some(3) = v {
	println!("v = 3");
}
```

`if let` æ˜¯ `match` åœ¨åªå¸Œæœ›åŒ¹é…ä¸€ç§æ¨¡å¼ä¸‹çš„è¯­æ³•ç³–ï¼š

```rust
// match
let config_max = Some(3u8);
match config_max {
	Some(max) => println!("The maximum is configured to be {max}"),
	_ => (),
}

// ç­‰ä»·çš„ if let
let config_max = Some(3u8);
if let Some(max) = config_max {
	println!("The maximum is configured to be {max}");
}
```

`if let` åå¯ä»¥è·Ÿ `else`ï¼š

```rust
for coin in coins.iter() {
	if let Coin::Quarter(state) = coin {
		println!("State quarter from {:?}!", state);
	} else {
		println!("Not a quarter");
	}
}
```

åœ¨ç®€å•çš„ä¾‹å­ä¸­ï¼Œç”¨ `if` è¯­å¥æ›´åˆé€‚ï¼š

```rust
let v = Some(3u8);
if v == Some(3) {
	println!("v = 3");
}
```

ä¸è¿‡è§£æ„æ›´å¤æ‚çš„æƒ…å†µæ‰æ˜¯ `if let` çš„ç”¨æ­¦ä¹‹åœ°ï¼š

```rust
enum Result {
    Success(i32),
    Failure(String),
}

fn main() {
    let res = Result::Success(123);
    if let Result::Success(val) = res {
        println!("Operation succeeded with value: {val}");
    } else {
        println!("Operation failed.");
    }
}
```

`match` å’Œ `if let` çš„é€‰æ‹©ï¼šå¦‚æœåªæƒ³è¦åŒ¹é…ä¸€ä¸ªæ¡ä»¶è€Œå¿½ç•¥å…¶ä½™æ¡ä»¶ï¼Œä½¿ç”¨ `if let`ï¼Œå¦åˆ™ä½¿ç”¨ `match`ã€‚

#### `matches!` å®

`matches!` å®å°†ä¸€ä¸ªè¡¨è¾¾å¼ä¸æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œè¿”å›ä¸€ä¸ª `bool` è¡¨ç¤ºåŒ¹é…ç»“æœã€‚

```rust
enum MyEnum {
    Foo,
    Bar,
}

fn main() {
    let v = vec![MyEnum::Foo, MyEnum::Bar, MyEnum::Foo];
}
```

ç°éœ€è¦å¯¹ `v` è¿›è¡Œè¿‡æ»¤ï¼Œåªä¿ç•™ç±»å‹ä¸º `MyEnum::Foo` çš„å…ƒç´ ï¼š

```rust
// not ok
v.iter().filter(|x| x == MyEnum::Foo);
```

è¿™æ˜¯ä¸æ­£ç¡®çš„ï¼Œåº”è¯¥ä½¿ç”¨ `matches!` å®ï¼š

```rust
// ok
v.iter().filter(|x| matches!(x, MyEnum::Foo));
```

æ›´å¤šç¤ºä¾‹ï¼š

```rust
let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z')); // success

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2)); // success
```

### è§£æ„ `Option`

`Option` çš„å®šä¹‰ï¼š

```rust
enum Option<T> {
	Some(T),
	None,
}
```

ä¸€ä¸ª `Option` å®ä¾‹è¦ä¹ˆæœ‰å€¼ `Some(T)`ï¼Œè¦ä¹ˆä¸ºç©º `None`ã€‚

ä½¿ç”¨ `Option<T>` çš„æ„ä¹‰æ˜¯ä» `Some` ä¸­å–å‡º `T` å€¼ï¼Œæˆ–è€…å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µã€‚

```rust
fn main() {
	let five = Some(5);
	let six = plus_one(five); // Some(6)
	let none = plus_one(None); // None
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
	    Some(i) => Some(i + 1),
        None => None,
    }
}
```

`plus_one` æ¥æ”¶ä¸€ä¸ª `Option<i32>`ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Option<i32>`ï¼š

- å¦‚æœä¼ å…¥ä¸€ä¸ª `Some(i32)`ï¼Œåˆ™é€šè¿‡ `match` å°†å…¶ä¸­çš„å€¼ç»‘å®šåˆ° `i`ï¼Œå†è¿”å› `Some` åŒ…è£¹çš„ `i+1`ã€‚
- å¦‚æœä¼ å…¥ä¸€ä¸ª `None`ï¼Œåˆ™ç›´æ¥è¿”å›ä¸€ä¸ª `None`ã€‚

### æ¨¡å¼é€‚ç”¨åœºæ™¯

- `match` åˆ†æ”¯
- `if let` åˆ†æ”¯
- `while let` æ¡ä»¶å¾ªç¯
- `for` å¾ªç¯
- `let` è¯­å¥
- å‡½æ•°å‚æ•°

#### `while let` æ¡ä»¶å¾ªç¯

ç±»ä¼¼äº `if let`ï¼Œä¸è¿‡åªè¦æ¨¡å¼ä¸€ç›´åŒ¹é…å°±ä¿æŒå¾ªç¯ã€‚

```rust
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() { // å¼¹å®Œå³æ­¢
    println!("{top}");
}
```

#### å‡½æ•°å‚æ•°

å‚æ•°å³ä¸ºæ¨¡å¼ï¼Œè¿˜å¯ä»¥åœ¨å‚æ•°ä¸­åŒ¹é…å…ƒç»„ï¼š

```rust
fn print_point(&(x, y): &(i32, i32)) {
	println!("({x}, {y})");
}
```

### å…¨æ¨¡å¼åˆ—è¡¨

å‚è€ƒï¼š[å…¨æ¨¡å¼åˆ—è¡¨](https://course.rs/basic/match-pattern/all-patterns.html)ã€‚

ğŸ‘‰ [[6 æ–¹æ³•]]