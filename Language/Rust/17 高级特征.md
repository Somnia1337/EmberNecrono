ğŸ‘ˆ [[16 æ¨¡å¼ä¸æ¨¡å¼åŒ¹é…]]

## `unsafe` Rust

ç¼–è¯‘å™¨æœ‰æ—¶ç¼ºä¹å¿…è¦çš„ä¿¡æ¯ï¼Œä¼šæ‹’ç»å®é™…å®‰å…¨çš„ä»£ç ï¼Œä½¿ç”¨ **`unsafe` Rust** å°†ç¦ç”¨ç¼–è¯‘å™¨çš„éƒ¨åˆ†æ£€æŸ¥æœºåˆ¶ï¼Œä»è€Œä½¿ä»£ç è¿‡ç¼–ã€‚

### `unsafe` çš„è¶…èƒ½åŠ›

å…³é”®å­— `unsafe` ç¦ç”¨çš„ç¼–è¯‘å™¨æ£€æŸ¥ï¼š

- è§£å¼•ç”¨è£¸æŒ‡é’ˆ
- è°ƒç”¨ä¸å®‰å…¨å‡½æ•°æˆ–æ–¹æ³•
- è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡
- å®ç°ä¸å®‰å…¨ trait
- è®¿é—®Â `union`Â çš„å­—æ®µ

è¿™ 5 ç±»æ“ä½œå¿…é¡»ä½äºæ ‡è®°ä¸º `unsafe` çš„å—ä¸­ï¼Œä¿æŒå®ƒå°½å¯èƒ½å°ï¼Œè¿™å°†æ–¹ä¾¿é”™è¯¯çš„æ’æŸ¥ã€‚

### è§£å¼•ç”¨è£¸æŒ‡é’ˆ

unsafe Rust çš„ **è£¸æŒ‡é’ˆ**(raw pointer) æ˜¯ç±»ä¼¼äºå¼•ç”¨çš„ç±»å‹ï¼Œä¸å¯å˜ä¸å¯å˜å½¢å¼åˆ†åˆ«å†™ä¸º `*const T`ã€`*mut T`ï¼Œå…¶ä¸­ `*` ä¸æ˜¯è§£å¼•ç”¨è¿ç®—ç¬¦ï¼Œè€Œæ˜¯ç±»å‹åç§°çš„ä¸€éƒ¨åˆ†ã€‚

è£¸æŒ‡é’ˆç›¸å½“äºå¼•ç”¨ / æ™ºèƒ½æŒ‡é’ˆçš„ç‰¹æ€§ï¼š

- å…è®¸å¿½ç•¥å€Ÿç”¨è§„åˆ™ï¼Œå¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸å¯å˜å’Œå¯å˜çš„æŒ‡é’ˆï¼Œæˆ–å¤šä¸ªæŒ‡å‘ç›¸åŒä½ç½®çš„å¯å˜æŒ‡é’ˆã€‚
- ä¸ä¿è¯æŒ‡å‘æœ‰æ•ˆçš„å†…å­˜ã€‚
- å…è®¸ä¸ºç©ºã€‚
- ä¸èƒ½å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†åŠŸèƒ½ã€‚

ä»å¼•ç”¨åˆ›å»ºè£¸æŒ‡é’ˆï¼š

```rust
let mut num = 5;
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

è¿™é‡Œæ— éœ€ `unsafe`ï¼Œå› ä¸ºåœ¨å®‰å…¨ä»£ç ä¸­ï¼Œå¯ä»¥åˆ›å»ºè£¸æŒ‡é’ˆï¼Œåªæ˜¯ä¸èƒ½å¯¹å…¶è§£å¼•ç”¨ã€‚

åœ¨ä¸€ä¸ª `unsafe` å—ä¸­è§£å¼•ç”¨è£¸æŒ‡é’ˆï¼š

```rust
unsafe {
	println!("r1={}", *r1);
	println!("r2={}", *r2);
}
```

ä¸è¿‡ï¼Œå¦‚æœå°†è£¸æŒ‡é’ˆæ”¹ä¸ºå¼•ç”¨ï¼š

```rust
let mut num = 5;
let r1 = &num;
let r2 = &mut num;
println!("r1={}", *r1);
println!("r2={}", *r2);
```

æ— æ³•è¿‡ç¼–ï¼Œå› ä¸ºä¸èƒ½åŒæ—¶å­˜åœ¨ä¸å¯å˜å’Œå¯å˜å¼•ç”¨ã€‚

è£¸æŒ‡é’ˆåˆ™å…è®¸è¿™æ ·åšï¼Œé€šè¿‡å¯å˜çš„è£¸æŒ‡é’ˆä¿®æ”¹æ•°æ®æœ‰æ½œåœ¨çš„æ•°æ®ç«äº‰é£é™©ã€‚

è£¸æŒ‡é’ˆçš„ä¸»è¦åº”ç”¨åœºæ™¯ï¼š

- è°ƒç”¨ C ä»£ç çš„æ¥å£ã€‚
- æ„å»ºå€Ÿç”¨æ£€æŸ¥å™¨æ— æ³•ç†è§£çš„å®‰å…¨æŠ½è±¡ã€‚

### è°ƒç”¨ä¸å®‰å…¨å‡½æ•°æˆ–æ–¹æ³•

åœ¨å‡½æ•°/æ–¹æ³•å‰éƒ¨æ·»åŠ  `unsafe` ä»¥åˆ›å»ºä¸€ä¸ªä¸å®‰å…¨çš„å‡½æ•°/æ–¹æ³•ï¼š

```rust
fn main() {
	unsafe {
		dangerous();
	}
}

unsafe fn dangerous() {
	// ...
}
```

æ­¤å¤„çš„ `unsafe` è¡¨æ˜è¯¥å‡½æ•° / æ–¹æ³•å…·æœ‰è°ƒç”¨æ—¶éœ€è¦æ»¡è¶³çš„è¦æ±‚ï¼Œå¿…é¡»é€šè¿‡ `unsafe` å—è°ƒç”¨ä¸€ä¸ª `unsafe` å‡½æ•° / æ–¹æ³•ï¼Œè¡¨æ˜è°ƒç”¨è€…å·²ç»é˜…è¯»äº†è¯¥å‡½æ•° / æ–¹æ³•çš„æ–‡æ¡£ï¼Œå¹¶ä¿è¯æ»¡è¶³äº†è°ƒç”¨è¦æ±‚ã€‚

`unsafe` å‡½æ•° / æ–¹æ³•ä½“ä¹Ÿæ˜¯ `unsafe` å—ï¼Œæ— éœ€å†…ç½®æ›´å¤š `unsafe` å—ã€‚

#### åˆ›å»º `unsafe` ä»£ç çš„å®‰å…¨æŠ½è±¡

ä»…ä»…å› ä¸ºå‡½æ•° / æ–¹æ³•åŒ…å«ä¸å®‰å…¨ä»£ç å¹¶ä¸æ„å‘³ç€å…¶è¦æ•´ä¸ªæ ‡æ³¨ `unsafe`ã€‚

æ ‡å‡†åº“å‡½æ•° `split_at_mut()` è·å–ä¸€ä¸ª slice å¹¶ä»ç»™å®šçš„ç´¢å¼•å¤„å°†å…¶ä¸€åˆ†ä¸ºäºŒï¼š

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];
let r = &mut v[..];
let (a, b) = r.split_at_mut(3);
assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

è¿™ä¸ªå‡½æ•°çš„å®ç°ç”¨åˆ°äº† `unsafe` ç‰¹æ€§ï¼Œç°åœ¨ï¼Œå°è¯•é¿å¼€ `unsafe` å¹¶å®ç°ï¼š

```rust
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    assert!(mid <= len);
    (&mut values[..mid], &mut values[mid..])
}
```

æ— æ³•è¿‡ç¼–ï¼š

```text
error[E0499]: cannot borrow `*values` as mutable more than once at a time
  --> src\main.rs:12:31
   |
9  | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
   |                         - let's call the lifetime of this reference `'1`      
...
12 |     (&mut values[..mid], &mut values[mid..])
   |     --------------------------^^^^^^--------
   |     |     |                   |
   |     |     |                   second mutable borrow occurs here
   |     |     first mutable borrow occurs here
   |     returning this value requires that `*values` is borrowed for `'1`
```

ç¼–è¯‘å™¨ä¸å…è®¸å€Ÿç”¨åŒä¸€ä¸ª slice ä¸¤æ¬¡ï¼Œè™½ç„¶å®é™…ä¸Šè¿™ä¸¤æ¬¡å€Ÿç”¨äº† slice ä¸­å®Œå…¨ä¸é‡å çš„ä¸¤ä¸ªéƒ¨åˆ†ï¼ˆäº‹å®ä¸Šå®‰å…¨ï¼Œå±äºâ€œæˆ‘ä»¬æ¯”ç¼–è¯‘å™¨çŸ¥é“æ›´å¤šæƒ…å†µâ€ï¼‰ã€‚

åªå¥½ç”¨ `unsafe` è®©ç¼–è¯‘å™¨é—­å˜´äº†ï¼š

```rust
use std::slice;

fn main() {
    let mut v = vec![1, 2, 3, 4, 5, 6];
    let r = &mut v[..];
    let (a, b) = split_at_mut(r, 3);
    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);
}

fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();
    assert!(mid <= len);
    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

slice æ˜¯ä¸€ä¸ªæŒ‡å‘ä¸€äº›æ•°æ®çš„æŒ‡é’ˆï¼Œå¹¶å¸¦æœ‰è¯¥ slice çš„é•¿åº¦ï¼Œè°ƒç”¨ `as_mut_ptr()` å°†å…¶è£¸æŒ‡é’ˆå­˜å‚¨åœ¨ `ptr`ã€‚

`unsafe` å—ä¸­è°ƒç”¨äº† `slice::from_raw_parts_mut()` å’Œ `add()`ï¼Œå®ƒä»¬éƒ½æ˜¯ `unsafe` çš„ï¼Œå®ƒä»¬è¦æ±‚çš„å‰ææ˜¯æ¥æ”¶çš„å‚æ•°ï¼ˆè£¸æŒ‡é’ˆï¼Œç´¢å¼•ï¼‰æ˜¯æœ‰æ•ˆçš„ï¼Œè¿™å·²ç»ç”± `assert!(mid <= len)` æ‰‹åŠ¨éªŒè¯äº†ã€‚

#### ä½¿ç”¨ `extern` å‡½æ•°è°ƒç”¨å¤–éƒ¨ä»£ç 

å…³é”®å­— `extern` ç”¨äºåˆ›å»ºå’Œä½¿ç”¨å¤–éƒ¨å‡½æ•°æ¥å£ï¼Œå³å…¶ä»–ç¼–ç¨‹è¯­è¨€çš„å‡½æ•°ã€‚

é›†æˆ C è¯­è¨€æ ‡å‡†åº“ä¸­çš„ `abs()`ï¼š

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    let x = -2;
    unsafe {
        println!("In C, abs({x})={}", abs(x));
    }
}
```

å…¶ä»–è¯­è¨€çš„å®ç°æ— æ³•ç”± Rust æ£€æŸ¥ï¼Œå› æ­¤éƒ½éœ€è¦æ”¾åœ¨ `unsafe` å—ä¸­è°ƒç”¨ï¼Œä¸è¿‡ `extern` æœ¬èº«æ— éœ€æ­é… `unsafe` ä½¿ç”¨ã€‚

### è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡

Rust å…¶å®æ”¯æŒå…¨å±€å˜é‡ï¼Œä¸è¿‡å…¶å¯¹äºæ‰€æœ‰æƒè§„åˆ™å­˜åœ¨é—®é¢˜ï¼šå¦‚æœä¸¤ä¸ªçº¿ç¨‹è®¿é—®åŒä¸€ä¸ªå¯å˜çš„å…¨å±€å˜é‡ï¼Œæ½œåœ¨æœ‰æ•°æ®ç«äº‰ã€‚

å…¨å±€å˜é‡åœ¨ Rust ä¸­ç§°ä¸º **é™æ€**(static) å˜é‡ï¼Œå£°æ˜ä¸€ä¸ªä¸å¯å˜çš„ `PI`ï¼š

```rust
static PI: f64 = 3.14; // å¿…é¡»æ ‡æ³¨ç±»å‹

fn main() {
    println!("Pi = {PI}");
}
```

é™æ€å˜é‡åªèƒ½å­˜å‚¨æ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ï¼Œå› æ­¤ç¼–è¯‘å™¨èƒ½å¤Ÿè‡ªè¡Œè®¡ç®—ç”Ÿå‘½å‘¨æœŸã€‚

è®¿é—®ä¸å¯å˜é™æ€å˜é‡æ˜¯å®‰å…¨çš„ã€‚

åŒºåˆ†é™æ€å˜é‡å’Œå¸¸é‡ï¼š

- ä¸å¯å˜é™æ€å˜é‡çš„å€¼æœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œè€Œå¸¸é‡çš„å€¼å¯ä»¥è¢«å¤åˆ¶ã€‚
- é™æ€å˜é‡å¯ä»¥æ˜¯å¯å˜çš„ï¼ˆå¯å˜é™æ€å˜é‡ï¼‰ï¼Œå¯¹å…¶è®¿é—®å’Œä¿®æ”¹éƒ½æ˜¯ `unsafe` çš„ã€‚

å£°æ˜ä¸€ä¸ªå¯å˜é™æ€å˜é‡ï¼Œéšåè®¿é—®å¹¶ä¿®æ”¹ï¼š

```rust
static mut COUNT: u32 = 0; // æŒ‡æ˜å¯å˜

fn main() {
    add_to_count(3);
    unsafe { // è®¿é—®å¿…é¡»åœ¨ unsafe å—å†…
        println!("COUNT={COUNT}");
    }
}

fn add_to_count(inc: u32) {
    unsafe { // ä¿®æ”¹ä¹Ÿå¿…é¡»åœ¨ unsafe å—å†…
        COUNT += inc;
    }
}
```

```text
COUNT=3
```

è¿™æ®µå•çº¿ç¨‹ä»£ç æ€ä¹ˆçœ‹éƒ½å¾ˆå®‰å…¨ï¼Œä½†åœ¨å¤šçº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­ï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶è¿›è¡Œæ“ä½œæ—¶å¯èƒ½å‡ºé”™ï¼Œå› æ­¤è®¿é—®å’Œä¿®æ”¹çš„ä»£ç å¿…é¡»åœ¨ `unsafe` å—å†…ã€‚

### å®ç°ä¸å®‰å…¨ trait

åœ¨ trait å‰éƒ¨æ·»åŠ  `unsafe` ä»¥åˆ›å»ºä¸€ä¸ªä¸å®‰å…¨ traitï¼š

```rust
unsafe trait Danger {
	// ...
}

unsafe impl Danger for Ous {
	// ...
}
```

å¯¹ä¸å®‰å…¨ trait è¿›è¡Œå®ç°æ—¶ï¼Œä¹Ÿéœ€åœ¨å‰éƒ¨æ·»åŠ  `unsafe`ã€‚

### è®¿é—® `union` çš„å­—æ®µ

`union` ä¸»è¦ç”¨äºä¸ C ä»£ç ä¸­çš„è”åˆä½“äº¤äº’ï¼Œä¹Ÿå±äºä¸å®‰å…¨æ“ä½œã€‚

### ä½•æ—¶ä½¿ç”¨ `unsafe`

è¦å…ˆç¡®ä¿ `unsafe` ä¸­çš„ä»£ç æ˜¯æ­£ç¡®çš„ï¼Œä¸è¿‡ä¸ç®¡æ€ä¹ˆè¯´ï¼Œæ˜¾å¼æ ‡æ³¨ `unsafe` ä½¿å¾—é—®é¢˜å‘ç”Ÿæ—¶æ›´å®¹æ˜“æ’æŸ¥ã€‚

## é«˜çº§ trait

### å…³è”ç±»å‹åœ¨ trait å®šä¹‰ä¸­æŒ‡å®šå ä½ç¬¦ç±»å‹

**å…³è”ç±»å‹**(associated types) æ˜¯ä¸€ä¸ªå°†ç±»å‹å ä½ç¬¦ä¸ trait ç›¸å…³è”çš„æ–¹å¼ï¼Œè¿™æ · trait çš„æ–¹æ³•ç­¾åä¸­å°±å¯ä»¥ä½¿ç”¨è¿™äº›å ä½ç¬¦ç±»å‹ã€‚

æ ‡å‡†åº“æä¾›çš„ `Iterator` trait çš„å®šä¹‰ä¸­å°±æœ‰ä¸€ä¸ªå…³è”ç±»å‹ `Item`ï¼š

```rust
pub trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
}
```

å…³è”ç±»å‹æ˜¯ trait å¥‘çº¦ä¹‹ä¸€ï¼Œå®ç°æ—¶å¿…é¡»æä¾›å…·ä½“ç±»å‹ä»£æ›¿å®ƒã€‚çœ‹èµ·æ¥ç±»ä¼¼äºæ³›å‹ï¼Œä¸º `Counter` struct å®ç° `Iterator`ï¼š

```rust
impl Iterator for Counter {
	type Item = u32;
	
	fn next(&mut self) -> Option<Self::Item> {
		// ...
	}
}
```

çœ‹èµ·æ¥å°±æ˜¯æ³›å‹ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆä¸å¦‚ä¸‹å®šä¹‰ `Iterator`ï¼š

```rust
pub trait Iterator<T> {
	fn next(&mut self) -> Option<T>;
}
```

å¦‚æœæ˜¯è¿™æ ·ï¼Œå‡è®¾æœ‰å¤šä¸ª `impl Iterator for Counter` çš„å®ç°ï¼Œæ¯ä¸ªéƒ½æœ‰æ³›å‹å‚æ•° `T` çš„ä¸åŒçš„å…·ä½“ç±»å‹ï¼Œé‚£ä¹ˆæ¯æ¬¡è°ƒç”¨ `Counter::next()` æ—¶ï¼Œéƒ½è¦æä¾›ç±»å‹æ³¨è§£ä»¥æŒ‡æ˜ä½¿ç”¨çš„å®ç°ã€‚

å¦‚æœé€šè¿‡å…³è”ç±»å‹å®ç° `Iterator`ï¼Œåˆ™æ— éœ€æ¯æ¬¡éƒ½æ ‡æ³¨ç±»å‹ï¼Œå› ä¸ºæ ¹æœ¬æ— æ³•å¤šæ¬¡å®ç° `Iterator`ï¼Œä¹Ÿå³åªèƒ½æœ‰ä¸€ä¸ª `impl Iterator for Counter`ã€‚

### é»˜è®¤æ³›å‹ç±»å‹å‚æ•°å’Œè¿ç®—ç¬¦é‡è½½

ä¸Šä¸ªä»£ç å—ä¸­ï¼Œå¯ä»¥ä¸ºæ³›å‹ç±»å‹å‚æ•°æŒ‡å®šé»˜è®¤å€¼ï¼š

```rust
pub trait Iterator<T = u32> {
    fn next(&mut self) -> Option<T>;
}
```

Rust ä¸å…è®¸åˆ›å»ºè‡ªå®šä¹‰è¿ç®—ç¬¦æˆ–é‡è½½è¿ç®—ç¬¦ï¼Œä¸è¿‡ `std::ops` ä¸­æ‰€åˆ—çš„è¿ç®—ç¬¦å¯ä»¥é€šè¿‡å®ç°å…¶ç›¸å…³çš„ trait è¿›è¡Œé‡è½½ã€‚

ä¸º `Point` struct å®ç° `Add` traitï¼Œé‡è½½ `+`ï¼Œä»¥å®ç°ä¸¤ä¸ª `point` ç›¸åŠ ï¼š

```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;
    
    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```

`Add` trait æœ‰ä¸€ä¸ªå…³è”ç±»å‹ `Output`ï¼Œå†³å®šäº† `add()` çš„è¿”å›å€¼ç±»å‹ï¼š

```rust
trait Add<Rhs = Self> {
    type Output;
    
    fn add(self, rhs: Rhs) -> Self::Output;
}
```

æ³›å‹ç±»å‹å‚æ•° `Rhs`(right hand side) çš„é»˜è®¤å€¼ä¸º `Self`ï¼Œä¸º `Point` å®ç° `Add` æ—¶æ²¡æœ‰æŒ‡å®šæ³›å‹ç±»å‹ï¼Œå› æ­¤é‡‡ç”¨äº†é»˜è®¤å€¼ `Self`ï¼Œæ­¤å³ä¸º `Point`ã€‚

å¦ä¸€ä¸ªä¸é‡‡ç”¨é»˜è®¤å€¼çš„ç¤ºä¾‹ï¼š

```rust
use std::ops::Add;

struct Millimeters(u32);

struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;
    
    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

å°† `Millimeters` ä¸ `Meters` ç›¸åŠ ï¼Œå¹¶æŒ‡å®šç»“æœç±»å‹ä¸º `Meters`ã€‚

### å®Œå…¨é™å®šè¯­æ³•ä¸æ¶ˆæ­§ä¹‰ï¼šè°ƒç”¨ç›¸åŒåç§°çš„æ–¹æ³•

Rust æ—¢æ— æ³•é¿å…ä¸¤ä¸ª trait æ‹¥æœ‰åŒåæ–¹æ³•ï¼Œä¹Ÿæ— æ³•é˜»æ­¢ä¸ºåŒä¸€ç±»å‹åŒæ—¶å®ç°è¿™ä¸¤ä¸ª traitï¼Œç”šè‡³ç›´æ¥åœ¨ç±»å‹ä¸Šå®ç°æœ¬å·²å­˜åœ¨çš„åŒåæ–¹æ³•ä¹Ÿæ˜¯å¯èƒ½çš„ã€‚

è°ƒç”¨è¿™æ ·çš„åŒåæ–¹æ³•æ—¶ï¼Œéœ€è¦æŒ‡å®šå…·ä½“æ˜¯å“ªä¸€ä¸ªï¼š

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Bird;

impl Bird {
    fn fly(&self) {
        println!("A bird can fly, of course!");
    }
}

impl Pilot for Bird {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Bird {
    fn fly(&self) {
        println!("abracadabra!");
    }
}
```

`Pilot` å’Œ `Wizard` ä¸¤ä¸ª trait æœ‰åŒåæ–¹æ³• `fly()`ï¼Œ`Bird` struct å·²ç»äº‹å…ˆå®ç° `fly()`ï¼Œå†ä¸º `Bird` åˆ†åˆ«å®ç°ä¸¤ä¸ª traitã€‚ç°åœ¨ï¼Œå¯¹ `bird` è°ƒç”¨ `fly()`ï¼š

```rust
let bird = Bird;
bird.fly();
```

```text
A bird can fly, of course!
```

ç¼–è¯‘å™¨ä¼šé»˜è®¤è°ƒç”¨ `impl Bird` å—ä¸­çš„ `fly()` å®ç°ã€‚

è¦è°ƒç”¨ `Pilot::fly()` å’Œ `Wizard::fly()`ï¼Œéœ€è¦æŒ‡æ˜ï¼š

```rust
let bird = Bird;
bird.fly();
Pilot::fly(&bird);
Wizard::fly(&bird);
```

```text
A bird can fly, of course!
This is your captain speaking.
abracadabra!
```

è¿™å¯¹äºæ¥æ”¶ `&self` å‚æ•°çš„æ–¹æ³•è¶³å¤Ÿäº†ã€‚

ä½†æ˜¯å‡½æ•°å¹¶ä¸æ¥æ”¶ `&self`ï¼Œå¯¹äºåŒåå‡½æ•°éœ€è¦ä½¿ç”¨å®Œå…¨é™å®šè¯­æ³•ï¼š

```rust
trait Animal {
    fn name() -> String;
}

struct Dog;

impl Dog {
    fn name() -> String {
        String::from("Lucky")
    }
}

impl Animal for Dog {
    fn name() -> String {
        String::from("puppy")
    }
}
```

`Animal` trait æœ‰å‡½æ•° `name()`ï¼Œ`Dog` struct å®ç°äº†åŒåå‡½æ•°ï¼Œåˆå®ç°äº† `Animal::name()`ã€‚

```rust
println!("Here's {} the dog.", Dog::name());
```

```text
Here's Lucky the dog.
```

è¿™æ²¡é—®é¢˜ï¼Œç°åœ¨ï¼Œå°è¯•è°ƒç”¨ `Animal::name()`ï¼š

```rust
println!("A baby dog is often called a {}", Animal::name());
```

æ— æ³•è¿‡ç¼–ï¼š

```text
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --> src\main.rs:21:49
   |
2  |     fn name() -> String;
   |     -------------------- `Animal::name` defined here
...
21 |     println!("A baby dog is often called a {}", Animal::name());
   |                                                 ^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
21 |     println!("A baby dog is often called a {}", <Dog as Animal>::name());     
   |                                                 +++++++       +
```

ç”±äº `Animal::name()` ä¸æ¥æ”¶ `&self`ï¼ŒåŒæ—¶å®ƒå¯èƒ½åŒæ—¶è¢«å…¶ä»–ç±»å‹å®ç°ï¼ŒRust ä¸çŸ¥é“åº”è¯¥è°ƒç”¨å“ªä¸€ä¸ª `Animal::name()` å®ç°ã€‚

ä¸ºäº†æ¶ˆæ­§ä¹‰ï¼Œéœ€è¦æŒ‡å®šè°ƒç”¨çš„æ˜¯ `Dog` çš„ `Animal` å®ç°ï¼š

```rust
println!("Here's {} the dog.", Dog::name());
println!("A baby dog is often called a {}", <Dog as Animal>::name());
```

```text
Here's Lucky the dog.
A baby dog is often called a puppy
```

å®Œå…¨é™å®šè¯­æ³•çš„å½¢å¼ï¼š

```rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

### TODOï¼š[çˆ¶ trait ç”¨äºåœ¨å¦ä¸€ä¸ª trait ä¸­ä½¿ç”¨æŸ trait çš„åŠŸèƒ½](https://kaisery.github.io/trpl-zh-cn/ch19-03-advanced-traits.html#%E7%88%B6-trait-%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA-trait-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9F%90-trait-%E7%9A%84%E5%8A%9F%E8%83%BD)

### TODOï¼š[newtype æ¨¡å¼ç”¨ä»¥åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ trait](https://kaisery.github.io/trpl-zh-cn/ch19-03-advanced-traits.html#newtype-%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BB%A5%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8-trait)

