ğŸ‘ˆ [[13 æ™ºèƒ½æŒ‡é’ˆ]]

## ä½¿ç”¨çº¿ç¨‹åŒæ—¶è¿è¡Œä»£ç 

### ä½¿ç”¨ `spawn` åˆ›å»ºæ–°çº¿ç¨‹

Rust æ ‡å‡†åº“ä½¿ç”¨ 1:1 çº¿ç¨‹å®ç°ï¼Œå³ä¸€ä¸ªè¯­è¨€çº§çº¿ç¨‹å¯¹åº”ä¸€ä¸ªç³»ç»Ÿçº¿ç¨‹ã€‚

è°ƒç”¨ `thread::spawn` å¹¶ä¼ é€’ä¸€ä¸ªé—­åŒ…ä»¥åˆ›å»ºæ–°çº¿ç¨‹ï¼š

```rust
thread::spawn(|| {
	// ...
});
```

#### ä½¿ç”¨ `join` ç­‰å¾…æ‰€æœ‰çº¿ç¨‹ç»“æŸ

`thread::spawn` è¿”å›ä¸€ä¸ª `JoinHandle`ï¼Œå¯¹å…¶è°ƒç”¨ `join()` å¯ä»¥å¼ºåˆ¶å…¶ç­‰å¾…çº¿ç¨‹ç»“æŸï¼Œç¡®ä¿çº¿ç¨‹åœ¨ä¸»çº¿ç¨‹é€€å‡ºå‰å®Œæˆæ‰§è¡Œï¼š

```rust
fn main() {
	let handle = thread::spawn(|| {
		// ...
	});
	handle.join().unwrap();
}
```

å®é™…ä¸Šï¼Œè°ƒç”¨ `handle.join()` å°†é˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ° `handle` çº¿ç¨‹ç»“æŸï¼ˆå› æ­¤ `join()` è°ƒç”¨çš„ä½ç½®å¾ˆé‡è¦ï¼‰ã€‚

### å°† `move` é—­åŒ…ä¸çº¿ç¨‹ä¸€åŒä½¿ç”¨

å°è¯•åœ¨å­çº¿ç¨‹ä¸­æ‰“å°åœ¨ä¸»çº¿ç¨‹ä¸­å®šä¹‰çš„ vectorï¼š

```rust
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(|| {
        println!("{:?}", v);
    });
    handle.join().unwrap();
}
```

æ— æ³•è¿‡ç¼–ï¼š

```text
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --> src\main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("{:?}", v);
  |                          - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --> src\main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("{:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

é”™è¯¯ä¿¡æ¯è¡¨æ˜é—­åŒ…å¯èƒ½æ¯”å½“å‰å‡½æ•°æ´»å¾—æ›´ä¹…ï¼Œä½†å®ƒæ•è·äº†å½“å‰å‡½æ•°çš„å˜é‡ `v`ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨çº¿ç¨‹ä½¿ç”¨ `v` æ—¶å…¶å¯èƒ½å·²ç»å¤±æ•ˆã€‚æ¯”å¦‚ï¼Œæœ‰å¯èƒ½åœ¨ä¸‹æ–‡è°ƒç”¨ `drop(v)`ï¼š

```rust
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(|| {
        println!("{:?}", v);
    });
    drop(v); // v å¤±æ•ˆ
    handle.join().unwrap();
}
```

ç¼–è¯‘å™¨å»ºè®®ä½¿ç”¨ `move` å¼ºåˆ¶é—­åŒ…è·å– `v` çš„æ‰€æœ‰æƒï¼š

```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
```

```rust
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("{:?}", v);
    });
    handle.join().unwrap();
}
```

### ä½¿ç”¨æ¶ˆæ¯ä¼ é€’åœ¨çº¿ç¨‹é—´ä¼ é€æ•°æ®

**æ¶ˆæ¯ä¼ é€’**(message passing) æ˜¯ä¸€ä¸ªç¡®ä¿å®‰å…¨å¹¶å‘çš„æ–¹å¼ï¼Œçº¿ç¨‹æˆ– actor é€šè¿‡å‘é€åŒ…å«æ•°æ®çš„æ¶ˆæ¯è¿›è¡Œæ²Ÿé€šã€‚

Rust æ ‡å‡†åº“æä¾›äº†ä¸€ä¸ª **ä¿¡é“**(channel) å®ç°ï¼Œè¿™æ˜¯ä¸€ä¸ªé€šç”¨ç¼–ç¨‹æ¦‚å¿µï¼Œè¡¨ç¤ºæ•°æ®ä»ä¸€ä¸ªçº¿ç¨‹å‘é€åˆ°å¦ä¸€ä¸ªã€‚ä¿¡é“ç”± **å‘é€è€…**(transmitter) å’Œ **æ¥æ”¶è€…**(receiver) ç»„æˆã€‚

å¯ä»¥å°†ä¿¡é“æƒ³è±¡æˆä¸€æ¡æ²³æµï¼Œåœ¨ä¸Šæ¸¸æ”¾å…¥ä¸€ä¸ªæ©¡çš®é¸­ï¼ˆå‘é€ï¼‰ï¼Œå®ƒä¼šéšæ°´æµåˆ°è¾¾ä¸‹æ¸¸ï¼ˆæ¥æ”¶ï¼‰ã€‚

è°ƒç”¨ `mpsc::channel` åˆ›å»ºä¸€ä¸ªä¿¡é“ï¼š

```rust
let (tx, rx) = mpsc::channel();
```

`mpsc` æ˜¯ **å¤šç”Ÿäº§è€…ï¼Œå•æ¶ˆè´¹è€…**(multiple producer, single consumer) çš„ç¼©å†™ï¼Œ`tx`ã€`rx` åˆ†åˆ«æ˜¯å‘é€è€…ã€æ¥æ”¶è€…çš„æƒ¯ç”¨ç¼©å†™ã€‚

è®© `tx` åœ¨å­çº¿ç¨‹ä¸­å‘é€æ¶ˆæ¯ï¼Œ`rx` åœ¨ä¸»çº¿ç¨‹ä¸­æ¥æ”¶è¯¥æ¶ˆæ¯ï¼š

```rust
fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

```text
Got: hi
```

### ä¿¡é“ä¸æ‰€æœ‰æƒè½¬ç§»

å°è¯•åœ¨ `tx` å‘é€å®Œ `val` åå†ä½¿ç”¨ `val`ï¼š

```rust
fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("{val}");
    });
    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
```

æ— æ³•è¿‡ç¼–ï¼š

```text
error[E0382]: borrow of moved value: `val`
 --> src\main.rs:9:19
  |
7 |         let val = String::from("hi");
  |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
8 |         tx.send(val).unwrap();
  |                 --- value moved here
9 |         println!("{val}");
  |                   ^^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
8 |         tx.send(val.clone()).unwrap();
  |                    ++++++++
```

å½“çº¿ç¨‹å°†å€¼å‘é€å‡ºå»åï¼Œå…¶ä»–çº¿ç¨‹å¯¹å€¼çš„ä¿®æ”¹å¯èƒ½ä¼šç”±äºä¸ä¸€è‡´è€Œå¯¼è‡´é”™è¯¯æˆ–æ„å¤–çš„ç»“æœï¼Œå› æ­¤ `send()` è¢«è®¾è®¡ä¸ºè·å–å‚æ•°çš„æ‰€æœ‰æƒï¼Œä»¥é˜²åœ¨å‘é€åå†æ„å¤–åœ°ä½¿ç”¨è¿™ä¸ªå€¼ã€‚

### å‘é€å¤šä¸ªå€¼å¹¶è§‚å¯Ÿæ¥æ”¶è€…çš„ç­‰å¾…

ç°åœ¨ï¼Œå­çº¿ç¨‹æœ‰ä¸€ä¸ª `Vec<String>` è¦å‘é€åˆ°ä¸»çº¿ç¨‹ï¼Œå•ç‹¬å‘é€æ¯ä¸ªå­—ç¬¦ä¸²å¹¶æš‚åœ `1` ç§’ï¼›åœ¨ä¸»çº¿ç¨‹ä¸­ï¼Œä¸å†æ˜¾å¼è°ƒç”¨ `recv()`ï¼Œè€Œæ˜¯å°† `rx` ä½œä¸ºä¸€ä¸ªè¿­ä»£å™¨ä½¿ç”¨ï¼Œå½“ä¿¡é“å…³é—­æ—¶è¿­ä»£å™¨ä¹Ÿç»“æŸï¼š

```rust
fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let vals: Vec<String> =
            ["hi", "from", "the", "thread"]
                .iter()
                .map(|x| x.to_string())
                .collect();
        for val in vals {
            thread::sleep(Duration::from_secs(1));
            tx.send(val).unwrap();
        }
    });
    for received in rx {
        println!("Got: {received}");
    }
}
```

è§‚å¯Ÿè¾“å‡ºï¼Œæ¯éš” `1` ç§’æ‰ä¼šæ‰“å°å‡ºæ–°çš„ä¸€è¡Œï¼š

```text
Got: hi
Got: from
Got: the
Got: thread
```

è¿™ç›´è§‚åœ°æ¼”ç¤ºäº†ä¿¡é“çš„ä½œç”¨ï¼šä¸»çº¿ç¨‹ä¸­æ²¡æœ‰ä»»ä½•æš‚åœæˆ–ç­‰å¾…çš„ä»£ç ï¼Œä¹‹æ‰€ä»¥å‡ºç° `1` ç§’çš„é—´éš”ï¼Œå°±æ˜¯å› ä¸ºä¸»çº¿ç¨‹åœ¨ç­‰å¾…ä»å­çº¿ç¨‹ä¸­æ¥æ”¶æ–°çš„æ¶ˆæ¯ã€‚

### é€šè¿‡å…‹éš†å‘é€è€…æ¥åˆ›å»ºå¤šä¸ªç”Ÿäº§è€…

æ—¢ç„¶ `mpsc` çš„æ„æ€æ˜¯æœ‰å¤šä¸ªç”Ÿäº§è€…ï¼Œå¯ä»¥é€šè¿‡å…‹éš† `tx` è·å¾—ä¸€ä¸ªæ–°çš„å‘é€è€…ï¼Œåœ¨ä¸¤ä¸ªå­çº¿ç¨‹ä¸­åˆ†åˆ«å‘åŒä¸€ä¸ªæ¥æ”¶è€…å‘é€æ¶ˆæ¯ï¼š

```rust
fn main() {
    let (tx, rx) = mpsc::channel();
    let tx_cloned = tx.clone(); // å…‹éš†
    thread::spawn(move || {
        let vals: Vec<String> =
            ["hi", "from", "the", "thread"]
                .iter()
                .map(|x| x.to_string())
                .collect();
        for val in vals {
            thread::sleep(Duration::from_secs(1));
            tx.send(val).unwrap();
        }
    });
    thread::spawn(move || { // æ–°å¢çš„å­çº¿ç¨‹
        let vals: Vec<String> =
            ["more", "messages", "for", "you"]
                .iter()
                .map(|x| x.to_string())
                .collect();
        for val in vals {
            thread::sleep(Duration::from_secs(1));
            tx_cloned.send(val).unwrap();
        }
    });
    for received in rx {
        println!("Got: {received}");
    }
}
```

```text
Got: hi
Got: more
Got: messages
Got: from
Got: for
Got: the
Got: thread
Got: you
```

## å…±äº«çŠ¶æ€å¹¶å‘

é™¤äº†æ¶ˆæ¯ä¼ é€’ï¼Œå¤šä¸ªçº¿ç¨‹è¿˜å¯ä»¥æ‹¥æœ‰ç›¸åŒçš„å…±äº«æ•°æ®è¿›è¡Œå¹¶å‘ã€‚

**äº’æ–¥å™¨**(mutex) æ˜¯ mutual exclusion çš„ç¼©å†™ï¼Œæ„å‘³ç€ä»»æ„æ—¶åˆ»åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è®¿é—®æŸäº›æ•°æ®ã€‚äº’æ–¥å™¨é€šè¿‡ **é”**(lock) ç³»ç»Ÿ **ä¿æŠ¤**(guarding) å…¶æ•°æ®ã€‚

äº’æ–¥å™¨éš¾ä»¥ä½¿ç”¨çš„åŸå› åœ¨äºå¿…é¡»ç‰¢è®°å…¶è§„åˆ™ï¼š

- åœ¨è®¿é—®æ•°æ®å‰è¦å…ˆè·å–é”ã€‚
- å¤„ç†å®Œæ•°æ®åè¦é‡Šæ”¾é”ï¼Œä»¥ä¾¿å…¶ä»–çº¿ç¨‹è·å–é”ã€‚

Rust ä¸­ï¼Œç±»å‹ç³»ç»Ÿå’Œæ‰€æœ‰æƒè§„åˆ™ä¿è¯äº†ç¨‹åºä¸ä¼šåœ¨è·å–é”æˆ–è§£é”ä¸Šå‡ºé”™ã€‚

### äº’æ–¥å™¨ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è®¿é—®æ•°æ®

åœ¨å•çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ `Mutex<T>`ï¼Œåœ¨å­å—ä¸­è·å–é”å¹¶ä¿®æ”¹å…¶å€¼ï¼Œç„¶ååœ¨å¤–éƒ¨æ‰“å°å‡ºä¿®æ”¹åçš„å€¼ï¼š

```rust
let m = Mutex::new(5);
{
	let mut num = m.lock().unwrap();
	*num = 6;
}
println!("m = {:?}", m);
```

```text
m = Mutex { data: 6, poisoned: false, .. }
```

è°ƒç”¨ `lock()` å°†å°è¯•è·å–é”ï¼Œå®ƒå°†é˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ°å…¶æ‹¥æœ‰é”ã€‚å¦‚æœé”æ­£è¢«å¦ä¸€ä¸ªçº¿ç¨‹å ç”¨ï¼Œæ­¤æ—¶åè€… panicï¼Œåˆ™ `lock()` è°ƒç”¨å°†å¤±è´¥ä¸”æ²¡æœ‰çº¿ç¨‹èƒ½å¤Ÿè·å–è¿™ä¸ªé”ã€‚

è·å–é”ä¹‹åï¼Œå°±å¯ä»¥å°†è¿”å›å€¼ï¼ˆæ­¤ä¸º `num`ï¼‰è§†ä¸ºä¸€ä¸ªå…¶å†…éƒ¨æ•°æ®çš„å¯å˜å¼•ç”¨ã€‚

`Mutex<T>` æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œç¡®åˆ‡åœ°è¯´ï¼Œ`lock()` è¿”å›ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆ `MutexGuard`ï¼Œå®ƒå®ç°äº† `Deref` trait æŒ‡å‘å…¶å†…éƒ¨æ•°æ®ï¼Œä¹Ÿå®ç°äº† `Drop` trait ä»¥åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾é”ï¼Œç¡®ä¿é”è¢«é‡Šæ”¾ã€‚

### `Mutex<T>` çš„ API

#### åœ¨çº¿ç¨‹é—´å…±äº« `Mutex<T>`

å°è¯•å¯åŠ¨ 10 ä¸ªçº¿ç¨‹ï¼Œåœ¨æ¯ä¸ªçº¿ç¨‹ä¸­å¯¹åŒä¸€ä¸ªè®¡æ•°å™¨ `+1`ï¼ŒçŒœæµ‹è®¡æ•°å™¨å°†ä» `0` åŠ åˆ° `10`ï¼š

```rust
let counter = Mutex::new(0);
let mut handles = vec![];
for _ in 0..10 {
	let handle = thread::spawn(move || {
		let mut num = counter.lock().unwrap();
		*num += 1;
	});
	handles.push(handle);
}
for handle in handles {
	handle.join().unwrap();
}
println!("Result: {}", *counter.lock().unwrap());
```

æ— æ³•è¿‡ç¼–ï¼š

```text
error[E0382]: use of moved value: `counter`

 --> src\main.rs:8:36
  |
5 |     let counter = Mutex::new(0);
  |         ------- move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait
...
8 |         let handle = thread::spawn(move || {
  |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
9 |             let mut num = counter.lock().unwrap();
  |                           ------- use occurs due to use in closure
```

é”™è¯¯ä¿¡æ¯è¡¨æ˜ï¼Œåœ¨å…ˆå‰çš„å¾ªç¯ä¸­ï¼Œ`counter` çš„æ‰€æœ‰æƒè¢«ç§»å…¥é—­åŒ…ï¼Œå› è€Œä¸èƒ½åœ¨åç»­çš„å¾ªç¯ä¸­å†æ¬¡ä½¿ç”¨ã€‚

#### å¤šçº¿ç¨‹å’Œå¤šæ‰€æœ‰æƒ

å°è¯•ç”¨å¤šæ‰€æœ‰æƒæ™ºèƒ½æŒ‡é’ˆ `Rc<T>` ä¿®å¤ä¸Šæ–‡ä»£ç ï¼Œå®ç°å¤šçº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­çš„çº¿ç¨‹å…±äº« `Mutex<T>`ï¼š

```rust
let counter = Rc::new(Mutex::new(0));
let mut handles = vec![];
for _ in 0..10 {
	let counter = Rc::clone(&counter);
	let handle = thread::spawn(move || {
		let mut num = counter.lock().unwrap();
		*num += 1;
	});
	handles.push(handle);
}
for handle in handles {
	handle.join().unwrap();
}
println!("Result: {}", *counter.lock().unwrap());
```

æ— æ³•è¿‡ç¼–ï¼š

```text
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
   --> src\main.rs:10:36
    |
10  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src\main.rs:10:36: 10:43}`
    | |                      |
    | |                      required by a bound introduced by this call
11  | |             let mut num = counter.lock().unwrap();
12  | |             *num += 1;
13  | |         });
    | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely
    |
    = help: within `{closure@src\main.rs:10:36: 10:43}`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`
note: required because it's used within this closure
   --> src\main.rs:10:36
    |
10  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --> C:\Users\spygl\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\std\src\thread\mod.rs:681:8
    |
678 | pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    |        ----- required by a bound in this function
...
681 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`
```

é”™è¯¯ä¿¡æ¯è¡¨æ˜ï¼Œ`Rc<Mutex<i32>> cannot be sent between threads safely`ï¼Œå› ä¸ºå®ƒæ²¡æœ‰å®ç° `Send` traitï¼Œåè€…æ˜¯ä¸€ä¸ªç¡®ä¿ç±»å‹å¯ä»¥å®‰å…¨ç”¨äºå¹¶å‘çš„ traitã€‚

`Rc<T>` åŠ å‡è®¡æ•°çš„æ–¹å¼æ˜¯ `clone()` çš„è°ƒç”¨å’Œå…‹éš†çš„ä¸¢å¼ƒï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸æ˜¯åŸå­æ€§çš„ï¼Œå› è€Œæ— æ³•å®‰å…¨ç”¨äºå¹¶å‘ã€‚

#### åŸå­å¼•ç”¨è®¡æ•° `Arc<T>`

`Arc<T>` æ˜¯ä¸€ä¸ªç±»ä¼¼ `Rc<T>`ã€ä½†å¯ä»¥å®‰å…¨ç”¨äºå¹¶å‘çš„ç±»å‹ï¼Œ`Arc` æ˜¯ **åŸå­å¼•ç”¨è®¡æ•°**(atomically reference counted) çš„ç¼©å†™ã€‚

`Arc<T>` å’Œ `Rc<T>` çš„ API ç›¸åŒï¼Œç›´æ¥ä¿®æ”¹ä¸Šæ–‡ä»£ç ï¼š

```rust
let counter = Arc::new(Mutex::new(0));
let mut handles = vec![];
for _ in 0..10 {
	let counter = Arc::clone(&counter);
	let handle = thread::spawn(move || {
		let mut num = counter.lock().unwrap();
		*num += 1;
	});
	handles.push(handle);
}
for handle in handles {
	handle.join().unwrap();
}
println!("Result: {}", *counter.lock().unwrap());
```

```text
Result: 10
```

è¿è¡Œçš„ç»“æœæ­£å¦‚ä¸€å¼€å§‹çš„æœŸæœ›ã€‚

### `RefCell<T>`/`Rc<T>`Â ä¸Â `Mutex<T>`/`Arc<T>`Â çš„ç›¸ä¼¼æ€§

æ­£å¦‚ `RefCell<T>` å¯ä»¥æ”¹å˜ `Rc<T>` çš„å†…å®¹ï¼Œä¹Ÿå¯ä»¥ç”¨ `Mutex<T>` æ”¹å˜ `Arc<T>` çš„å†…å®¹ã€‚

Rust ä¸èƒ½é¿å… `Mutex<T>` çš„å…¨éƒ¨é€»è¾‘é”™è¯¯ï¼Œæ­£å¦‚ä¸¤ä¸ª `Rc<T>` ç›¸äº’å¼•ç”¨é€ æˆçš„å†…å­˜æ³„æ¼ï¼Œ`Mutex<T>` ä¹Ÿæœ‰é€ æˆæ­»é”çš„é£é™©ã€‚

## ä½¿ç”¨Â `Sync`Â å’ŒÂ `Send`Â trait çš„å¯æ‰©å±•å¹¶å‘

å¹¶å‘å‡ ä¹å…¨éƒ¨åŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼Œè€Œé Rust æœ¬èº«ã€‚ä½† `std::marker` ä¸­çš„ `Sync` å’Œ `Send` trait æ˜¯è¯­è¨€æœ¬èº«ç‰¹æ€§ã€‚

### é€šè¿‡ `Send` å…è®¸åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ

å®ç°äº† `Send` trait çš„ç±»å‹ï¼Œå…¶å€¼çš„æ‰€æœ‰æƒå¯ä»¥åœ¨çº¿ç¨‹é—´ä¼ é€ã€‚å‡ ä¹æ‰€æœ‰ç±»å‹éƒ½å®ç°äº† `Send`ï¼Œä½†å¦‚ `Rc<T>` ç­‰å¹¶ä¸ã€‚

### `Sync` å…è®¸å¤šçº¿ç¨‹è®¿é—®

å®ç°äº† `Sync` trait çš„ç±»å‹ï¼Œå…¶å¯ä»¥å®‰å…¨åœ°åœ¨å¤šä¸ªçº¿ç¨‹ä¸­æ‹¥æœ‰å…¶å€¼çš„å¼•ç”¨ã€‚åŸºæœ¬ç±»å‹éƒ½å®ç°äº† `Sync`ï¼Œç”±åŸºæœ¬ç±»å‹æ„æˆçš„ç±»å‹ä¹Ÿæ˜¯ã€‚

å¯¹ç±»å‹ `T`ï¼Œå¦‚æœ `&T` å®ç°äº† `Send`ï¼Œåˆ™ `T` å®ç°äº† `Sync`ã€‚

### æ‰‹åŠ¨å®ç° `Send` å’Œ `Sync` æ˜¯ä¸å®‰å…¨çš„

ğŸ‘‰ [[15 é¢å‘å¯¹è±¡]]