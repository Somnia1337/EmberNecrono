上一页笔记中的图片：

![[28-3.png|450]]

关注其中的`#define INTGER int`，这条预处理指令相当于给基本数据类型int起了一个别名INTGER。

在初识C语言时，学习过的知识：C本身没有规定类型的sizeof大小，具体由编译器和平台决定，下图示意了一种可能的情况：

![[29-1.png|450]]

那么一段使用了较大int数据的代码，在其他平台上可能会出现溢出错误。

为了避免这种错误，可以使用数据类型的别名（不是内置在stdio.h中的）：

![[29-2.png|450]]

同样是int32_t（表示32位二进制/4个字节的整型），在VS2019中为int，在其他平台可能为long，所以用别名代替的整型类型在不同平台下也能保证sizeof大小是一致的。

### 关键词typedef

格式：typedef *数据类型* *别名*;

例如：typedef int int32_t; 定义后的int32_t可以像int一样使用。

**别名也有作用域**，规则与标识符一致（见[[27 标识符作用]]）。

别名常用于struct，用法：

![[29-3.png|450]]

这样就定义了一个结构类型名person，随后直接使用person即可声明结构变量（以前每次声明都需要关键词struct+别名，如下图）（注意以前的别名和现在的类型别名==位置的区别==）。

![[25-6.png|300]]

### typedef与#define

1. \#define可以为值设置一个别名，而typedef不行。例如`#define PI 3.14`。

2. \#define由预处理器处理，并且会修改代码；typedef由编译器处理。

3. typedef比#define更适合为==数据类型==设置别名。

例如用typedef设置字符型指针的别名并声明两个标识符，替换后如下图：

![[29-4.png|300]]

name1被正确声明为char*，而name2则被错误声明为char。

使用typedef则不会出现此问题：

![[29-5.png|300]]

### 提高可移植性

C语言发明者考虑到了整型在不同平台可能存在数据溢出的问题，所以编译器会自动根据本平台的整形大小范围设置对应的别名，这需要包含头文件stdint.h。

现在已经保证了整型的可移植性，为了printf能正确打印整型，不同平台的转换说明符（%d等）也需要一致化，这需要包含头文件inttypes.h。

因此，对于32位二进制/4字节整型数据的移植，可以写出如下代码（包含第2个头文件inttypes.h即可）：

![[29-6.png|450]]