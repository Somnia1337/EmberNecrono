### 内存地址

字节：8个晶体管为一组的数据存储单元，可以看作一个“储藏室”。

内存地址：“储藏室”的编号。

除了char类型只需一个“储藏室”，其他类型都需要多个，为了明确一个数据对象的存储位置，一般以==首地址+存储空间大小==的形式来表示。

### 指针

**取地址运算符&**：写在数据对象左侧，获取数据对象的首地址和存储空间大小。

声明格式：*目标数据类型* * *变量名*;（三个元素之间可加任意空格）。

```c
char c;
char* pc = &c;
//char*pc、char * pc也正确
```

==指针类型的值就是目标数据对象的首地址==。

![[17-7.png|450]]

指针类型对应的==目标数据类型标识了存储空间大小==，因此，尝试将不同目标数据类型的指针互相赋值无法通过编译，因为这会导致数据长度改变。

**取值运算符\***：写在指针类型左侧，根据指针中存储的首地址和存储空间大小找到目标数据对象。

```c
#include <stdio.h>

int main()
{
	int n = 0;
	int* pn = &n;
	char c = 0;
	char* pc = &c;

	*pn = 123;
	*pc = 'a';
  	//对指针取地址并赋值

	printf("%d\n", n);
	printf("%d\n", *pn);
	printf("%c\n",c);
	printf("%c\n", *pc);
  	//打印，发现原变量也被赋值

	return 0;
}
```

用转换操作%u打印指针的值，即首地址。

### 占用空间

用sizeof分别测量char、int类型指针占用空间，结果均为4字节，==因为它们存储的都是目标变量的地址==。

与编译器和编译配置相关。

![[17-8.png|450]]

![[17-9.png|450]]

### 强制转换

![[17-11.png|450]]

![[17-10.png|450]]

转换后，由于指针的目标类型由int变为char，但是首地址没有变，所以在内存区读取数据时仅读取1字节，造成取值不正确。

### 指针与整型加减

尝试让指针变量从地址100开始加减

![[17-1.png|200]]

![[17-4.png|200]]

这段代码无法通过编译，因为左侧的指针变量存储了首地址、目标数据大小两个量，而右侧仅有一个量。

![[17-2.png|300]]

使用强制转换修改之后，可以运行，打印结果如下：

![[17-3.png]]

**步长**：sizeof(目标数据对象)。指针±n，首地址±（n\*步长）个字节。

### 同类型指针相减

![[17-5.png|450]]

![[17-6.png|300]]

&arr\[5\] - &arr\[0\] = 5，而不是20，这是因为步长产生的影响。

同类型指针相减，结果为==两个首地址之差 / 步长==。

其它的运算不具有实际意义（指针类型与整型乘除，同类型指针相加/乘除等），且无法通过编译。