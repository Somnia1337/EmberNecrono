### \#include

**头文件stdio.h**：包含常见函数（如printf）的定义。

**指令`#include <stdio.h>`**：预处理器将头文件stdio.h包含的==函数定义==写入代码，然后删除预处理指令，修改后进入编译器的代码如下：

![[31-1.png|450]]

`#include`的两种格式：

![[31-2.png|450]]

头文件stdio.h属于编译器自带文件，位于编译器的包含目录中。

### 多文件代码

##### 任务：编写一个简化版的print函数，并通过`#include`调用

新建源文件print.cpp，写入print函数定义：

![[31-14.png|300]]

在另一个源文件中写入预处理指令`#include "print.cpp"`，并通过main调用print：

![[31-15.png|300]]

出现一个**链接错误**：LNK1169（LNK为link）。

从代码到可执行文件的构建过程：

![[31-3.png|450]]

==编译器==对每个源文件独立地编译，==生成对应的目标文件（.obj）==。

编译完成后，==链接器将所有目标文件链接为一个可执行文件==。

问题根源：每个文件独立地被编译，==编译主函数所在文件时，标识符print无法识别==。

解决：使用函数声明。本例中只有一个函数，如果有很多个，还需要重复声明所有函数，不如把声明单独写在一个文件里面，这个文件就是**头文件**。

![[31-4.png|450]]

注意：==自己写的头文件==不在编译器的包含目录中，因此==需要引号""==（而非尖括号<>)。

完整的多文件结构示意：

![[31-5.png|450]]

##### 实例：人员信息录入与显示

定义==结构模板Person==存储人员信息、返回值类型为Person的==函数newPerson==读取人员信息、参数类型为const Person\*的==函数printPerson==打印人员信息（使用指针传递结构，减小数据在函数之间传递的成本）。

现将代码模块化：

把处理人员信息相关的函数等代码抽离到单独的==源文件person.cpp==中，再创建一个==头文件person.h写入person.cpp内的函数声明==，然后==在main.cpp中写入预处理指令`#include "person.h"`==。

现在，Person的定义同时存在于3个文件中，但程序仍然可以通过编译、链接，构建成一个可执行文件，==因为Person的定义位于代码块外，它的作用域是文件作用域，在3个文件中的作用域并未重叠==。

**标识符重定义错误的本质**：==同名标识符的作用域重叠==。

在修改Person（比如增加一个成员age）时，需要同步修改不同文件中的代码块，如果能实现自动同步修改就好了。这是可以做到的：==将源文件person.cpp中的Person定义删去、改为`#include "person.h"`==，这样，Person的定义仅存在于头文件person.h，只需改动person.h即可。

多文件的模型：

xxx.cpp：==包含一系列函数定义==；==需要包含xxx.h==。

xxx.h：包含符号常量、宏函数、函数声明、结构声明、类型定义；它==向main.cpp声明有哪些函数可以调用==。

main.cpp：调用相关函数；==需要包含xxx.h==。

![[31-6.png|450]]

### 头文件守卫

如果==在同一个源文件中重复包含同一个头文件==，就会引发标识符重定义错误.

这个问题看似容易避免，但其常常非常隐蔽、且层层嵌套，例如：

![[31-7.png|450]]

这样的层叠错误非常难以排查。

目标：无论多么错综复杂的包含关系，==同一个头文件，只允许其被包含一次==。

可以借助==条件编译==。

![[31-8.png|300]]

![[31-9.png|300]]

原理：==用条件编译指令将头文件指令包括起来==，#ifndef后接全大写字母表示的对应头文件名，如果该宏还未被定义，则定义该宏，并包含头文件；此后，再遇到同样的条件编译语句时，由于宏已被定义，所以将不会再次包含这个头文件。

用头文件守卫==防止嵌套包含==：

![[31-10.png|300]]

守卫后的条件编译命令：

![[31-11.png|300]]

由于student.h中又包含了person.h，所以==还需要再次展开包含==：

![[31-12.png|300]]

此外，还可以用指令`#pragma once`守卫头文件。

两种守卫方法的对比如下：

![[31-13.png|450]]