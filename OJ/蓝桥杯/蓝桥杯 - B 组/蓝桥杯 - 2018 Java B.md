### 题目

#### 1. 第几天

2000 年的 1 月 1 日，是那一年的第 1 天。

那么，2000 年的 5 月 4 日，是那一年的第几天？

注意：需要提交的是一个整数，不要填写任何多余内容。

#### 2. 方格计数

如图所示，在二维平面上有无数个 $1 \times 1$ 的小方格。

![[蓝桥杯 - 2018 - p1.png|300]]

我们以某个小方格的一个顶点为圆心画一个半径为 $1000$ 的圆。

你能计算出这个圆里有多少个完整的小方格吗？ 

注意：需要提交的是一个整数，不要填写任何多余内容。

#### 3. 复数幂

设 $i$ 为虚数单位。对于任意正整数 $n$，$(2 + 3 i)^n$ 的实部和虚部都是整数。

求 $(2 + 3 i)^{123456}$ 等于多少？ 即 $(2 + 3 i)$ 的 $123456$ 次幂，这个数字很大，要求精确表示。

答案写成 "实部 $\pm$ 虚部 $i$" 的形式，实部和虚部都是整数（不能用科学计数法表示），中间任何地方都不加空格，实部为正时前面不加正号。$(2 + 3 i)^2$ 写成：$- 5 + 12 i$，$(2 + 3 i)^5$ 写成：$122 - 597 i$

注意：需要提交的是一个很庞大的复数，不要填写任何多余内容。

#### 4. 测试次数

x 星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。

各大厂商也就纷纷推出各种耐摔型手机。x 星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。

x 星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的 2 楼。

如果手机从第 7 层扔下去没摔坏，但第 8 层摔坏了，则手机耐摔指数 $= 7$。

特别地，如果手机从第 1 层扔下去就坏了，则耐摔指数 $= 0$。

如果到了塔的最高层第 n 层扔没摔坏，则耐摔指数 $= n$。

为了减少测试次数，从每个厂家抽样 3 部手机参加测试。

某次测试的塔高为 1000 层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？

请填写这个最多测试次数。

注意：需要填写的是一个整数，不要填写任何多余内容。

#### 5. 快速排序

以下代码可以从数组 `a[]` 中找出第 `k` 小的元素 

它使用了类似快速排序中的分治算法，期望时间复杂度是 $O(N)$ 的。

请仔细阅读分析源码，填写划线部分缺失的内容。

```java
import java.util.Random;
public class Main{
	public static int quickSelect(int a[], int l, int r, int k) {
		Random rand = new Random();
		int p = rand.nextInt(r - l + 1) + l;
		int x = a[p];
		int tmp = a[p]; a[p] = a[r]; a[r] = tmp;
		int i = l, j = r;
		while(i < j) {
                	while(i < j && a[i] < x) i++;
                	if(i < j) {
                        	a[j] = a[i];
                        	j--;
                	}
                	while(i < j && a[j] > x) j--;
                	if(i < j) {
                        	a[i] = a[j];
                        	i++;
                	}
        	}
        	a[i] = x;
        	p = i;
        	if(i - l + 1 == k) return a[i];
        	if(i - l + 1 < k) return quickSelect( _________________________________ ); // 填空
        	else return quickSelect(a, l, i - 1, k);	
	}
	public static void main(String args[]) {
		int [] a = {1, 4, 2, 8, 5, 7};
		System.out.println(quickSelect(a, 0, 5, 4));
	}
}
```

注意：只提交划线部分缺少的代码，不要抄写任何已经存在的代码或符号。

#### 6. 递增三元组

给定三个整数数组

`A = [A1, A2, ... AN]`, 

`B = [B1, B2, ... BN]`, 

`C = [C1, C2, ... CN]`，

请你统计有多少个三元组 `(i, j, k)` 满足：

1. `1 <= i, j, k <= n`
2. `Ai < Bj < Ck`

【输入格式】

第一行包含一个整数 `N`。

第二行包含 `N` 个整数 `A1, A2, ... AN`。

第三行包含 `N` 个整数 `B1, B2, ... BN`。

第四行包含 `N` 个整数 `C1, C2, ... CN`。

- 对于 30% 的数据，`1 <= N <= 100`
- 对于 60% 的数据，`1 <= N <= 1000`
- 对于 100% 的数据，`1 <= N <= 100000`，`0 <= Ai, Bi, Ci <= 100000`

【输出格式】

一个整数表示答案

【输入样例】

```text
3
1 1 1
2 2 2
3 3 3
```

【输出样例】

```text
27
```

资源约定：

- 峰值内存消耗（含虚拟机） `< 256` M
- CPU消耗  `< 1000` ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

不要使用 `package` 语句。不要使用 JDK 1.7 及以上版本的特性。

主类的名字必须是：`Main`，否则按无效代码处理。

#### 7. 螺旋折线

![[蓝桥杯 - 2018 - p2.png|300]]

如图所示的螺旋折线经过平面上所有整点恰好一次。

对于整点 `(X, Y)`，我们定义它到原点的距离 `dis(X, Y)` 是从原点到 `(X, Y)` 的螺旋折线段的长度。

例如 `dis(0, 1) = 3`，`dis(-2, -1) = 9`。

给出整点坐标 `(X, Y)`，你能计算出 `dis(X, Y)` 吗？

【输入格式】

`X` 和 `Y`。

- 对于 40% 的数据，`-1000 <= X, Y <= 1000`
- 对于 70% 的数据，`-100000 <= X, Y <= 100000`
- 对于 100% 的数据, `-1000000000 <= X, Y <= 1000000000`

【输出格式】

输出 `dis(X, Y)`

【输入样例】

```text
0 1
```

【输出样例】

```text
3
```

资源约定：

- 峰值内存消耗（含虚拟机） `< 256` M
- CPU消耗  `< 1000` ms

#### 8. 日志统计

小明维护着一个程序员论坛。现在他收集了一份"点赞"日志，日志共有 `N` 行。其中每一行的格式是：

```text
ts id
```

表示在 `ts` 时刻编号 `id` 的帖子收到一个"赞"。

现在小明想统计有哪些帖子曾经是"热帖"。如果一个帖子曾在任意一个长度为 `D` 的时间段内收到不少于 `K` 个赞，小明就认为这个帖子曾是"热帖"。

具体来说，如果存在某个时刻 `T` 满足该帖在 $[T, T + D)$ 这段时间内（注意是左闭右开区间）收到不少于 `K` 个赞，该帖就曾是"热帖"。

给定日志，请你帮助小明统计出所有曾是"热帖"的帖子编号。

【输入格式】

第一行包含三个整数 `N`、`D` 和 `K`。

以下 `N` 行每行一条日志，包含两个整数 `ts` 和 `id`。

- 对于 50% 的数据，`1 <= K <= N <= 1000`
- 对于 100% 的数据，`1 <= K <= N <= 100000`，`0 <= ts <= 100000`，`0 <= id <= 100000`

【输出格式】

按从小到大的顺序输出热帖 `id`。每个 `id` 一行。

【输入样例】

```text
7 10 2
0 1
0 10
10 10
10 1
9 1
100 3
100 3
```

【输出样例】

```text
1
3
```

资源约定：

- 峰值内存消耗（含虚拟机） `< 256` M
- CPU消耗  `< 1000` ms

#### 9. 全球变暖

你有一张某海域 $N \times N$ 像素的照片，"." 表示海洋、"#" 表示陆地，如下所示：

```text
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中"上下左右"四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 2 座岛屿。

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。

例如上图中的海域未来会变成如下样子：

```text
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。

【输入格式】

第一行包含一个整数 `N`。(`1 <= N <= 1000`)  
以下 `N` 行 `N` 列代表一张海域照片。

照片保证第 `1` 行、第 `1` 列、第 `N` 行、第 `N` 列的像素都是海洋。

【输出格式】

一个整数表示答案。

【输入样例】

```text
7
.......
.##....
.##....
....##.
..####.
...###.
.......
```

【输出样例】

```text
1
```

资源约定：

- 峰值内存消耗（含虚拟机） `< 256` M
- CPU消耗  `< 1000` ms

#### 10. 堆的计数

我们知道包含 `N` 个元素的堆可以看成是一棵包含 `N` 个节点的完全二叉树。

每个节点有一个权值。对于小根堆来说，父节点的权值一定小于其子节点的权值。

假设 `N` 个节点的权值分别是 `1`~`N`，你能求出一共有多少种不同的小根堆吗？  

例如对于 `N == 4` 有如下 3 种：

```text
    1
   / \
  2   3
 /
4
```

```text
    1
   / \
  3   2
 /
4
```

```text
    1
   / \
  2   4
 /
3
```

由于数量可能超过整型范围，你只需要输出结果除以 `1000000009` 的余数。

【输入格式】

一个整数 `N`。

- 对于 40% 的数据，`1 <= N <= 1000`
- 对于 70% 的数据，`1 <= N <= 10000`
- 对于 100% 的数据，`1 <= N <= 100000`

【输出格式】

一个整数表示答案。

【输入样例】

```text
4
```

【输出样例】

```text
3
```

资源约定：

- 峰值内存消耗（含虚拟机） `< 256` M
- CPU消耗  `< 1000` ms

### 作答

#### 8. 日志统计

```java
StringTokenizer st = new StringTokenizer(in.readLine());
int n = Integer.parseInt(st.nextToken());
int d = Integer.parseInt(st.nextToken());
int k = Integer.parseInt(st.nextToken());
Map<Integer, List<Integer>> g = new HashMap<>();
while (n-- > 0) {
	st = new StringTokenizer(in.readLine());
	int ts = Integer.parseInt(st.nextToken()), id = Integer.parseInt(st.nextToken());
	g.computeIfAbsent(id, e -> new ArrayList<>()).add(ts);
}
List<Integer> ans = new ArrayList<>();
for (Map.Entry<Integer, List<Integer>> e : g.entrySet()) {
	List<Integer> ts = e.getValue();
	int size = ts.size();
	if (size < k) continue;
	Collections.sort(ts);
	int l = 0, r = 0;
	while (r < size) {
		int R = ts.get(r);
		while (l < r && ts.get(l) <= R - d) l++;
		if (r - l + 1 >= k) {
			ans.add(e.getKey());
			break;
		}
		r++;
	}
}
Collections.sort(ans);
for (int x : ans) out.println(x);
```