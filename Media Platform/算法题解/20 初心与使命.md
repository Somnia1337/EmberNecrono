## 1. ä¸¤æ•°ä¹‹å’Œ

#### å‰è¨€

ã€Œç®—æ³•é¢˜è§£ã€ç³»åˆ—è‡´åŠ›äºåˆ†äº«æœ‰ä»·å€¼çš„é¢˜ç›®ã€æ¢è®¨æ›´ä¼˜ç§€çš„è§£æ³•ã€‚

è¿™æ˜¯æœ¬ç³»åˆ—çš„ç¬¬ 20 ç¯‡é¢˜è§£ï¼Œæ›´å¤šé¢˜è§£å…³æ³¨ Somnia1337@åŠ›æ‰£ã€‚

ä¸å¿˜åˆå¿ƒï¼Œæ–¹èƒ½ä¸è¾±ä½¿å‘½ã€‚ä¸çŸ¥ä¸è§‰é—´ï¼Œè¿™å·²ç»æ˜¯ã€Œå¯¹è¯ Somniaã€å¸¦ç»™å¤§å®¶çš„ç¬¬ 20 ç¯‡é¢˜è§£äº†ï¼Œä¸€èµ·ç”¨ã€ŒRust / Java / Python / Goã€4 ç§è¯­è¨€å›é¡¾æ¢¦å¼€å§‹çš„åœ°æ–¹å§ï¼

#### é¢˜ç›®æè¿°

> éš¾åº¦ï¼šğŸŸ¢ç®€å•
> 
> æ ‡ç­¾ï¼š\#æ•°ç»„ \#å“ˆå¸Œè¡¨

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„Â `nums`Â å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼Â `target`ï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºÂ **å’Œä¸ºç›®æ ‡å€¼**Â `target`Â  çš„é‚£Â **ä¸¤ä¸ª**Â æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

```text
è¾“å…¥: nums=[2,7,11,15], target=9
è¾“å‡º: [0,1]
è§£é‡Š: å› ä¸º nums[0]+nums[1]=9, è¿”å› [0, 1]
```

#### 1. æš´åŠ›

åŒé‡ `for` æšä¸¾æ¯ä¸ªæ•°å¯¹ï¼Œæ£€æŸ¥å…¶å’Œæ˜¯å¦ä¸º `target`ã€‚

##### Rust

```rust
impl Solution {
    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        for i in 0..nums.len() {
            for j in i+1..nums.len() {
                if nums[i] + nums[j] == target {
                    return vec![i as i32, j as i32];
                }
            }
        }
        unreachable!()
    }
}
```

##### Java

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
}
```

##### Python

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, x in enumerate(nums):
            for j in range(i + 1, len(nums)):
                if x + nums[j] == target:
                    return [i, j]
```

##### Go

```go
func twoSum(nums []int, target int) []int {
    for i, x := range nums {
        for j := i + 1; j < len(nums); j++ {
            if x+nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil
}
```

#### 2. å“ˆå¸Œè¡¨

å“ˆå¸Œè¡¨è®°å½• `{å€¼: ä¸‹æ ‡}`ï¼Œéå† `nums`ï¼Œå¯¹æ¯ä¸ªå…ƒç´  `x`ï¼Œæ£€æŸ¥å…¶è¡¥æ•° `target - x` æ˜¯å¦å­˜åœ¨ï¼Œæ‰¾åˆ°æ—¶è¿”å›ä¸¤å…ƒç´ ä¸‹æ ‡ã€‚

##### Rust

```rust
use std::collections::HashMap;

impl Solution {
    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let mut vis = HashMap::new();
        for (i, &x) in nums.iter().enumerate() {
            if let Some(&j) = vis.get(&(target - x)) {
                return vec![i as i32, j as i32];
            }
            vis.insert(x, i);
        }
        unreachable!()
    }
}
```

##### Java

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> vis = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (vis.containsKey(target - nums[i])) {
                return new int[]{i, vis.get(target - nums[i])};
            }
            vis.put(nums[i], i);
        }
        return null;
    }
}
```

##### Python

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        vis = {}
        for i, x in enumerate(nums):
            if target - x in vis:
                return [i, vis[target - x]]
            vis[x] = i
```

##### Go

```go
func twoSum(nums []int, target int) []int {
    vis := make(map[int]int)
    for i, x := range nums {
        if j, ok := vis[target-x]; ok {
            return []int{i, j}
        }
        vis[x] = i
    }
    return nil
}
```

#### æœ€å

æ›´å¤šç³»åˆ—ã€Œå¤–æºæ¨æ–‡ã€&ã€Œç”Ÿæ´»åˆ†äº«ã€å…³æ³¨å…¬ä¼—å·ï¼š