## Write Number in Expanded Form

#### 前言

> Rust 不适合写题，但我就是玩！——Somnia1337

#### 题目描述

本题目的在线练习：

```text
https://www.codewars.com/kata/5842df8ccbd22792a4000245
```

> 难度：6 kyu（Codewars 难度评级，从 1:最难 到 8:最简单）
> 
> 标签：\#字符串 \#数学

给定一个数字，返回它的扩展形式（见示例）。

```text
expanded_form(1);     // 返回 "1"
expanded_form(42);    // 返回 "40 + 2"
expanded_form(70304); // 返回 "70000 + 300 + 4"
```

注意 `0` 不计入（见示例 3）。

#### 解题思路

模拟，完毕。

```rust
fn expanded_form(n: u64) -> String {
    let mut digits = vec![];
```

等等，那我为什么不用 Jvav 写呢🤡

试一下🦀强大的零成本抽象！

假设输入为 `70304`，模拟的过程可以抽象为：

1. 转换为字符数组：`['7','0','3','0','4']`
2. 筛选出非 `0` 位：`['7','3','4']`
3. 对剩余位，根据其原位置追加相应数量的 `'0'`：`["70000","300","4"]`
4. 用加号连接所有结果串：`"70000 + 300 + 4"`。

唯一复杂的就是第 3 步，实现时可以曲线救国：

1. 反转数组：`['4','3','7']`
2. 为每一项附加位置编号：`[0,2,4]`
3. 追加位置编号数量的 `'0'`：`["4","300","70000"]`
4. 反转回来：`["70000","300","4"]`

开始抽象：

```rust
fn expanded_form(n: u64) -> String {
    n.to_string() // 转换为 String
     .chars() // 获取 char 数组的迭代器
     .rev() // 反转
     .zip(0..) // 添加位置编号, 从 0 开始
     .filter(|&(c, _)| c > '0') // 筛掉 0
     .map(|(c, p)| format!("{}{}", c, "0".repeat(p))) // 追加尾 0
     .collect::<Vec<_>>() // 收集到 Vec<String>
     .into_iter() // 转换为迭代器
     .rev() // 反转
     .collect::<Vec<_>>() // 收集到 Vec<String>
     .join(" + ") // 用加号连接每一项
}
```

朝链 11，夕死可矣🫠

#### 最后

更多系列「外源推文」&「生活分享」关注公众号：